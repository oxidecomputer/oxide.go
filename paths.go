// Code generated by `generate`. DO NOT EDIT.

package oxide

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
)

// List: List racks in the system.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *RacksService) List(limit int, pageToken string, sortBy IdSortMode) (*RackResultsPage, error) {
	// Create the url.
	path := "/hardware/racks"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RackResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List racks in the system.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *RacksService) ListAllPages(sortBy IdSortMode) (*[]Rack, error) {

	var allPages []Rack
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch information about a particular rack.
//
// Parameters:
//	- `rackId`: The rack's unique ID.
func (s *RacksService) Get(rackID string) (*Rack, error) {
	// Create the url.
	path := "/hardware/racks/{{.rack_id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"rack_id": rackID,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Rack
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List sleds in the system.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *SledsService) List(limit int, pageToken string, sortBy IdSortMode) (*SledResultsPage, error) {
	// Create the url.
	path := "/hardware/sleds"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SledResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List sleds in the system.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *SledsService) ListAllPages(sortBy IdSortMode) (*[]Sled, error) {

	var allPages []Sled
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch information about a sled in the system.
//
// Parameters:
//	- `sledId`: The sled's unique ID.
func (s *SledsService) Get(sledID string) (*Sled, error) {
	// Create the url.
	path := "/hardware/sleds/{{.sled_id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sled_id": sledID,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Sled
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SpoofLogin
func (s *HiddenService) SpoofLogin(j *LoginParams) error {
	// Create the url.
	path := "/login"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// Logout
func (s *HiddenService) Logout() error {
	// Create the url.
	path := "/logout"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List all organizations.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *OrganizationsService) List(limit int, pageToken string, sortBy NameOrIdSortMode) (*OrganizationResultsPage, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body OrganizationResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List all organizations.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *OrganizationsService) ListAllPages(sortBy NameOrIdSortMode) (*[]Organization, error) {

	var allPages []Organization
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a new organization.
func (s *OrganizationsService) Create(j *OrganizationCreate) (*Organization, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Fetch a specific organization
//
// Parameters:
//	- `organizationName`: The organization's unique name.
func (s *OrganizationsService) Get(organizationName Name) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a specific organization.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
func (s *OrganizationsService) Put(organizationName Name, j *OrganizationUpdate) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a specific organization.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
func (s *OrganizationsService) Delete(organizationName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List all projects.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *ProjectsService) List(limit int, pageToken string, sortBy NameOrIdSortMode, organizationName Name) (*ProjectResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ProjectResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List all projects.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `sortBy`
func (s *ProjectsService) ListAllPages(sortBy NameOrIdSortMode, organizationName Name) (*[]Project, error) {

	var allPages []Project
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a new project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
func (s *ProjectsService) Create(organizationName Name, j *ProjectCreate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Fetch a specific project
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *ProjectsService) Get(organizationName Name, projectName Name) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a specific project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *ProjectsService) Put(organizationName Name, projectName Name, j *ProjectUpdate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a specific project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *ProjectsService) Delete(organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List disks in a project.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *DisksService) List(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List disks in a project.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *DisksService) ListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Disk, error) {

	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a disk in a project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *DisksService) Create(organizationName Name, projectName Name, j *DiskCreate) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Fetch a single disk in a project.
//
// Parameters:
//	- `diskName`
//	- `organizationName`
//	- `projectName`
func (s *DisksService) Get(diskName Name, organizationName Name, projectName Name) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk_name":         string(diskName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a disk from a project.
//
// Parameters:
//	- `diskName`
//	- `organizationName`
//	- `projectName`
func (s *DisksService) Delete(diskName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk_name":         string(diskName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List instances in a project.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *InstancesService) List(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*InstanceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body InstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List instances in a project.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *InstancesService) ListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Instance, error) {

	var allPages []Instance
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create an instance in a project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *InstancesService) Create(organizationName Name, projectName Name, j *InstanceCreate) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get an instance in a project.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Get(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete an instance from a project.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Delete(instanceName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// DisksList: List disks attached to this instance.
//
// To iterate over all pages, use the `DisksListAllPages` method, instead.
//
// Parameters:
//	- `instanceName`
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) DisksList(limit int, pageToken string, sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DisksListAllPages: List disks attached to this instance.
//
// This method is a wrapper around the `DisksList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) DisksListAllPages(sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*[]Disk, error) {

	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := s.DisksList(limit, pageToken, sortBy, instanceName, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // DisksAttach
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) DisksAttach(instanceName Name, organizationName Name, projectName Name, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/attach"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DisksDetach
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) DisksDetach(instanceName Name, organizationName Name, projectName Name, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/detach"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Migrate: Migrate an instance to a different propolis-server, possibly on a different sled.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Migrate(instanceName Name, organizationName Name, projectName Name, j *InstanceMigrate) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/migrate"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesList: List network interfaces attached to this instance.
//
// To iterate over all pages, use the `NetworkInterfacesListAllPages` method, instead.
//
// Parameters:
//	- `instanceName`
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) NetworkInterfacesList(limit int, pageToken string, sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*NetworkInterfaceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesListAllPages: List network interfaces attached to this instance.
//
// This method is a wrapper around the `NetworkInterfacesList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) NetworkInterfacesListAllPages(sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*[]NetworkInterface, error) {

	var allPages []NetworkInterface
	pageToken := ""
	limit := 100
	for {
		page, err := s.NetworkInterfacesList(limit, pageToken, sortBy, instanceName, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // NetworkInterfacesCreate: Create a network interface for an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) NetworkInterfacesCreate(instanceName Name, organizationName Name, projectName Name, j *NetworkInterfaceCreate) (*NetworkInterface, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesGetInterface: Get an interface attached to an instance.
//
// Parameters:
//	- `instanceName`
//	- `interfaceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) NetworkInterfacesGetInterface(instanceName Name, interfaceName Name, organizationName Name, projectName Name) (*NetworkInterface, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces/{{.interface_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"interface_name":    string(interfaceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesDeleteInterface: Detach a network interface from an instance.
//
// Parameters:
//	- `instanceName`
//	- `interfaceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) NetworkInterfacesDeleteInterface(instanceName Name, interfaceName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces/{{.interface_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"interface_name":    string(interfaceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// Reboot: Reboot an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Reboot(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/reboot"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Start: Boot an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Start(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/start"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Stop: Halt an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Stop(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/stop"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List snapshots in a project.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *SnapshotsService) List(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*SnapshotResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SnapshotResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List snapshots in a project.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *SnapshotsService) ListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Snapshot, error) {

	var allPages []Snapshot
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a snapshot of a disk.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *SnapshotsService) Create(organizationName Name, projectName Name, j *SnapshotCreate) (*Snapshot, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get a snapshot in a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `snapshotName`
func (s *SnapshotsService) Get(organizationName Name, projectName Name, snapshotName Name) (*Snapshot, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots/{{.snapshot_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"snapshot_name":     string(snapshotName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a snapshot from a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `snapshotName`
func (s *SnapshotsService) Delete(organizationName Name, projectName Name, snapshotName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots/{{.snapshot_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"snapshot_name":     string(snapshotName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List VPCs in a project.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *VpcsService) List(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*VPCResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List VPCs in a project.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *VpcsService) ListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]VPC, error) {

	var allPages []VPC
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a VPC in a project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *VpcsService) Create(organizationName Name, projectName Name, j *VPCCreate) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get a VPC in a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *VpcsService) Get(organizationName Name, projectName Name, vpcName Name) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *VpcsService) Put(organizationName Name, projectName Name, vpcName Name, j *VPCUpdate) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a vpc from a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *VpcsService) Delete(organizationName Name, projectName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// RulesList: List firewall rules for a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *FirewallService) RulesList(organizationName Name, projectName Name, vpcName Name) (*FirewallRules, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RulesPut: Replace the firewall rules for a VPC
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *FirewallService) RulesPut(organizationName Name, projectName Name, vpcName Name, j *FirewallRuleUpdateParams) (*FirewallRules, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List VPC Custom and System Routers
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *RoutersService) List(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*RouterResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"sort_by":           string(sortBy),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List VPC Custom and System Routers
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *RoutersService) ListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]Router, error) {

	var allPages []Router
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *RoutersService) Create(organizationName Name, projectName Name, vpcName Name, j *RouterCreate) (*Router, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Router
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *RoutersService) Get(organizationName Name, projectName Name, routerName Name, vpcName Name) (*Router, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Router
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *RoutersService) Put(organizationName Name, projectName Name, routerName Name, vpcName Name, j *RouterUpdate) (*Router, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Router
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a router from its VPC
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *RoutersService) Delete(organizationName Name, projectName Name, routerName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List a Router's routes
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `routerName`
//	- `sortBy`
//	- `vpcName`
func (s *RoutesService) List(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, routerName Name, vpcName Name) (*RouterRouteResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"sort_by":           string(sortBy),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRouteResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List a Router's routes
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `sortBy`
//	- `vpcName`
func (s *RoutesService) ListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, routerName Name, vpcName Name) (*[]RouterRoute, error) {

	var allPages []RouterRoute
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName, routerName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *RoutesService) Create(organizationName Name, projectName Name, routerName Name, vpcName Name, j *RouterRouteCreateParams) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get a VPC Router route
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
func (s *RoutesService) Get(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"route_name":        string(routeName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a Router route
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
func (s *RoutesService) Put(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name, j *RouterRouteUpdateParams) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"route_name":        string(routeName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a route from its router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
func (s *RoutesService) Delete(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"route_name":        string(routeName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List subnets in a VPC.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *SubnetsService) List(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*SubnetResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"sort_by":           string(sortBy),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SubnetResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List subnets in a VPC.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *SubnetsService) ListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]Subnet, error) {

	var allPages []Subnet
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a subnet in a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *SubnetsService) Create(organizationName Name, projectName Name, vpcName Name, j *SubnetCreate) (*Subnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Subnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get subnet in a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) Get(organizationName Name, projectName Name, subnetName Name, vpcName Name) (*Subnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"subnet_name":       string(subnetName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Subnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a VPC Subnet.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) Put(organizationName Name, projectName Name, subnetName Name, vpcName Name, j *SubnetUpdate) (*Subnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"subnet_name":       string(subnetName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Subnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a subnet from a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) Delete(organizationName Name, projectName Name, subnetName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"subnet_name":       string(subnetName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// NetworkInterfacesList: List network interfaces in a VPC subnet.
//
// To iterate over all pages, use the `NetworkInterfacesListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) NetworkInterfacesList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, subnetName Name, vpcName Name) (*NetworkInterfaceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}/network-interfaces"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": string(organizationName),
		"page_token":        pageToken,
		"project_name":      string(projectName),
		"sort_by":           string(sortBy),
		"subnet_name":       string(subnetName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesListAllPages: List network interfaces in a VPC subnet.
//
// This method is a wrapper around the `NetworkInterfacesList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) NetworkInterfacesListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, subnetName Name, vpcName Name) (*[]NetworkInterface, error) {

	var allPages []NetworkInterface
	pageToken := ""
	limit := 100
	for {
		page, err := s.NetworkInterfacesList(limit, pageToken, sortBy, organizationName, projectName, subnetName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // List: List the built-in roles
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
func (s *RolesService) List(limit int, pageToken string) (*RoleResultsPage, error) {
	// Create the url.
	path := "/roles"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RoleResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List the built-in roles
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
func (s *RolesService) ListAllPages() (*[]Role, error) {

	var allPages []Role
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch a specific built-in role
//
// Parameters:
//	- `roleName`: The built-in role's unique name.
func (s *RolesService) Get(roleName string) (*Role, error) {
	// Create the url.
	path := "/roles/{{.role_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"role_name": roleName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Role
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List all sagas (for debugging)
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *SagasService) List(limit int, pageToken string, sortBy IdSortMode) (*SagaResultsPage, error) {
	// Create the url.
	path := "/sagas"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SagaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List all sagas (for debugging)
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *SagasService) ListAllPages(sortBy IdSortMode) (*[]Saga, error) {

	var allPages []Saga
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch information about a single saga (for debugging)
//
// Parameters:
//	- `sagaId`
func (s *SagasService) Get(sagaID string) (*Saga, error) {
	// Create the url.
	path := "/sagas/{{.saga_id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"saga_id": sagaID,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Saga
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// SessionMe: Fetch the user associated with the current session
func (s *HiddenService) SessionMe() (*SessionUser, error) {
	// Create the url.
	path := "/session/me"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SessionUser
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// TimeseriesSchemaList: List all timeseries schema
//
// To iterate over all pages, use the `TimeseriesSchemaListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
func (s *MetricsService) TimeseriesSchemaList(limit int, pageToken string) (*TimeseriesSchemaResultsPage, error) {
	// Create the url.
	path := "/timeseries/schema"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body TimeseriesSchemaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// TimeseriesSchemaListAllPages: List all timeseries schema
//
// This method is a wrapper around the `TimeseriesSchemaList` method.
// This method returns all the pages at once.
func (s *MetricsService) TimeseriesSchemaListAllPages() (*[]TimeseriesSchema, error) {

	var allPages []TimeseriesSchema
	pageToken := ""
	limit := 100
	for {
		page, err := s.TimeseriesSchemaList(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Refresh: Refresh update metadata
func (s *UpdatesService) Refresh() error {
	// Create the url.
	path := "/updates/refresh"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List the built-in system users
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *UsersService) List(limit int, pageToken string, sortBy NameSortMode) (*UserResultsPage, error) {
	// Create the url.
	path := "/users"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List the built-in system users
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *UsersService) ListAllPages(sortBy NameSortMode) (*[]User, error) {

	var allPages []User
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch a specific built-in system user
//
// Parameters:
//	- `userName`: The built-in user's unique name.
func (s *UsersService) Get(userName Name) (*User, error) {
	// Create the url.
	path := "/users/{{.user_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"user_name": string(userName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}
