// Code generated by `generate`. DO NOT EDIT.

package oxide

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
)

// List: List racks in the system.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *RacksService) List(limit int, pageToken string, sortBy IdSortMode) (*RackResultsPage, error) {
	// Create the url.
	path := "/hardware/racks"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RackResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List racks in the system.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *RacksService) ListAllPages(sortBy IdSortMode) (*[]Rack, error) {

	var allPages []Rack
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch information about a particular rack.
//
// Parameters:
//	- `rackId`: The rack's unique ID.
func (s *RacksService) Get(rackID string) (*Rack, error) {
	// Create the url.
	path := "/hardware/racks/{{.rack_id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"rack_id": rackID,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Rack
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List sleds in the system.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *SledsService) List(limit int, pageToken string, sortBy IdSortMode) (*SledResultsPage, error) {
	// Create the url.
	path := "/hardware/sleds"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SledResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List sleds in the system.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *SledsService) ListAllPages(sortBy IdSortMode) (*[]Sled, error) {

	var allPages []Sled
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch information about a sled in the system.
//
// Parameters:
//	- `sledId`: The sled's unique ID.
func (s *SledsService) Get(sledID string) (*Sled, error) {
	// Create the url.
	path := "/hardware/sleds/{{.sled_id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sled_id": sledID,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Sled
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ImagesList: List global images.
//
// Returns a list of all the global images. Global images are returned sorted by creation date, with the most recent images appearing first.
//
// To iterate over all pages, use the `ImagesListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *ImagesglobalService) ImagesList(limit int, pageToken string, sortBy NameSortMode) (*ImageResultsPage, error) {
	// Create the url.
	path := "/images"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ImageResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ImagesListAllPages: List global images.
//
// Returns a list of all the global images. Global images are returned sorted by creation date, with the most recent images appearing first.
//
// This method is a wrapper around the `ImagesList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *ImagesglobalService) ImagesListAllPages(sortBy NameSortMode) (*[]Image, error) {

	var allPages []Image
	pageToken := ""
	limit := 100
	for {
		page, err := s.ImagesList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // ImagesCreate: Create a global image.
//
// Create a new global image. This image can then be used by any user as a base for instances.
func (s *ImagesglobalService) ImagesCreate(j *ImageCreate) (*Image, error) {
	// Create the url.
	path := "/images"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ImagesGetImage: Get a global image.
//
// Returns the details of a specific global image.
//
// Parameters:
//	- `imageName`
func (s *ImagesglobalService) ImagesGetImage(imageName string) (*Image, error) {
	// Create the url.
	path := "/images/{{.image_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"image_name": imageName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ImagesDeleteImage: Delete a global image.
//
// Permanently delete a global image. This operation cannot be undone. Any instances using the global image will continue to run, however new instances can not be created with this image.
//
// Parameters:
//	- `imageName`
func (s *ImagesglobalService) ImagesDeleteImage(imageName string) error {
	// Create the url.
	path := "/images/{{.image_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"image_name": imageName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List all organizations.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *OrganizationsService) List(limit int, pageToken string, sortBy NameOrIdSortMode) (*OrganizationResultsPage, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body OrganizationResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List all organizations.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *OrganizationsService) ListAllPages(sortBy NameOrIdSortMode) (*[]Organization, error) {

	var allPages []Organization
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a new organization.
func (s *OrganizationsService) Create(j *OrganizationCreate) (*Organization, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Fetch a specific organization
//
// Parameters:
//	- `organizationName`: The organization's unique name.
func (s *OrganizationsService) Get(organizationName string) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a specific organization.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
func (s *OrganizationsService) Put(organizationName string, j *OrganizationUpdate) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a specific organization.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
func (s *OrganizationsService) Delete(organizationName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List all projects.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *ProjectsService) List(limit int, pageToken string, sortBy NameOrIdSortMode, organizationName string) (*ProjectResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ProjectResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List all projects.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `sortBy`
func (s *ProjectsService) ListAllPages(sortBy NameOrIdSortMode, organizationName string) (*[]Project, error) {

	var allPages []Project
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a new project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
func (s *ProjectsService) Create(organizationName string, j *ProjectCreate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Fetch a specific project
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *ProjectsService) Get(organizationName string, projectName string) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a specific project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *ProjectsService) Put(organizationName string, projectName string, j *ProjectUpdate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a specific project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *ProjectsService) Delete(organizationName string, projectName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List disks in a project.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *DisksService) List(limit int, pageToken string, sortBy NameSortMode, organizationName string, projectName string) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List disks in a project.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *DisksService) ListAllPages(sortBy NameSortMode, organizationName string, projectName string) (*[]Disk, error) {

	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a disk in a project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *DisksService) Create(organizationName string, projectName string, j *DiskCreate) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Fetch a single disk in a project.
//
// Parameters:
//	- `diskName`
//	- `organizationName`
//	- `projectName`
func (s *DisksService) Get(diskName string, organizationName string, projectName string) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk_name":         diskName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a disk from a project.
//
// Parameters:
//	- `diskName`
//	- `organizationName`
//	- `projectName`
func (s *DisksService) Delete(diskName string, organizationName string, projectName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk_name":         diskName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List images
//
// List images in a project. The images are returned sorted by creation date, with the most recent images appearing first.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *ImagesService) List(limit int, pageToken string, sortBy NameSortMode, organizationName string, projectName string) (*ImageResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/images"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body ImageResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List images
//
// List images in a project. The images are returned sorted by creation date, with the most recent images appearing first.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *ImagesService) ListAllPages(sortBy NameSortMode, organizationName string, projectName string) (*[]Image, error) {

	var allPages []Image
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create an image
//
// Create a new image in a project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *ImagesService) Create(organizationName string, projectName string, j *ImageCreate) (*Image, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/images"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get an image
//
// Get the details of a specific image in a project.
//
// Parameters:
//	- `imageName`
//	- `organizationName`
//	- `projectName`
func (s *ImagesService) Get(imageName string, organizationName string, projectName string) (*Image, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/images/{{.image_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"image_name":        imageName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete an image
//
// Permanently delete an image from a project. This operation cannot be undone. Any instances in the project using the image will continue to run, however new instances can not be created with this image.
//
// Parameters:
//	- `imageName`
//	- `organizationName`
//	- `projectName`
func (s *ImagesService) Delete(imageName string, organizationName string, projectName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/images/{{.image_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"image_name":        imageName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List instances in a project.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *InstancesService) List(limit int, pageToken string, sortBy NameSortMode, organizationName string, projectName string) (*InstanceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body InstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List instances in a project.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *InstancesService) ListAllPages(sortBy NameSortMode, organizationName string, projectName string) (*[]Instance, error) {

	var allPages []Instance
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create an instance in a project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *InstancesService) Create(organizationName string, projectName string, j *InstanceCreate) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get an instance in a project.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Get(instanceName string, organizationName string, projectName string) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete an instance from a project.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Delete(instanceName string, organizationName string, projectName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// DisksList: List disks attached to this instance.
//
// To iterate over all pages, use the `DisksListAllPages` method, instead.
//
// Parameters:
//	- `instanceName`
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) DisksList(limit int, pageToken string, sortBy NameSortMode, instanceName string, organizationName string, projectName string) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DisksListAllPages: List disks attached to this instance.
//
// This method is a wrapper around the `DisksList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) DisksListAllPages(sortBy NameSortMode, instanceName string, organizationName string, projectName string) (*[]Disk, error) {

	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := s.DisksList(limit, pageToken, sortBy, instanceName, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // DisksAttach
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) DisksAttach(instanceName string, organizationName string, projectName string, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/attach"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// DisksDetach
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) DisksDetach(instanceName string, organizationName string, projectName string, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/detach"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Migrate: Migrate an instance to a different propolis-server, possibly on a different sled.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Migrate(instanceName string, organizationName string, projectName string, j *InstanceMigrate) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/migrate"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesList: List network interfaces attached to this instance.
//
// To iterate over all pages, use the `NetworkInterfacesListAllPages` method, instead.
//
// Parameters:
//	- `instanceName`
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) NetworkInterfacesList(limit int, pageToken string, sortBy NameSortMode, instanceName string, organizationName string, projectName string) (*NetworkInterfaceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesListAllPages: List network interfaces attached to this instance.
//
// This method is a wrapper around the `NetworkInterfacesList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
func (s *InstancesService) NetworkInterfacesListAllPages(sortBy NameSortMode, instanceName string, organizationName string, projectName string) (*[]NetworkInterface, error) {

	var allPages []NetworkInterface
	pageToken := ""
	limit := 100
	for {
		page, err := s.NetworkInterfacesList(limit, pageToken, sortBy, instanceName, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // NetworkInterfacesCreate: Create a network interface for an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) NetworkInterfacesCreate(instanceName string, organizationName string, projectName string, j *NetworkInterfaceCreate) (*NetworkInterface, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesGetInterface: Get an interface attached to an instance.
//
// Parameters:
//	- `instanceName`
//	- `interfaceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) NetworkInterfacesGetInterface(instanceName string, interfaceName string, organizationName string, projectName string) (*NetworkInterface, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces/{{.interface_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"interface_name":    interfaceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesDeleteInterface: Detach a network interface from an instance.
//
// Parameters:
//	- `instanceName`
//	- `interfaceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) NetworkInterfacesDeleteInterface(instanceName string, interfaceName string, organizationName string, projectName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces/{{.interface_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"interface_name":    interfaceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// Reboot: Reboot an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Reboot(instanceName string, organizationName string, projectName string) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/reboot"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Start: Boot an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Start(instanceName string, organizationName string, projectName string) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/start"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Stop: Halt an instance.
//
// Parameters:
//	- `instanceName`
//	- `organizationName`
//	- `projectName`
func (s *InstancesService) Stop(instanceName string, organizationName string, projectName string) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/stop"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     instanceName,
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List snapshots in a project.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *SnapshotsService) List(limit int, pageToken string, sortBy NameSortMode, organizationName string, projectName string) (*SnapshotResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SnapshotResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List snapshots in a project.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *SnapshotsService) ListAllPages(sortBy NameSortMode, organizationName string, projectName string) (*[]Snapshot, error) {

	var allPages []Snapshot
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a snapshot of a disk.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *SnapshotsService) Create(organizationName string, projectName string, j *SnapshotCreate) (*Snapshot, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get a snapshot in a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `snapshotName`
func (s *SnapshotsService) Get(organizationName string, projectName string, snapshotName string) (*Snapshot, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots/{{.snapshot_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"snapshot_name":     snapshotName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a snapshot from a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `snapshotName`
func (s *SnapshotsService) Delete(organizationName string, projectName string, snapshotName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots/{{.snapshot_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"snapshot_name":     snapshotName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List VPCs in a project.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`: The organization's unique name.
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *VPCsService) List(limit int, pageToken string, sortBy NameSortMode, organizationName string, projectName string) (*VPCResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPCResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List VPCs in a project.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
//	- `sortBy`
func (s *VPCsService) ListAllPages(sortBy NameSortMode, organizationName string, projectName string) (*[]VPC, error) {

	var allPages []VPC
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a VPC in a project.
//
// Parameters:
//	- `organizationName`: The organization's unique name.
//	- `projectName`: The project's unique name within the organization.
func (s *VPCsService) Create(organizationName string, projectName string, j *VPCCreate) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get a VPC in a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *VPCsService) Get(organizationName string, projectName string, vpcName string) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *VPCsService) Put(organizationName string, projectName string, vpcName string, j *VPCUpdate) (*VPC, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body VPC
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a vpc from a project.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *VPCsService) Delete(organizationName string, projectName string, vpcName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"vpc_name":          vpcName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// RulesList: List firewall rules for a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *FirewallService) RulesList(organizationName string, projectName string, vpcName string) (*FirewallRules, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// RulesPut: Replace the firewall rules for a VPC
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *FirewallService) RulesPut(organizationName string, projectName string, vpcName string, j *FirewallRuleUpdateParams) (*FirewallRules, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body FirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List VPC Custom and System Routers
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *RoutersService) List(limit int, pageToken string, sortBy NameSortMode, organizationName string, projectName string, vpcName string) (*RouterResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouterResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List VPC Custom and System Routers
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *RoutersService) ListAllPages(sortBy NameSortMode, organizationName string, projectName string, vpcName string) (*[]Router, error) {

	var allPages []Router
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *RoutersService) Create(organizationName string, projectName string, vpcName string, j *RouterCreate) (*Router, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Router
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *RoutersService) Get(organizationName string, projectName string, routerName string, vpcName string) (*Router, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"router_name":       routerName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Router
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *RoutersService) Put(organizationName string, projectName string, routerName string, vpcName string, j *RouterUpdate) (*Router, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"router_name":       routerName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Router
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a router from its VPC
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *RoutersService) Delete(organizationName string, projectName string, routerName string, vpcName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"router_name":       routerName,
		"vpc_name":          vpcName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List a Router's routes
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `routerName`
//	- `sortBy`
//	- `vpcName`
func (s *RoutesService) List(limit int, pageToken string, sortBy NameSortMode, organizationName string, projectName string, routerName string, vpcName string) (*RouteResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"router_name":       routerName,
		"sort_by":           string(sortBy),
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RouteResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List a Router's routes
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `sortBy`
//	- `vpcName`
func (s *RoutesService) ListAllPages(sortBy NameSortMode, organizationName string, projectName string, routerName string, vpcName string) (*[]Route, error) {

	var allPages []Route
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName, routerName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a VPC Router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routerName`
//	- `vpcName`
func (s *RoutesService) Create(organizationName string, projectName string, routerName string, vpcName string, j *RouteCreate) (*Route, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"router_name":       routerName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Route
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get a VPC Router route
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
func (s *RoutesService) Get(organizationName string, projectName string, routeName string, routerName string, vpcName string) (*Route, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"route_name":        routeName,
		"router_name":       routerName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Route
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a Router route
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
func (s *RoutesService) Put(organizationName string, projectName string, routeName string, routerName string, vpcName string, j *RouteUpdate) (*Route, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"route_name":        routeName,
		"router_name":       routerName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Route
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a route from its router
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `routeName`
//	- `routerName`
//	- `vpcName`
func (s *RoutesService) Delete(organizationName string, projectName string, routeName string, routerName string, vpcName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"route_name":        routeName,
		"router_name":       routerName,
		"vpc_name":          vpcName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List subnets in a VPC.
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *SubnetsService) List(limit int, pageToken string, sortBy NameSortMode, organizationName string, projectName string, vpcName string) (*SubnetResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SubnetResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List subnets in a VPC.
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `vpcName`
func (s *SubnetsService) ListAllPages(sortBy NameSortMode, organizationName string, projectName string, vpcName string) (*[]Subnet, error) {

	var allPages []Subnet
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a subnet in a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `vpcName`
func (s *SubnetsService) Create(organizationName string, projectName string, vpcName string, j *SubnetCreate) (*Subnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Subnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Get subnet in a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) Get(organizationName string, projectName string, subnetName string, vpcName string) (*Subnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"subnet_name":       subnetName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Subnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Put: Update a VPC Subnet.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) Put(organizationName string, projectName string, subnetName string, vpcName string, j *SubnetUpdate) (*Subnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"subnet_name":       subnetName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Subnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a subnet from a VPC.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) Delete(organizationName string, projectName string, subnetName string, vpcName string) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": organizationName,
		"project_name":      projectName,
		"subnet_name":       subnetName,
		"vpc_name":          vpcName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// NetworkInterfacesList: List network interfaces in a VPC subnet.
//
// To iterate over all pages, use the `NetworkInterfacesListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `organizationName`
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `projectName`
//	- `sortBy`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) NetworkInterfacesList(limit int, pageToken string, sortBy NameSortMode, organizationName string, projectName string, subnetName string, vpcName string) (*NetworkInterfaceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}/network-interfaces"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":             strconv.Itoa(limit),
		"organization_name": organizationName,
		"page_token":        pageToken,
		"project_name":      projectName,
		"sort_by":           string(sortBy),
		"subnet_name":       subnetName,
		"vpc_name":          vpcName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// NetworkInterfacesListAllPages: List network interfaces in a VPC subnet.
//
// This method is a wrapper around the `NetworkInterfacesList` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `organizationName`
//	- `projectName`
//	- `sortBy`
//	- `subnetName`
//	- `vpcName`
func (s *SubnetsService) NetworkInterfacesListAllPages(sortBy NameSortMode, organizationName string, projectName string, subnetName string, vpcName string) (*[]NetworkInterface, error) {

	var allPages []NetworkInterface
	pageToken := ""
	limit := 100
	for {
		page, err := s.NetworkInterfacesList(limit, pageToken, sortBy, organizationName, projectName, subnetName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // List: List the built-in roles
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
func (s *RolesService) List(limit int, pageToken string) (*RoleResultsPage, error) {
	// Create the url.
	path := "/roles"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body RoleResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List the built-in roles
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
func (s *RolesService) ListAllPages() (*[]Role, error) {

	var allPages []Role
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch a specific built-in role
//
// Parameters:
//	- `roleName`: The built-in role's unique name.
func (s *RolesService) Get(roleName string) (*Role, error) {
	// Create the url.
	path := "/roles/{{.role_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"role_name": roleName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Role
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List: List all sagas (for debugging)
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *SagasService) List(limit int, pageToken string, sortBy IdSortMode) (*SagaResultsPage, error) {
	// Create the url.
	path := "/sagas"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SagaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List all sagas (for debugging)
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *SagasService) ListAllPages(sortBy IdSortMode) (*[]Saga, error) {

	var allPages []Saga
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch information about a single saga (for debugging)
//
// Parameters:
//	- `sagaId`
func (s *SagasService) Get(sagaID string) (*Saga, error) {
	// Create the url.
	path := "/sagas/{{.saga_id}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"saga_id": sagaID,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Saga
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// List
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *SilosService) List(limit int, pageToken string, sortBy NameOrIdSortMode) (*SiloResultsPage, error) {
	// Create the url.
	path := "/silos"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body SiloResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *SilosService) ListAllPages(sortBy NameOrIdSortMode) (*[]Silo, error) {

	var allPages []Silo
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Create: Create a new silo.
func (s *SilosService) Create(j *SiloCreate) (*Silo, error) {
	// Create the url.
	path := "/silos"
	uri := resolveRelative(s.client.server, path)
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}
	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Silo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Get: Fetch a specific silo
//
// Parameters:
//	- `siloName`: The silo's unique name.
func (s *SilosService) Get(siloName string) (*Silo, error) {
	// Create the url.
	path := "/silos/{{.silo_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": siloName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body Silo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// Delete: Delete a specific silo.
//
// Parameters:
//	- `siloName`: The silo's unique name.
func (s *SilosService) Delete(siloName string) error {
	// Create the url.
	path := "/silos/{{.silo_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": siloName,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// TimeseriesSchemaList: List all timeseries schema
//
// To iterate over all pages, use the `TimeseriesSchemaListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
func (s *MetricsService) TimeseriesSchemaList(limit int, pageToken string) (*TimeseriesSchemaResultsPage, error) {
	// Create the url.
	path := "/timeseries/schema"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body TimeseriesSchemaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// TimeseriesSchemaListAllPages: List all timeseries schema
//
// This method is a wrapper around the `TimeseriesSchemaList` method.
// This method returns all the pages at once.
func (s *MetricsService) TimeseriesSchemaListAllPages() (*[]TimeseriesSchema, error) {

	var allPages []TimeseriesSchema
	pageToken := ""
	limit := 100
	for {
		page, err := s.TimeseriesSchemaList(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Refresh: Refresh update metadata
func (s *UpdatesService) Refresh() error {
	// Create the url.
	path := "/updates/refresh"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}
	// Return.
	return nil
}

// List: List the built-in system users
//
// To iterate over all pages, use the `ListAllPages` method, instead.
//
// Parameters:
//	- `limit`: Maximum number of items returned by a single call
//	- `pageToken`: Token returned by previous call to retreive the subsequent page
//	- `sortBy`
func (s *UsersService) List(limit int, pageToken string, sortBy NameSortMode) (*UserResultsPage, error) {
	// Create the url.
	path := "/users"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}

// ListAllPages: List the built-in system users
//
// This method is a wrapper around the `List` method.
// This method returns all the pages at once.
//
// Parameters:
//	- `sortBy`
func (s *UsersService) ListAllPages(sortBy NameSortMode) (*[]User, error) {

	var allPages []User
	pageToken := ""
	limit := 100
	for {
		page, err := s.List(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
} // Get: Fetch a specific built-in system user
//
// Parameters:
//	- `userName`: The built-in user's unique name.
func (s *UsersService) Get(userName string) (*User, error) {
	// Create the url.
	path := "/users/{{.user_name}}"
	uri := resolveRelative(s.client.server, path)
	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}
	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"user_name": userName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}
	// Send the request.
	resp, err := s.client.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()
	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}
	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}
	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}
	// Return the response.
	return &body, nil
}
