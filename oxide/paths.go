// Code generated by `generate`. DO NOT EDIT.

package oxide

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
)

// DiskListV1: List disks
//
// To iterate over all pages, use the `DiskListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
func (c *Client) DiskListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode) (*DiskResultsPage, error) {
	// Create the url.
	path := "/v1/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskListV1AllPages: List disks
//
// This method is a wrapper around the `DiskListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `project`
// - `sortBy`
func (c *Client) DiskListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode) (*[]Disk, error) {
	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := c.DiskListV1(limit, organization, pageToken, project, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// DiskCreateV1: Create a disk
//
// Parameters
// - `organization`
// - `project`
func (c *Client) DiskCreateV1(organization NameOrId, project NameOrId, j *DiskCreate) (*Disk, error) {
	// Create the url.
	path := "/v1/disks"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskViewV1: Fetch a disk
//
// Parameters
// - `disk`
// - `organization`
// - `project`
func (c *Client) DiskViewV1(disk NameOrId, organization NameOrId, project NameOrId) (*Disk, error) {
	// Create the url.
	path := "/v1/disks/{{.disk}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk":         disk.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskDeleteV1: Delete a disk
//
// Parameters
// - `disk`
// - `organization`
// - `project`
func (c *Client) DiskDeleteV1(disk NameOrId, organization NameOrId, project NameOrId) error {
	// Create the url.
	path := "/v1/disks/{{.disk}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk":         disk.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceListV1: List instances
//
// To iterate over all pages, use the `InstanceListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
func (c *Client) InstanceListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode) (*InstanceResultsPage, error) {
	// Create the url.
	path := "/v1/instances"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceListV1AllPages: List instances
//
// This method is a wrapper around the `InstanceListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `project`
// - `sortBy`
func (c *Client) InstanceListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode) (*[]Instance, error) {
	var allPages []Instance
	pageToken := ""
	limit := 100
	for {
		page, err := c.InstanceListV1(limit, organization, pageToken, project, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceCreateV1: Create an instance
//
// Parameters
// - `organization`
// - `project`
func (c *Client) InstanceCreateV1(organization NameOrId, project NameOrId, j *InstanceCreate) (*Instance, error) {
	// Create the url.
	path := "/v1/instances"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceViewV1: Fetch an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceViewV1(organization NameOrId, project NameOrId, instance NameOrId) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDeleteV1: Delete an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceDeleteV1(organization NameOrId, project NameOrId, instance NameOrId) error {
	// Create the url.
	path := "/v1/instances/{{.instance}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceDiskListV1: List an instance's disks
//
// To iterate over all pages, use the `InstanceDiskListV1AllPages` method, instead.
//
// Parameters
// - `instance`
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
func (c *Client) InstanceDiskListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode, instance NameOrId) (*DiskResultsPage, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskListV1AllPages: List an instance's disks
//
// This method is a wrapper around the `InstanceDiskListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `instance`
// - `organization`
// - `project`
// - `sortBy`
func (c *Client) InstanceDiskListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode, instance NameOrId) (*[]Disk, error) {
	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := c.InstanceDiskListV1(limit, organization, pageToken, project, sortBy, instance)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceDiskAttachV1: Attach a disk to an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceDiskAttachV1(instance NameOrId, organization NameOrId, project NameOrId, j *DiskPath) (*Disk, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/disks/attach"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskDetachV1: Detach a disk from an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceDiskDetachV1(instance NameOrId, organization NameOrId, project NameOrId, j *DiskPath) (*Disk, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/disks/detach"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceMigrateV1: Migrate an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceMigrateV1(organization NameOrId, project NameOrId, instance NameOrId, j *InstanceMigrate) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/migrate"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceRebootV1: Reboot an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceRebootV1(organization NameOrId, project NameOrId, instance NameOrId) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/reboot"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsoleV1: Fetch an instance's serial console
//
// Parameters
// - `fromStart` Character index in the serial buffer from which to read, counting the bytes output since instance start. If this is not provided, `most_recent` must be provided, and if this *is* provided, `most_recent` must *not* be provided.
// - `instance`
// - `maxBytes` Maximum number of bytes of buffered serial console contents to return. If the requested range runs to the end of the available buffer, the data returned will be shorter than `max_bytes`.
// - `mostRecent` Character index in the serial buffer from which to read, counting *backward* from the most recently buffered data retrieved from the instance. (See note on `from_start` about mutual exclusivity)
// - `organization`
// - `project`
func (c *Client) InstanceSerialConsoleV1(instance NameOrId, fromStart int, maxBytes int, mostRecent int, organization NameOrId, project NameOrId) (*InstanceSerialConsoleData, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/serial-console"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"from_start":   strconv.Itoa(fromStart),
		"instance":     instance.(string),
		"max_bytes":    strconv.Itoa(maxBytes),
		"most_recent":  strconv.Itoa(mostRecent),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceSerialConsoleData
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsoleStreamV1: Stream an instance's serial console
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceSerialConsoleStreamV1(instance NameOrId, organization NameOrId, project NameOrId) error {
	// Create the url.
	path := "/v1/instances/{{.instance}}/serial-console/stream"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceStartV1: Boot an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceStartV1(organization NameOrId, project NameOrId, instance NameOrId) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/start"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceStopV1: Stop an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceStopV1(organization NameOrId, project NameOrId, instance NameOrId) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/stop"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationListV1: List organizations
//
// To iterate over all pages, use the `OrganizationListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) OrganizationListV1(limit int, pageToken string, sortBy NameOrIdSortMode) (*OrganizationResultsPage, error) {
	// Create the url.
	path := "/v1/organizations"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OrganizationResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationListV1AllPages: List organizations
//
// This method is a wrapper around the `OrganizationListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) OrganizationListV1AllPages(sortBy NameOrIdSortMode) (*[]Organization, error) {
	var allPages []Organization
	pageToken := ""
	limit := 100
	for {
		page, err := c.OrganizationListV1(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// OrganizationCreateV1: Create an organization
func (c *Client) OrganizationCreateV1(j *OrganizationCreate) (*Organization, error) {
	// Create the url.
	path := "/v1/organizations"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationViewV1: Fetch an organization
//
// Parameters
// - `organization`
func (c *Client) OrganizationViewV1(organization NameOrId) (*Organization, error) {
	// Create the url.
	path := "/v1/organizations/{{.organization}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationUpdateV1: Update an organization
//
// Parameters
// - `organization`
func (c *Client) OrganizationUpdateV1(organization NameOrId, j *OrganizationUpdate) (*Organization, error) {
	// Create the url.
	path := "/v1/organizations/{{.organization}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationDeleteV1: Delete an organization
//
// Parameters
// - `organization`
func (c *Client) OrganizationDeleteV1(organization NameOrId) error {
	// Create the url.
	path := "/v1/organizations/{{.organization}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// OrganizationPolicyViewV1: Fetch an organization's IAM policy
//
// Parameters
// - `organization`
func (c *Client) OrganizationPolicyViewV1(organization NameOrId) (*OrganizationRolePolicy, error) {
	// Create the url.
	path := "/v1/organizations/{{.organization}}/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OrganizationRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationPolicyUpdateV1: Update an organization's IAM policy
//
// Parameters
// - `organization`
func (c *Client) OrganizationPolicyUpdateV1(organization NameOrId, j *OrganizationRolePolicy) (*OrganizationRolePolicy, error) {
	// Create the url.
	path := "/v1/organizations/{{.organization}}/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OrganizationRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectListV1: List projects
//
// To iterate over all pages, use the `ProjectListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) ProjectListV1(limit int, organization NameOrId, pageToken string, sortBy NameOrIdSortMode) (*ProjectResultsPage, error) {
	// Create the url.
	path := "/v1/projects"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectListV1AllPages: List projects
//
// This method is a wrapper around the `ProjectListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `sortBy`
func (c *Client) ProjectListV1AllPages(organization NameOrId, sortBy NameOrIdSortMode) (*[]Project, error) {
	var allPages []Project
	pageToken := ""
	limit := 100
	for {
		page, err := c.ProjectListV1(limit, organization, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// ProjectCreateV1: Create a project
//
// Parameters
// - `organization`
func (c *Client) ProjectCreateV1(organization NameOrId, j *ProjectCreate) (*Project, error) {
	// Create the url.
	path := "/v1/projects"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectViewV1: Fetch a project
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectViewV1(project NameOrId, organization NameOrId) (*Project, error) {
	// Create the url.
	path := "/v1/projects/{{.project}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectUpdateV1: Update a project
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectUpdateV1(project NameOrId, organization NameOrId, j *ProjectUpdate) (*Project, error) {
	// Create the url.
	path := "/v1/projects/{{.project}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectDeleteV1: Delete a project
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectDeleteV1(project NameOrId, organization NameOrId) error {
	// Create the url.
	path := "/v1/projects/{{.project}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// ProjectPolicyViewV1: Fetch a project's IAM policy
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectPolicyViewV1(project NameOrId, organization NameOrId) (*ProjectRolePolicy, error) {
	// Create the url.
	path := "/v1/projects/{{.project}}/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectPolicyUpdateV1: Update a project's IAM policy
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectPolicyUpdateV1(project NameOrId, organization NameOrId, j *ProjectRolePolicy) (*ProjectRolePolicy, error) {
	// Create the url.
	path := "/v1/projects/{{.project}}/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemComponentVersionList: View version and update status of component tree
//
// To iterate over all pages, use the `SystemComponentVersionListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SystemComponentVersionList(limit int, pageToken string, sortBy IdSortMode) (*UpdateableComponentResultsPage, error) {
	// Create the url.
	path := "/v1/system/update/components"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateableComponentResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemComponentVersionListAllPages: View version and update status of component tree
//
// This method is a wrapper around the `SystemComponentVersionList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SystemComponentVersionListAllPages(sortBy IdSortMode) (*[]UpdateableComponent, error) {
	var allPages []UpdateableComponent
	pageToken := ""
	limit := 100
	for {
		page, err := c.SystemComponentVersionList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// UpdateDeploymentsList: List all update deployments
//
// To iterate over all pages, use the `UpdateDeploymentsListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) UpdateDeploymentsList(limit int, pageToken string, sortBy IdSortMode) (*UpdateDeploymentResultsPage, error) {
	// Create the url.
	path := "/v1/system/update/deployments"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateDeploymentResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UpdateDeploymentsListAllPages: List all update deployments
//
// This method is a wrapper around the `UpdateDeploymentsList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) UpdateDeploymentsListAllPages(sortBy IdSortMode) (*[]UpdateDeployment, error) {
	var allPages []UpdateDeployment
	pageToken := ""
	limit := 100
	for {
		page, err := c.UpdateDeploymentsList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// UpdateDeploymentView: Fetch a system update deployment
//
// Parameters
// - `id`
func (c *Client) UpdateDeploymentView(id string) (*UpdateDeployment, error) {
	// Create the url.
	path := "/v1/system/update/deployments/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateDeployment
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateRefresh: Refresh update data
func (c *Client) SystemUpdateRefresh() error {
	// Create the url.
	path := "/v1/system/update/refresh"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemUpdateStart: Start system update
func (c *Client) SystemUpdateStart(j *SystemUpdateStart) (*UpdateDeployment, error) {
	// Create the url.
	path := "/v1/system/update/start"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateDeployment
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateStop: Stop system update
// If there is no update in progress, do nothing.
func (c *Client) SystemUpdateStop() error {
	// Create the url.
	path := "/v1/system/update/stop"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemUpdateList: List all updates
//
// To iterate over all pages, use the `SystemUpdateListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SystemUpdateList(limit int, pageToken string, sortBy IdSortMode) (*SystemUpdateResultsPage, error) {
	// Create the url.
	path := "/v1/system/update/updates"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SystemUpdateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateListAllPages: List all updates
//
// This method is a wrapper around the `SystemUpdateList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SystemUpdateListAllPages(sortBy IdSortMode) (*[]SystemUpdate, error) {
	var allPages []SystemUpdate
	pageToken := ""
	limit := 100
	for {
		page, err := c.SystemUpdateList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemUpdateView: View system update
//
// Parameters
// - `version`
func (c *Client) SystemUpdateView(version SemverVersion) (*SystemUpdate, error) {
	// Create the url.
	path := "/v1/system/update/updates/{{.version}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"version": string(version),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SystemUpdate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateComponentsList: View system update component tree
//
// Parameters
// - `version`
func (c *Client) SystemUpdateComponentsList(version SemverVersion) (*ComponentUpdateResultsPage, error) {
	// Create the url.
	path := "/v1/system/update/updates/{{.version}}/components"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"version": string(version),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ComponentUpdateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemVersion: View system version and update status
func (c *Client) SystemVersion() (*SystemVersion, error) {
	// Create the url.
	path := "/v1/system/update/version"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SystemVersion
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}
