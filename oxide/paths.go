// Code generated by `generate`. DO NOT EDIT.

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package oxide

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"
)

// LoginSaml: Authenticate a user via SAML
func (c *Client) LoginSaml(ctx context.Context, params LoginSamlParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	b := params.Body

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/login/{{.silo_name}}/saml/{{.provider_name}}"),
		map[string]string{
			"provider_name": string(params.ProviderName),
			"silo_name":     string(params.SiloName),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// AlertClassList: List alert classes
//
// To iterate over all pages, use the `AlertClassListAllPages` method, instead.
func (c *Client) AlertClassList(ctx context.Context, params AlertClassListParams) (*AlertClassResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/alert-classes"),
		map[string]string{},
		map[string]string{
			"filter":     string(params.Filter),
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AlertClassResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AlertClassListAllPages: List alert classes
//
// This method is a wrapper around the `AlertClassList` method.
// This method returns all the pages at once.
func (c *Client) AlertClassListAllPages(ctx context.Context, params AlertClassListParams) ([]AlertClass, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AlertClass
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.AlertClassList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// AlertReceiverList: List alert receivers
//
// To iterate over all pages, use the `AlertReceiverListAllPages` method, instead.
func (c *Client) AlertReceiverList(ctx context.Context, params AlertReceiverListParams) (*AlertReceiverResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/alert-receivers"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AlertReceiverResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AlertReceiverListAllPages: List alert receivers
//
// This method is a wrapper around the `AlertReceiverList` method.
// This method returns all the pages at once.
func (c *Client) AlertReceiverListAllPages(ctx context.Context, params AlertReceiverListParams) ([]AlertReceiver, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AlertReceiver
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.AlertReceiverList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// AlertReceiverView: Fetch alert receiver
func (c *Client) AlertReceiverView(ctx context.Context, params AlertReceiverViewParams) (*AlertReceiver, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/alert-receivers/{{.receiver}}"),
		map[string]string{
			"receiver": string(params.Receiver),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AlertReceiver
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AlertReceiverDelete: Delete alert receiver
func (c *Client) AlertReceiverDelete(ctx context.Context, params AlertReceiverDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/alert-receivers/{{.receiver}}"),
		map[string]string{
			"receiver": string(params.Receiver),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// AlertDeliveryList: List delivery attempts to alert receiver
// Optional query parameters to this endpoint may be used to filter deliveries by state. If none of the `failed`,
// `pending` or `delivered` query parameters are present, all deliveries are returned. If one or more of these
// parameters are provided, only those which are set to "true" are included in the response.
//
// To iterate over all pages, use the `AlertDeliveryListAllPages` method, instead.
func (c *Client) AlertDeliveryList(ctx context.Context, params AlertDeliveryListParams) (*AlertDeliveryResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/alert-receivers/{{.receiver}}/deliveries"),
		map[string]string{
			"receiver": string(params.Receiver),
		},
		map[string]string{
			"delivered":  strconv.FormatBool(*params.Delivered),
			"failed":     strconv.FormatBool(*params.Failed),
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"pending":    strconv.FormatBool(*params.Pending),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AlertDeliveryResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AlertDeliveryListAllPages: List delivery attempts to alert receiver
// Optional query parameters to this endpoint may be used to filter deliveries by state. If none of the `failed`,
// `pending` or `delivered` query parameters are present, all deliveries are returned. If one or more of these
// parameters are provided, only those which are set to "true" are included in the response.
//
// This method is a wrapper around the `AlertDeliveryList` method.
// This method returns all the pages at once.
func (c *Client) AlertDeliveryListAllPages(ctx context.Context, params AlertDeliveryListParams) ([]AlertDelivery, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AlertDelivery
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.AlertDeliveryList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// AlertReceiverProbe: Send liveness probe to alert receiver
// This endpoint synchronously sends a liveness probe to the selected alert receiver. The response message describes
// the outcome of the probe: either the successful response (as appropriate), or indication of why the probe failed.
//
// The result of the probe is represented as an `AlertDelivery` model. Details relating to the status of the
// probe depend on the alert delivery mechanism, and are included in the `AlertDeliveryAttempts` model. For
// example, webhook receiver liveness probes include the HTTP status code returned by the receiver endpoint.
//
// Note that the response status is `200 OK` as long as a probe request was able to be sent to the receiver endpoint.
// If an HTTP-based receiver, such as a webhook, responds to the another status code, including an error, this
// will be indicated by the response body, *not* the status of the response.
//
// The `resend` query parameter can be used to request re-delivery of failed events if the liveness probe succeeds.
// If it is set to true and the liveness probe succeeds, any alerts for which delivery to this receiver has
// failed will be queued for re-delivery.
func (c *Client) AlertReceiverProbe(ctx context.Context, params AlertReceiverProbeParams) (*AlertProbeResult, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/alert-receivers/{{.receiver}}/probe"),
		map[string]string{
			"receiver": string(params.Receiver),
		},
		map[string]string{
			"resend": strconv.FormatBool(*params.Resend),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AlertProbeResult
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AlertReceiverSubscriptionAdd: Add alert receiver subscription
func (c *Client) AlertReceiverSubscriptionAdd(ctx context.Context, params AlertReceiverSubscriptionAddParams) (*AlertSubscriptionCreated, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/alert-receivers/{{.receiver}}/subscriptions"),
		map[string]string{
			"receiver": string(params.Receiver),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AlertSubscriptionCreated
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AlertReceiverSubscriptionRemove: Remove alert receiver subscription
func (c *Client) AlertReceiverSubscriptionRemove(ctx context.Context, params AlertReceiverSubscriptionRemoveParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/alert-receivers/{{.receiver}}/subscriptions/{{.subscription}}"),
		map[string]string{
			"receiver":     string(params.Receiver),
			"subscription": string(params.Subscription),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// AlertDeliveryResend: Request re-delivery of alert
func (c *Client) AlertDeliveryResend(ctx context.Context, params AlertDeliveryResendParams) (*AlertDeliveryId, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/alerts/{{.alert_id}}/resend"),
		map[string]string{
			"alert_id": params.AlertId,
		},
		map[string]string{
			"receiver": string(params.Receiver),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AlertDeliveryId
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AntiAffinityGroupList: List anti-affinity groups
//
// To iterate over all pages, use the `AntiAffinityGroupListAllPages` method, instead.
func (c *Client) AntiAffinityGroupList(ctx context.Context, params AntiAffinityGroupListParams) (*AntiAffinityGroupResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/anti-affinity-groups"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AntiAffinityGroupResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AntiAffinityGroupListAllPages: List anti-affinity groups
//
// This method is a wrapper around the `AntiAffinityGroupList` method.
// This method returns all the pages at once.
func (c *Client) AntiAffinityGroupListAllPages(ctx context.Context, params AntiAffinityGroupListParams) ([]AntiAffinityGroup, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AntiAffinityGroup
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.AntiAffinityGroupList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// AntiAffinityGroupCreate: Create anti-affinity group
func (c *Client) AntiAffinityGroupCreate(ctx context.Context, params AntiAffinityGroupCreateParams) (*AntiAffinityGroup, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/anti-affinity-groups"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AntiAffinityGroup
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AntiAffinityGroupView: Fetch anti-affinity group
func (c *Client) AntiAffinityGroupView(ctx context.Context, params AntiAffinityGroupViewParams) (*AntiAffinityGroup, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/anti-affinity-groups/{{.anti_affinity_group}}"),
		map[string]string{
			"anti_affinity_group": string(params.AntiAffinityGroup),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AntiAffinityGroup
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AntiAffinityGroupUpdate: Update anti-affinity group
func (c *Client) AntiAffinityGroupUpdate(ctx context.Context, params AntiAffinityGroupUpdateParams) (*AntiAffinityGroup, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/anti-affinity-groups/{{.anti_affinity_group}}"),
		map[string]string{
			"anti_affinity_group": string(params.AntiAffinityGroup),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AntiAffinityGroup
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AntiAffinityGroupDelete: Delete anti-affinity group
func (c *Client) AntiAffinityGroupDelete(ctx context.Context, params AntiAffinityGroupDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/anti-affinity-groups/{{.anti_affinity_group}}"),
		map[string]string{
			"anti_affinity_group": string(params.AntiAffinityGroup),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// AntiAffinityGroupMemberList: List anti-affinity group members
//
// To iterate over all pages, use the `AntiAffinityGroupMemberListAllPages` method, instead.
func (c *Client) AntiAffinityGroupMemberList(ctx context.Context, params AntiAffinityGroupMemberListParams) (*AntiAffinityGroupMemberResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/anti-affinity-groups/{{.anti_affinity_group}}/members"),
		map[string]string{
			"anti_affinity_group": string(params.AntiAffinityGroup),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AntiAffinityGroupMemberResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AntiAffinityGroupMemberListAllPages: List anti-affinity group members
//
// This method is a wrapper around the `AntiAffinityGroupMemberList` method.
// This method returns all the pages at once.
func (c *Client) AntiAffinityGroupMemberListAllPages(ctx context.Context, params AntiAffinityGroupMemberListParams) ([]AntiAffinityGroupMember, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AntiAffinityGroupMember
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.AntiAffinityGroupMemberList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// AntiAffinityGroupMemberInstanceView: Fetch anti-affinity group member
func (c *Client) AntiAffinityGroupMemberInstanceView(ctx context.Context, params AntiAffinityGroupMemberInstanceViewParams) (*AntiAffinityGroupMember, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/anti-affinity-groups/{{.anti_affinity_group}}/members/instance/{{.instance}}"),
		map[string]string{
			"anti_affinity_group": string(params.AntiAffinityGroup),
			"instance":            string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AntiAffinityGroupMember
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AntiAffinityGroupMemberInstanceAdd: Add member to anti-affinity group
func (c *Client) AntiAffinityGroupMemberInstanceAdd(ctx context.Context, params AntiAffinityGroupMemberInstanceAddParams) (*AntiAffinityGroupMember, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/anti-affinity-groups/{{.anti_affinity_group}}/members/instance/{{.instance}}"),
		map[string]string{
			"anti_affinity_group": string(params.AntiAffinityGroup),
			"instance":            string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AntiAffinityGroupMember
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AntiAffinityGroupMemberInstanceDelete: Remove member from anti-affinity group
func (c *Client) AntiAffinityGroupMemberInstanceDelete(ctx context.Context, params AntiAffinityGroupMemberInstanceDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/anti-affinity-groups/{{.anti_affinity_group}}/members/instance/{{.instance}}"),
		map[string]string{
			"anti_affinity_group": string(params.AntiAffinityGroup),
			"instance":            string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// AuthSettingsView: Fetch current silo's auth settings
func (c *Client) AuthSettingsView(ctx context.Context) (*SiloAuthSettings, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/auth-settings"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloAuthSettings
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AuthSettingsUpdate: Update current silo's auth settings
func (c *Client) AuthSettingsUpdate(ctx context.Context, params AuthSettingsUpdateParams) (*SiloAuthSettings, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/auth-settings"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloAuthSettings
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateList: List certificates for external endpoints
// Returns a list of TLS certificates used for the external API (for the current Silo).  These are sorted by
// creation date, with the most recent certificates appearing first.
//
// To iterate over all pages, use the `CertificateListAllPages` method, instead.
func (c *Client) CertificateList(ctx context.Context, params CertificateListParams) (*CertificateResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/certificates"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body CertificateResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateListAllPages: List certificates for external endpoints
// Returns a list of TLS certificates used for the external API (for the current Silo).  These are sorted by
// creation date, with the most recent certificates appearing first.
//
// This method is a wrapper around the `CertificateList` method.
// This method returns all the pages at once.
func (c *Client) CertificateListAllPages(ctx context.Context, params CertificateListParams) ([]Certificate, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Certificate
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.CertificateList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// CertificateCreate: Create new system-wide x.509 certificate
// This certificate is automatically used by the Oxide Control plane to serve external connections.
func (c *Client) CertificateCreate(ctx context.Context, params CertificateCreateParams) (*Certificate, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/certificates"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateView: Fetch certificate
// Returns the details of a specific certificate
func (c *Client) CertificateView(ctx context.Context, params CertificateViewParams) (*Certificate, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/certificates/{{.certificate}}"),
		map[string]string{
			"certificate": string(params.Certificate),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateDelete: Delete certificate
// Permanently delete a certificate. This operation cannot be undone.
func (c *Client) CertificateDelete(ctx context.Context, params CertificateDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/certificates/{{.certificate}}"),
		map[string]string{
			"certificate": string(params.Certificate),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskList: List disks
//
// To iterate over all pages, use the `DiskListAllPages` method, instead.
func (c *Client) DiskList(ctx context.Context, params DiskListParams) (*DiskResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/disks"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskListAllPages: List disks
//
// This method is a wrapper around the `DiskList` method.
// This method returns all the pages at once.
func (c *Client) DiskListAllPages(ctx context.Context, params DiskListParams) ([]Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Disk
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.DiskList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// DiskCreate: Create a disk
func (c *Client) DiskCreate(ctx context.Context, params DiskCreateParams) (*Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/disks"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskView: Fetch disk
func (c *Client) DiskView(ctx context.Context, params DiskViewParams) (*Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/disks/{{.disk}}"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskDelete: Delete disk
func (c *Client) DiskDelete(ctx context.Context, params DiskDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/disks/{{.disk}}"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskBulkWriteImport: Import blocks into disk
func (c *Client) DiskBulkWriteImport(ctx context.Context, params DiskBulkWriteImportParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/disks/{{.disk}}/bulk-write"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskBulkWriteImportStart: Start importing blocks into disk
// Start the process of importing blocks into a disk
func (c *Client) DiskBulkWriteImportStart(ctx context.Context, params DiskBulkWriteImportStartParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/disks/{{.disk}}/bulk-write-start"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskBulkWriteImportStop: Stop importing blocks into disk
// Stop the process of importing blocks into a disk
func (c *Client) DiskBulkWriteImportStop(ctx context.Context, params DiskBulkWriteImportStopParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/disks/{{.disk}}/bulk-write-stop"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskFinalizeImport: Confirm disk block import completion
func (c *Client) DiskFinalizeImport(ctx context.Context, params DiskFinalizeImportParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/disks/{{.disk}}/finalize"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// FloatingIpList: List floating IPs
//
// To iterate over all pages, use the `FloatingIpListAllPages` method, instead.
func (c *Client) FloatingIpList(ctx context.Context, params FloatingIpListParams) (*FloatingIpResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/floating-ips"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIpResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpListAllPages: List floating IPs
//
// This method is a wrapper around the `FloatingIpList` method.
// This method returns all the pages at once.
func (c *Client) FloatingIpListAllPages(ctx context.Context, params FloatingIpListParams) ([]FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []FloatingIp
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.FloatingIpList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// FloatingIpCreate: Create floating IP
func (c *Client) FloatingIpCreate(ctx context.Context, params FloatingIpCreateParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/floating-ips"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpView: Fetch floating IP
func (c *Client) FloatingIpView(ctx context.Context, params FloatingIpViewParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpUpdate: Update floating IP
func (c *Client) FloatingIpUpdate(ctx context.Context, params FloatingIpUpdateParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpDelete: Delete floating IP
func (c *Client) FloatingIpDelete(ctx context.Context, params FloatingIpDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// FloatingIpAttach: Attach floating IP
// Attach floating IP to an instance or other resource.
func (c *Client) FloatingIpAttach(ctx context.Context, params FloatingIpAttachParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}/attach"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpDetach: Detach floating IP
func (c *Client) FloatingIpDetach(ctx context.Context, params FloatingIpDetachParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}/detach"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// GroupList: List groups
//
// To iterate over all pages, use the `GroupListAllPages` method, instead.
func (c *Client) GroupList(ctx context.Context, params GroupListParams) (*GroupResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/groups"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GroupResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// GroupListAllPages: List groups
//
// This method is a wrapper around the `GroupList` method.
// This method returns all the pages at once.
func (c *Client) GroupListAllPages(ctx context.Context, params GroupListParams) ([]Group, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Group
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.GroupList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// GroupView: Fetch group
func (c *Client) GroupView(ctx context.Context, params GroupViewParams) (*Group, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/groups/{{.group_id}}"),
		map[string]string{
			"group_id": params.GroupId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Group
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageList: List images
// List images which are global or scoped to the specified project. The images are returned sorted by creation date,
// with the most recent images appearing first.
//
// To iterate over all pages, use the `ImageListAllPages` method, instead.
func (c *Client) ImageList(ctx context.Context, params ImageListParams) (*ImageResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/images"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ImageResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageListAllPages: List images
// List images which are global or scoped to the specified project. The images are returned sorted by creation date,
// with the most recent images appearing first.
//
// This method is a wrapper around the `ImageList` method.
// This method returns all the pages at once.
func (c *Client) ImageListAllPages(ctx context.Context, params ImageListParams) ([]Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Image
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.ImageList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// ImageCreate: Create image
// Create a new image in a project.
func (c *Client) ImageCreate(ctx context.Context, params ImageCreateParams) (*Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/images"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageView: Fetch image
// Fetch the details for a specific image in a project.
func (c *Client) ImageView(ctx context.Context, params ImageViewParams) (*Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/images/{{.image}}"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageDelete: Delete image
// Permanently delete an image from a project. This operation cannot be undone. Any instances in the project using
// the image will continue to run, however new instances can not be created with this image.
func (c *Client) ImageDelete(ctx context.Context, params ImageDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/images/{{.image}}"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// ImageDemote: Demote silo image
// Demote silo image to be visible only to a specified project
func (c *Client) ImageDemote(ctx context.Context, params ImageDemoteParams) (*Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/images/{{.image}}/demote"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImagePromote: Promote project image
// Promote project image to be visible to all projects in the silo
func (c *Client) ImagePromote(ctx context.Context, params ImagePromoteParams) (*Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/images/{{.image}}/promote"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceList: List instances
//
// To iterate over all pages, use the `InstanceListAllPages` method, instead.
func (c *Client) InstanceList(ctx context.Context, params InstanceListParams) (*InstanceResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceListAllPages: List instances
//
// This method is a wrapper around the `InstanceList` method.
// This method returns all the pages at once.
func (c *Client) InstanceListAllPages(ctx context.Context, params InstanceListParams) ([]Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Instance
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.InstanceList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceCreate: Create instance
func (c *Client) InstanceCreate(ctx context.Context, params InstanceCreateParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/instances"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceView: Fetch instance
func (c *Client) InstanceView(ctx context.Context, params InstanceViewParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceUpdate: Update instance
func (c *Client) InstanceUpdate(ctx context.Context, params InstanceUpdateParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/instances/{{.instance}}"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDelete: Delete instance
func (c *Client) InstanceDelete(ctx context.Context, params InstanceDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/instances/{{.instance}}"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InstanceAntiAffinityGroupList: List anti-affinity groups containing instance
//
// To iterate over all pages, use the `InstanceAntiAffinityGroupListAllPages` method, instead.
func (c *Client) InstanceAntiAffinityGroupList(ctx context.Context, params InstanceAntiAffinityGroupListParams) (*AntiAffinityGroupResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/anti-affinity-groups"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AntiAffinityGroupResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceAntiAffinityGroupListAllPages: List anti-affinity groups containing instance
//
// This method is a wrapper around the `InstanceAntiAffinityGroupList` method.
// This method returns all the pages at once.
func (c *Client) InstanceAntiAffinityGroupListAllPages(ctx context.Context, params InstanceAntiAffinityGroupListParams) ([]AntiAffinityGroup, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AntiAffinityGroup
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.InstanceAntiAffinityGroupList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceDiskList: List disks for instance
//
// To iterate over all pages, use the `InstanceDiskListAllPages` method, instead.
func (c *Client) InstanceDiskList(ctx context.Context, params InstanceDiskListParams) (*DiskResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/disks"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskListAllPages: List disks for instance
//
// This method is a wrapper around the `InstanceDiskList` method.
// This method returns all the pages at once.
func (c *Client) InstanceDiskListAllPages(ctx context.Context, params InstanceDiskListParams) ([]Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Disk
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.InstanceDiskList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceDiskAttach: Attach disk to instance
func (c *Client) InstanceDiskAttach(ctx context.Context, params InstanceDiskAttachParams) (*Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/disks/attach"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskDetach: Detach disk from instance
func (c *Client) InstanceDiskDetach(ctx context.Context, params InstanceDiskDetachParams) (*Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/disks/detach"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceExternalIpList: List external IP addresses
func (c *Client) InstanceExternalIpList(ctx context.Context, params InstanceExternalIpListParams) (*ExternalIpResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/external-ips"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ExternalIpResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceEphemeralIpAttach: Allocate and attach ephemeral IP to instance
func (c *Client) InstanceEphemeralIpAttach(ctx context.Context, params InstanceEphemeralIpAttachParams) (*ExternalIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/external-ips/ephemeral"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ExternalIp
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceEphemeralIpDetach: Detach and deallocate ephemeral IP from instance
func (c *Client) InstanceEphemeralIpDetach(ctx context.Context, params InstanceEphemeralIpDetachParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/external-ips/ephemeral"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InstanceReboot: Reboot an instance
func (c *Client) InstanceReboot(ctx context.Context, params InstanceRebootParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/reboot"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsole: Fetch instance serial console
func (c *Client) InstanceSerialConsole(ctx context.Context, params InstanceSerialConsoleParams) (*InstanceSerialConsoleData, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/serial-console"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"from_start":  PointerIntToStr(params.FromStart),
			"max_bytes":   PointerIntToStr(params.MaxBytes),
			"most_recent": PointerIntToStr(params.MostRecent),
			"project":     string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceSerialConsoleData
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsoleStream: Stream instance serial console
func (c *Client) InstanceSerialConsoleStream(ctx context.Context, params InstanceSerialConsoleStreamParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/serial-console/stream"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"most_recent": PointerIntToStr(params.MostRecent),
			"project":     string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InstanceSshPublicKeyList: List SSH public keys for instance
// List SSH public keys injected via cloud-init during instance creation. Note that this list is a snapshot in
// time and will not reflect updates made after the instance is created.
//
// To iterate over all pages, use the `InstanceSshPublicKeyListAllPages` method, instead.
func (c *Client) InstanceSshPublicKeyList(ctx context.Context, params InstanceSshPublicKeyListParams) (*SshKeyResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/ssh-public-keys"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKeyResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSshPublicKeyListAllPages: List SSH public keys for instance
// List SSH public keys injected via cloud-init during instance creation. Note that this list is a snapshot in
// time and will not reflect updates made after the instance is created.
//
// This method is a wrapper around the `InstanceSshPublicKeyList` method.
// This method returns all the pages at once.
func (c *Client) InstanceSshPublicKeyListAllPages(ctx context.Context, params InstanceSshPublicKeyListParams) ([]SshKey, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SshKey
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.InstanceSshPublicKeyList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceStart: Boot instance
func (c *Client) InstanceStart(ctx context.Context, params InstanceStartParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/start"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceStop: Stop instance
func (c *Client) InstanceStop(ctx context.Context, params InstanceStopParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/stop"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpAddressList: List IP addresses attached to internet gateway
//
// To iterate over all pages, use the `InternetGatewayIpAddressListAllPages` method, instead.
func (c *Client) InternetGatewayIpAddressList(ctx context.Context, params InternetGatewayIpAddressListParams) (*InternetGatewayIpAddressResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/internet-gateway-ip-addresses"),
		map[string]string{},
		map[string]string{
			"gateway":    string(params.Gateway),
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayIpAddressResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpAddressListAllPages: List IP addresses attached to internet gateway
//
// This method is a wrapper around the `InternetGatewayIpAddressList` method.
// This method returns all the pages at once.
func (c *Client) InternetGatewayIpAddressListAllPages(ctx context.Context, params InternetGatewayIpAddressListParams) ([]InternetGatewayIpAddress, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InternetGatewayIpAddress
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.InternetGatewayIpAddressList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InternetGatewayIpAddressCreate: Attach IP address to internet gateway
func (c *Client) InternetGatewayIpAddressCreate(ctx context.Context, params InternetGatewayIpAddressCreateParams) (*InternetGatewayIpAddress, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/internet-gateway-ip-addresses"),
		map[string]string{},
		map[string]string{
			"gateway": string(params.Gateway),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayIpAddress
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpAddressDelete: Detach IP address from internet gateway
func (c *Client) InternetGatewayIpAddressDelete(ctx context.Context, params InternetGatewayIpAddressDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/internet-gateway-ip-addresses/{{.address}}"),
		map[string]string{
			"address": string(params.Address),
		},
		map[string]string{
			"cascade": strconv.FormatBool(*params.Cascade),
			"gateway": string(params.Gateway),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InternetGatewayIpPoolList: List IP pools attached to internet gateway
//
// To iterate over all pages, use the `InternetGatewayIpPoolListAllPages` method, instead.
func (c *Client) InternetGatewayIpPoolList(ctx context.Context, params InternetGatewayIpPoolListParams) (*InternetGatewayIpPoolResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/internet-gateway-ip-pools"),
		map[string]string{},
		map[string]string{
			"gateway":    string(params.Gateway),
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayIpPoolResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpPoolListAllPages: List IP pools attached to internet gateway
//
// This method is a wrapper around the `InternetGatewayIpPoolList` method.
// This method returns all the pages at once.
func (c *Client) InternetGatewayIpPoolListAllPages(ctx context.Context, params InternetGatewayIpPoolListParams) ([]InternetGatewayIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InternetGatewayIpPool
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.InternetGatewayIpPoolList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InternetGatewayIpPoolCreate: Attach IP pool to internet gateway
func (c *Client) InternetGatewayIpPoolCreate(ctx context.Context, params InternetGatewayIpPoolCreateParams) (*InternetGatewayIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/internet-gateway-ip-pools"),
		map[string]string{},
		map[string]string{
			"gateway": string(params.Gateway),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayIpPool
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpPoolDelete: Detach IP pool from internet gateway
func (c *Client) InternetGatewayIpPoolDelete(ctx context.Context, params InternetGatewayIpPoolDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/internet-gateway-ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{
			"cascade": strconv.FormatBool(*params.Cascade),
			"gateway": string(params.Gateway),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InternetGatewayList: List internet gateways
//
// To iterate over all pages, use the `InternetGatewayListAllPages` method, instead.
func (c *Client) InternetGatewayList(ctx context.Context, params InternetGatewayListParams) (*InternetGatewayResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/internet-gateways"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayListAllPages: List internet gateways
//
// This method is a wrapper around the `InternetGatewayList` method.
// This method returns all the pages at once.
func (c *Client) InternetGatewayListAllPages(ctx context.Context, params InternetGatewayListParams) ([]InternetGateway, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InternetGateway
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.InternetGatewayList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InternetGatewayCreate: Create VPC internet gateway
func (c *Client) InternetGatewayCreate(ctx context.Context, params InternetGatewayCreateParams) (*InternetGateway, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/internet-gateways"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGateway
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayView: Fetch internet gateway
func (c *Client) InternetGatewayView(ctx context.Context, params InternetGatewayViewParams) (*InternetGateway, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/internet-gateways/{{.gateway}}"),
		map[string]string{
			"gateway": string(params.Gateway),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGateway
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayDelete: Delete internet gateway
func (c *Client) InternetGatewayDelete(ctx context.Context, params InternetGatewayDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/internet-gateways/{{.gateway}}"),
		map[string]string{
			"gateway": string(params.Gateway),
		},
		map[string]string{
			"cascade": strconv.FormatBool(*params.Cascade),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// ProjectIpPoolList: List IP pools
//
// To iterate over all pages, use the `ProjectIpPoolListAllPages` method, instead.
func (c *Client) ProjectIpPoolList(ctx context.Context, params ProjectIpPoolListParams) (*SiloIpPoolResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/ip-pools"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloIpPoolResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectIpPoolListAllPages: List IP pools
//
// This method is a wrapper around the `ProjectIpPoolList` method.
// This method returns all the pages at once.
func (c *Client) ProjectIpPoolListAllPages(ctx context.Context, params ProjectIpPoolListParams) ([]SiloIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SiloIpPool
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.ProjectIpPoolList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// ProjectIpPoolView: Fetch IP pool
func (c *Client) ProjectIpPoolView(ctx context.Context, params ProjectIpPoolViewParams) (*SiloIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloIpPool
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// LoginLocal: Authenticate a user via username and password
func (c *Client) LoginLocal(ctx context.Context, params LoginLocalParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/login/{{.silo_name}}/local"),
		map[string]string{
			"silo_name": string(params.SiloName),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// CurrentUserView: Fetch user for current session
func (c *Client) CurrentUserView(ctx context.Context) (*CurrentUser, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/me"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body CurrentUser
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserAccessTokenList: List access tokens
// List device access tokens for the currently authenticated user.
//
// To iterate over all pages, use the `CurrentUserAccessTokenListAllPages` method, instead.
func (c *Client) CurrentUserAccessTokenList(ctx context.Context, params CurrentUserAccessTokenListParams) (*DeviceAccessTokenResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/me/access-tokens"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DeviceAccessTokenResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserAccessTokenListAllPages: List access tokens
// List device access tokens for the currently authenticated user.
//
// This method is a wrapper around the `CurrentUserAccessTokenList` method.
// This method returns all the pages at once.
func (c *Client) CurrentUserAccessTokenListAllPages(ctx context.Context, params CurrentUserAccessTokenListParams) ([]DeviceAccessToken, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []DeviceAccessToken
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.CurrentUserAccessTokenList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// CurrentUserAccessTokenDelete: Delete access token
// Delete a device access token for the currently authenticated user.
func (c *Client) CurrentUserAccessTokenDelete(ctx context.Context, params CurrentUserAccessTokenDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/me/access-tokens/{{.token_id}}"),
		map[string]string{
			"token_id": params.TokenId,
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// CurrentUserGroups: Fetch current user's groups
//
// To iterate over all pages, use the `CurrentUserGroupsAllPages` method, instead.
func (c *Client) CurrentUserGroups(ctx context.Context, params CurrentUserGroupsParams) (*GroupResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/me/groups"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GroupResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserGroupsAllPages: Fetch current user's groups
//
// This method is a wrapper around the `CurrentUserGroups` method.
// This method returns all the pages at once.
func (c *Client) CurrentUserGroupsAllPages(ctx context.Context, params CurrentUserGroupsParams) ([]Group, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Group
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.CurrentUserGroups(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// CurrentUserSshKeyList: List SSH public keys
// Lists SSH public keys for the currently authenticated user.
//
// To iterate over all pages, use the `CurrentUserSshKeyListAllPages` method, instead.
func (c *Client) CurrentUserSshKeyList(ctx context.Context, params CurrentUserSshKeyListParams) (*SshKeyResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/me/ssh-keys"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKeyResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserSshKeyListAllPages: List SSH public keys
// Lists SSH public keys for the currently authenticated user.
//
// This method is a wrapper around the `CurrentUserSshKeyList` method.
// This method returns all the pages at once.
func (c *Client) CurrentUserSshKeyListAllPages(ctx context.Context, params CurrentUserSshKeyListParams) ([]SshKey, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SshKey
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.CurrentUserSshKeyList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// CurrentUserSshKeyCreate: Create SSH public key
// Create an SSH public key for the currently authenticated user.
func (c *Client) CurrentUserSshKeyCreate(ctx context.Context, params CurrentUserSshKeyCreateParams) (*SshKey, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/me/ssh-keys"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKey
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserSshKeyView: Fetch SSH public key
// Fetch SSH public key associated with the currently authenticated user.
func (c *Client) CurrentUserSshKeyView(ctx context.Context, params CurrentUserSshKeyViewParams) (*SshKey, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/me/ssh-keys/{{.ssh_key}}"),
		map[string]string{
			"ssh_key": string(params.SshKey),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKey
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserSshKeyDelete: Delete SSH public key
// Delete an SSH public key associated with the currently authenticated user.
func (c *Client) CurrentUserSshKeyDelete(ctx context.Context, params CurrentUserSshKeyDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/me/ssh-keys/{{.ssh_key}}"),
		map[string]string{
			"ssh_key": string(params.SshKey),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// SiloMetric: View metrics
// View CPU, memory, or storage utilization metrics at the silo or project level.
//
// To iterate over all pages, use the `SiloMetricAllPages` method, instead.
func (c *Client) SiloMetric(ctx context.Context, params SiloMetricParams) (*MeasurementResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/metrics/{{.metric_name}}"),
		map[string]string{
			"metric_name": string(params.MetricName),
		},
		map[string]string{
			"end_time":   params.EndTime.Format(time.RFC3339),
			"limit":      PointerIntToStr(params.Limit),
			"order":      string(params.Order),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"start_time": params.StartTime.Format(time.RFC3339),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body MeasurementResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloMetricAllPages: View metrics
// View CPU, memory, or storage utilization metrics at the silo or project level.
//
// This method is a wrapper around the `SiloMetric` method.
// This method returns all the pages at once.
func (c *Client) SiloMetricAllPages(ctx context.Context, params SiloMetricParams) ([]Measurement, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Measurement
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SiloMetric(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceNetworkInterfaceList: List network interfaces
//
// To iterate over all pages, use the `InstanceNetworkInterfaceListAllPages` method, instead.
func (c *Client) InstanceNetworkInterfaceList(ctx context.Context, params InstanceNetworkInterfaceListParams) (*InstanceNetworkInterfaceResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/network-interfaces"),
		map[string]string{},
		map[string]string{
			"instance":   string(params.Instance),
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterfaceResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceListAllPages: List network interfaces
//
// This method is a wrapper around the `InstanceNetworkInterfaceList` method.
// This method returns all the pages at once.
func (c *Client) InstanceNetworkInterfaceListAllPages(ctx context.Context, params InstanceNetworkInterfaceListParams) ([]InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InstanceNetworkInterface
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.InstanceNetworkInterfaceList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceNetworkInterfaceCreate: Create network interface
func (c *Client) InstanceNetworkInterfaceCreate(ctx context.Context, params InstanceNetworkInterfaceCreateParams) (*InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/network-interfaces"),
		map[string]string{},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterface
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceView: Fetch network interface
func (c *Client) InstanceNetworkInterfaceView(ctx context.Context, params InstanceNetworkInterfaceViewParams) (*InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/network-interfaces/{{.interface}}"),
		map[string]string{
			"interface": string(params.Interface),
		},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterface
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceUpdate: Update network interface
func (c *Client) InstanceNetworkInterfaceUpdate(ctx context.Context, params InstanceNetworkInterfaceUpdateParams) (*InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/network-interfaces/{{.interface}}"),
		map[string]string{
			"interface": string(params.Interface),
		},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterface
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceDelete: Delete network interface
// Note that the primary interface for an instance cannot be deleted if there are any secondary interfaces. A
// new primary interface must be designated first. The primary interface can be deleted if there are no secondary
// interfaces.
func (c *Client) InstanceNetworkInterfaceDelete(ctx context.Context, params InstanceNetworkInterfaceDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/network-interfaces/{{.interface}}"),
		map[string]string{
			"interface": string(params.Interface),
		},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// Ping: Ping API
// Always responds with Ok if it responds at all.
func (c *Client) Ping(ctx context.Context) (*Ping, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/ping"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Ping
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PolicyView: Fetch current silo's IAM policy
func (c *Client) PolicyView(ctx context.Context) (*SiloRolePolicy, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PolicyUpdate: Update current silo's IAM policy
func (c *Client) PolicyUpdate(ctx context.Context, params PolicyUpdateParams) (*SiloRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectList: List projects
//
// To iterate over all pages, use the `ProjectListAllPages` method, instead.
func (c *Client) ProjectList(ctx context.Context, params ProjectListParams) (*ProjectResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/projects"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectListAllPages: List projects
//
// This method is a wrapper around the `ProjectList` method.
// This method returns all the pages at once.
func (c *Client) ProjectListAllPages(ctx context.Context, params ProjectListParams) ([]Project, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Project
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.ProjectList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// ProjectCreate: Create project
func (c *Client) ProjectCreate(ctx context.Context, params ProjectCreateParams) (*Project, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/projects"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectView: Fetch project
func (c *Client) ProjectView(ctx context.Context, params ProjectViewParams) (*Project, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/projects/{{.project}}"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectUpdate: Update a project
func (c *Client) ProjectUpdate(ctx context.Context, params ProjectUpdateParams) (*Project, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/projects/{{.project}}"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectDelete: Delete project
func (c *Client) ProjectDelete(ctx context.Context, params ProjectDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/projects/{{.project}}"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// ProjectPolicyView: Fetch project's IAM policy
func (c *Client) ProjectPolicyView(ctx context.Context, params ProjectPolicyViewParams) (*ProjectRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/projects/{{.project}}/policy"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectPolicyUpdate: Update project's IAM policy
func (c *Client) ProjectPolicyUpdate(ctx context.Context, params ProjectPolicyUpdateParams) (*ProjectRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/projects/{{.project}}/policy"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotList: List snapshots
//
// To iterate over all pages, use the `SnapshotListAllPages` method, instead.
func (c *Client) SnapshotList(ctx context.Context, params SnapshotListParams) (*SnapshotResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/snapshots"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SnapshotResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotListAllPages: List snapshots
//
// This method is a wrapper around the `SnapshotList` method.
// This method returns all the pages at once.
func (c *Client) SnapshotListAllPages(ctx context.Context, params SnapshotListParams) ([]Snapshot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Snapshot
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SnapshotList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SnapshotCreate: Create snapshot
// Creates a point-in-time snapshot from a disk.
func (c *Client) SnapshotCreate(ctx context.Context, params SnapshotCreateParams) (*Snapshot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/snapshots"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotView: Fetch snapshot
func (c *Client) SnapshotView(ctx context.Context, params SnapshotViewParams) (*Snapshot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/snapshots/{{.snapshot}}"),
		map[string]string{
			"snapshot": string(params.Snapshot),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotDelete: Delete snapshot
func (c *Client) SnapshotDelete(ctx context.Context, params SnapshotDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/snapshots/{{.snapshot}}"),
		map[string]string{
			"snapshot": string(params.Snapshot),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// AuditLogList: View audit log
// A single item in the audit log represents both the beginning and end of the logged operation (represented by
// `time_started` and `time_completed`) so that clients do not have to find multiple entries and match them up
// by request ID to get the full picture of an operation. Because timestamps may not be unique, entries have
// also have a unique `id` that can be used to deduplicate items fetched from overlapping time intervals.
//
// Audit log entries are designed to be immutable: once you see an entry, fetching it again will never get you
// a different result. The list is ordered by `time_completed`, not `time_started`. If you fetch the audit log
// for a time range that is fully in the past, the resulting list is guaranteed to be complete, i.e., fetching the
// same timespan again later will always produce the same set of entries.
//
// To iterate over all pages, use the `AuditLogListAllPages` method, instead.
func (c *Client) AuditLogList(ctx context.Context, params AuditLogListParams) (*AuditLogEntryResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/audit-log"),
		map[string]string{},
		map[string]string{
			"end_time":   params.EndTime.Format(time.RFC3339),
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
			"start_time": params.StartTime.Format(time.RFC3339),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AuditLogEntryResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// AuditLogListAllPages: View audit log
// A single item in the audit log represents both the beginning and end of the logged operation (represented by
// `time_started` and `time_completed`) so that clients do not have to find multiple entries and match them up
// by request ID to get the full picture of an operation. Because timestamps may not be unique, entries have
// also have a unique `id` that can be used to deduplicate items fetched from overlapping time intervals.
//
// Audit log entries are designed to be immutable: once you see an entry, fetching it again will never get you
// a different result. The list is ordered by `time_completed`, not `time_started`. If you fetch the audit log
// for a time range that is fully in the past, the resulting list is guaranteed to be complete, i.e., fetching the
// same timespan again later will always produce the same set of entries.
//
// This method is a wrapper around the `AuditLogList` method.
// This method returns all the pages at once.
func (c *Client) AuditLogListAllPages(ctx context.Context, params AuditLogListParams) ([]AuditLogEntry, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AuditLogEntry
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.AuditLogList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// PhysicalDiskList: List physical disks
//
// To iterate over all pages, use the `PhysicalDiskListAllPages` method, instead.
func (c *Client) PhysicalDiskList(ctx context.Context, params PhysicalDiskListParams) (*PhysicalDiskResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/disks"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PhysicalDiskListAllPages: List physical disks
//
// This method is a wrapper around the `PhysicalDiskList` method.
// This method returns all the pages at once.
func (c *Client) PhysicalDiskListAllPages(ctx context.Context, params PhysicalDiskListParams) ([]PhysicalDisk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []PhysicalDisk
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.PhysicalDiskList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// PhysicalDiskView: Get a physical disk
func (c *Client) PhysicalDiskView(ctx context.Context, params PhysicalDiskViewParams) (*PhysicalDisk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/disks/{{.disk_id}}"),
		map[string]string{
			"disk_id": params.DiskId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDisk
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortLldpNeighbors: Fetch the LLDP neighbors seen on a switch port
//
// To iterate over all pages, use the `NetworkingSwitchPortLldpNeighborsAllPages` method, instead.
func (c *Client) NetworkingSwitchPortLldpNeighbors(ctx context.Context, params NetworkingSwitchPortLldpNeighborsParams) (*LldpNeighborResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/rack-switch-port/{{.rack_id}}/{{.switch_location}}/{{.port}}/lldp/neighbors"),
		map[string]string{
			"port":            string(params.Port),
			"rack_id":         params.RackId,
			"switch_location": string(params.SwitchLocation),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body LldpNeighborResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortLldpNeighborsAllPages: Fetch the LLDP neighbors seen on a switch port
//
// This method is a wrapper around the `NetworkingSwitchPortLldpNeighbors` method.
// This method returns all the pages at once.
func (c *Client) NetworkingSwitchPortLldpNeighborsAllPages(ctx context.Context, params NetworkingSwitchPortLldpNeighborsParams) ([]LldpNeighbor, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []LldpNeighbor
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.NetworkingSwitchPortLldpNeighbors(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// RackList: List racks
//
// To iterate over all pages, use the `RackListAllPages` method, instead.
func (c *Client) RackList(ctx context.Context, params RackListParams) (*RackResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/racks"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RackResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RackListAllPages: List racks
//
// This method is a wrapper around the `RackList` method.
// This method returns all the pages at once.
func (c *Client) RackListAllPages(ctx context.Context, params RackListParams) ([]Rack, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Rack
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.RackList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// RackView: Fetch rack
func (c *Client) RackView(ctx context.Context, params RackViewParams) (*Rack, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/racks/{{.rack_id}}"),
		map[string]string{
			"rack_id": params.RackId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Rack
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledList: List sleds
//
// To iterate over all pages, use the `SledListAllPages` method, instead.
func (c *Client) SledList(ctx context.Context, params SledListParams) (*SledResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListAllPages: List sleds
//
// This method is a wrapper around the `SledList` method.
// This method returns all the pages at once.
func (c *Client) SledListAllPages(ctx context.Context, params SledListParams) ([]Sled, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Sled
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SledList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SledAdd: Add sled to initialized rack
func (c *Client) SledAdd(ctx context.Context, params SledAddParams) (*SledId, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/hardware/sleds"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledId
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListUninitialized: List uninitialized sleds
//
// To iterate over all pages, use the `SledListUninitializedAllPages` method, instead.
func (c *Client) SledListUninitialized(ctx context.Context, params SledListUninitializedParams) (*UninitializedSledResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds-uninitialized"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UninitializedSledResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListUninitializedAllPages: List uninitialized sleds
//
// This method is a wrapper around the `SledListUninitialized` method.
// This method returns all the pages at once.
func (c *Client) SledListUninitializedAllPages(ctx context.Context, params SledListUninitializedParams) ([]UninitializedSled, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []UninitializedSled
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SledListUninitialized(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SledView: Fetch sled
func (c *Client) SledView(ctx context.Context, params SledViewParams) (*Sled, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds/{{.sled_id}}"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Sled
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskList: List physical disks attached to sleds
//
// To iterate over all pages, use the `SledPhysicalDiskListAllPages` method, instead.
func (c *Client) SledPhysicalDiskList(ctx context.Context, params SledPhysicalDiskListParams) (*PhysicalDiskResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds/{{.sled_id}}/disks"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskListAllPages: List physical disks attached to sleds
//
// This method is a wrapper around the `SledPhysicalDiskList` method.
// This method returns all the pages at once.
func (c *Client) SledPhysicalDiskListAllPages(ctx context.Context, params SledPhysicalDiskListParams) ([]PhysicalDisk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []PhysicalDisk
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SledPhysicalDiskList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SledInstanceList: List instances running on given sled
//
// To iterate over all pages, use the `SledInstanceListAllPages` method, instead.
func (c *Client) SledInstanceList(ctx context.Context, params SledInstanceListParams) (*SledInstanceResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds/{{.sled_id}}/instances"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledInstanceResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledInstanceListAllPages: List instances running on given sled
//
// This method is a wrapper around the `SledInstanceList` method.
// This method returns all the pages at once.
func (c *Client) SledInstanceListAllPages(ctx context.Context, params SledInstanceListParams) ([]SledInstance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SledInstance
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SledInstanceList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SledSetProvisionPolicy: Set sled provision policy
func (c *Client) SledSetProvisionPolicy(ctx context.Context, params SledSetProvisionPolicyParams) (*SledProvisionPolicyResponse, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/hardware/sleds/{{.sled_id}}/provision-policy"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledProvisionPolicyResponse
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortList: List switch ports
//
// To iterate over all pages, use the `NetworkingSwitchPortListAllPages` method, instead.
func (c *Client) NetworkingSwitchPortList(ctx context.Context, params NetworkingSwitchPortListParams) (*SwitchPortResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/switch-port"),
		map[string]string{},
		map[string]string{
			"limit":          PointerIntToStr(params.Limit),
			"page_token":     params.PageToken,
			"sort_by":        string(params.SortBy),
			"switch_port_id": params.SwitchPortId,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchPortResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortListAllPages: List switch ports
//
// This method is a wrapper around the `NetworkingSwitchPortList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingSwitchPortListAllPages(ctx context.Context, params NetworkingSwitchPortListParams) ([]SwitchPort, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SwitchPort
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.NetworkingSwitchPortList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingSwitchPortLldpConfigView: Fetch the LLDP configuration for a switch port
func (c *Client) NetworkingSwitchPortLldpConfigView(ctx context.Context, params NetworkingSwitchPortLldpConfigViewParams) (*LldpLinkConfig, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/switch-port/{{.port}}/lldp/config"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{
			"rack_id":         params.RackId,
			"switch_location": string(params.SwitchLocation),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body LldpLinkConfig
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortLldpConfigUpdate: Update the LLDP configuration for a switch port
func (c *Client) NetworkingSwitchPortLldpConfigUpdate(ctx context.Context, params NetworkingSwitchPortLldpConfigUpdateParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/hardware/switch-port/{{.port}}/lldp/config"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{
			"rack_id":         params.RackId,
			"switch_location": string(params.SwitchLocation),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingSwitchPortApplySettings: Apply switch port settings
func (c *Client) NetworkingSwitchPortApplySettings(ctx context.Context, params NetworkingSwitchPortApplySettingsParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/hardware/switch-port/{{.port}}/settings"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{
			"rack_id":         params.RackId,
			"switch_location": string(params.SwitchLocation),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingSwitchPortClearSettings: Clear switch port settings
func (c *Client) NetworkingSwitchPortClearSettings(ctx context.Context, params NetworkingSwitchPortClearSettingsParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/hardware/switch-port/{{.port}}/settings"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{
			"rack_id":         params.RackId,
			"switch_location": string(params.SwitchLocation),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingSwitchPortStatus: Get switch port status
func (c *Client) NetworkingSwitchPortStatus(ctx context.Context, params NetworkingSwitchPortStatusParams) (*SwitchLinkState, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/switch-port/{{.port}}/status"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{
			"rack_id":         params.RackId,
			"switch_location": string(params.SwitchLocation),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchLinkState
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SwitchList: List switches
//
// To iterate over all pages, use the `SwitchListAllPages` method, instead.
func (c *Client) SwitchList(ctx context.Context, params SwitchListParams) (*SwitchResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/switches"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SwitchListAllPages: List switches
//
// This method is a wrapper around the `SwitchList` method.
// This method returns all the pages at once.
func (c *Client) SwitchListAllPages(ctx context.Context, params SwitchListParams) ([]Switch, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Switch
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SwitchList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SwitchView: Fetch switch
func (c *Client) SwitchView(ctx context.Context, params SwitchViewParams) (*Switch, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/switches/{{.switch_id}}"),
		map[string]string{
			"switch_id": params.SwitchId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Switch
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloIdentityProviderList: List identity providers for silo
// List identity providers for silo by silo name or ID.
//
// To iterate over all pages, use the `SiloIdentityProviderListAllPages` method, instead.
func (c *Client) SiloIdentityProviderList(ctx context.Context, params SiloIdentityProviderListParams) (*IdentityProviderResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/identity-providers"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"silo":       string(params.Silo),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IdentityProviderResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloIdentityProviderListAllPages: List identity providers for silo
// List identity providers for silo by silo name or ID.
//
// This method is a wrapper around the `SiloIdentityProviderList` method.
// This method returns all the pages at once.
func (c *Client) SiloIdentityProviderListAllPages(ctx context.Context, params SiloIdentityProviderListParams) ([]IdentityProvider, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IdentityProvider
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SiloIdentityProviderList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// LocalIdpUserCreate: Create user
// Users can only be created in Silos with `provision_type` == `Fixed`. Otherwise, Silo users are just-in-time (JIT)
// provisioned when a user first logs in using an external Identity Provider.
func (c *Client) LocalIdpUserCreate(ctx context.Context, params LocalIdpUserCreateParams) (*User, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/identity-providers/local/users"),
		map[string]string{},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body User
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// LocalIdpUserDelete: Delete user
func (c *Client) LocalIdpUserDelete(ctx context.Context, params LocalIdpUserDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/identity-providers/local/users/{{.user_id}}"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// LocalIdpUserSetPassword: Set or invalidate user's password
// Passwords can only be updated for users in Silos with identity mode `LocalOnly`.
func (c *Client) LocalIdpUserSetPassword(ctx context.Context, params LocalIdpUserSetPasswordParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/identity-providers/local/users/{{.user_id}}/set-password"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// SamlIdentityProviderCreate: Create SAML identity provider
func (c *Client) SamlIdentityProviderCreate(ctx context.Context, params SamlIdentityProviderCreateParams) (*SamlIdentityProvider, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/identity-providers/saml"),
		map[string]string{},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SamlIdentityProvider
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SamlIdentityProviderView: Fetch SAML identity provider
func (c *Client) SamlIdentityProviderView(ctx context.Context, params SamlIdentityProviderViewParams) (*SamlIdentityProvider, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/identity-providers/saml/{{.provider}}"),
		map[string]string{
			"provider": string(params.Provider),
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SamlIdentityProvider
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolList: List IP pools
//
// To iterate over all pages, use the `IpPoolListAllPages` method, instead.
func (c *Client) IpPoolList(ctx context.Context, params IpPoolListParams) (*IpPoolResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolListAllPages: List IP pools
//
// This method is a wrapper around the `IpPoolList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolListAllPages(ctx context.Context, params IpPoolListParams) ([]IpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IpPool
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.IpPoolList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// IpPoolCreate: Create IP pool
// IPv6 is not yet supported for unicast pools.
func (c *Client) IpPoolCreate(ctx context.Context, params IpPoolCreateParams) (*IpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceView: Fetch Oxide service IP pool
func (c *Client) IpPoolServiceView(ctx context.Context) (*IpPool, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools-service"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeList: List IP ranges for the Oxide service pool
// Ranges are ordered by their first address.
//
// To iterate over all pages, use the `IpPoolServiceRangeListAllPages` method, instead.
func (c *Client) IpPoolServiceRangeList(ctx context.Context, params IpPoolServiceRangeListParams) (*IpPoolRangeResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools-service/ranges"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRangeResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeListAllPages: List IP ranges for the Oxide service pool
// Ranges are ordered by their first address.
//
// This method is a wrapper around the `IpPoolServiceRangeList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolServiceRangeListAllPages(ctx context.Context, params IpPoolServiceRangeListParams) ([]IpPoolRange, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IpPoolRange
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.IpPoolServiceRangeList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// IpPoolServiceRangeAdd: Add IP range to Oxide service pool
// IPv6 ranges are not allowed yet.
func (c *Client) IpPoolServiceRangeAdd(ctx context.Context, params IpPoolServiceRangeAddParams) (*IpPoolRange, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools-service/ranges/add"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRange
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeRemove: Remove IP range from Oxide service pool
func (c *Client) IpPoolServiceRangeRemove(ctx context.Context, params IpPoolServiceRangeRemoveParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools-service/ranges/remove"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolView: Fetch IP pool
func (c *Client) IpPoolView(ctx context.Context, params IpPoolViewParams) (*IpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolUpdate: Update IP pool
func (c *Client) IpPoolUpdate(ctx context.Context, params IpPoolUpdateParams) (*IpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolDelete: Delete IP pool
func (c *Client) IpPoolDelete(ctx context.Context, params IpPoolDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolRangeList: List ranges for IP pool
// Ranges are ordered by their first address.
//
// To iterate over all pages, use the `IpPoolRangeListAllPages` method, instead.
func (c *Client) IpPoolRangeList(ctx context.Context, params IpPoolRangeListParams) (*IpPoolRangeResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/ranges"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRangeResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolRangeListAllPages: List ranges for IP pool
// Ranges are ordered by their first address.
//
// This method is a wrapper around the `IpPoolRangeList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolRangeListAllPages(ctx context.Context, params IpPoolRangeListParams) ([]IpPoolRange, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IpPoolRange
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.IpPoolRangeList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// IpPoolRangeAdd: Add range to IP pool.
// IPv6 ranges are not allowed yet for unicast pools.
//
// For multicast pools, all ranges must be either Any-Source Multicast (ASM) or Source-Specific Multicast (SSM),
// but not both. Mixing ASM and SSM ranges in the same pool is not allowed.
//
// ASM: IPv4 addresses outside 232.0.0.0/8, IPv6 addresses with flag field != 3 SSM: IPv4 addresses in 232.0.0.0/8, IPv6
// addresses with flag field = 3
func (c *Client) IpPoolRangeAdd(ctx context.Context, params IpPoolRangeAddParams) (*IpPoolRange, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/ranges/add"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRange
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolRangeRemove: Remove range from IP pool
func (c *Client) IpPoolRangeRemove(ctx context.Context, params IpPoolRangeRemoveParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/ranges/remove"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolSiloList: List IP pool's linked silos
//
// To iterate over all pages, use the `IpPoolSiloListAllPages` method, instead.
func (c *Client) IpPoolSiloList(ctx context.Context, params IpPoolSiloListParams) (*IpPoolSiloLinkResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/silos"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolSiloLinkResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolSiloListAllPages: List IP pool's linked silos
//
// This method is a wrapper around the `IpPoolSiloList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolSiloListAllPages(ctx context.Context, params IpPoolSiloListParams) ([]IpPoolSiloLink, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IpPoolSiloLink
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.IpPoolSiloList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// IpPoolSiloLink: Link IP pool to silo
// Users in linked silos can allocate external IPs from this pool for their instances. A silo can have at most
// one default pool. IPs are allocated from the default pool when users ask for one without specifying a pool.
func (c *Client) IpPoolSiloLink(ctx context.Context, params IpPoolSiloLinkParams) (*IpPoolSiloLink, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/silos"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolSiloLink
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolSiloUpdate: Make IP pool default for silo
// When a user asks for an IP (e.g., at instance create time) without specifying a pool, the IP comes from the
// default pool if a default is configured. When a pool is made the default for a silo, any existing default will
// remain linked to the silo, but will no longer be the default.
func (c *Client) IpPoolSiloUpdate(ctx context.Context, params IpPoolSiloUpdateParams) (*IpPoolSiloLink, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/silos/{{.silo}}"),
		map[string]string{
			"pool": string(params.Pool),
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolSiloLink
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolSiloUnlink: Unlink IP pool from silo
// Will fail if there are any outstanding IPs allocated in the silo.
func (c *Client) IpPoolSiloUnlink(ctx context.Context, params IpPoolSiloUnlinkParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/silos/{{.silo}}"),
		map[string]string{
			"pool": string(params.Pool),
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolUtilizationView: Fetch IP pool utilization
func (c *Client) IpPoolUtilizationView(ctx context.Context, params IpPoolUtilizationViewParams) (*IpPoolUtilization, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/utilization"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolUtilization
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemMetric: View metrics
// View CPU, memory, or storage utilization metrics at the fleet or silo level.
//
// To iterate over all pages, use the `SystemMetricAllPages` method, instead.
func (c *Client) SystemMetric(ctx context.Context, params SystemMetricParams) (*MeasurementResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/metrics/{{.metric_name}}"),
		map[string]string{
			"metric_name": string(params.MetricName),
		},
		map[string]string{
			"end_time":   params.EndTime.Format(time.RFC3339),
			"limit":      PointerIntToStr(params.Limit),
			"order":      string(params.Order),
			"page_token": params.PageToken,
			"silo":       string(params.Silo),
			"start_time": params.StartTime.Format(time.RFC3339),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body MeasurementResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemMetricAllPages: View metrics
// View CPU, memory, or storage utilization metrics at the fleet or silo level.
//
// This method is a wrapper around the `SystemMetric` method.
// This method returns all the pages at once.
func (c *Client) SystemMetricAllPages(ctx context.Context, params SystemMetricParams) ([]Measurement, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Measurement
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SystemMetric(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingAddressLotList: List address lots
//
// To iterate over all pages, use the `NetworkingAddressLotListAllPages` method, instead.
func (c *Client) NetworkingAddressLotList(ctx context.Context, params NetworkingAddressLotListParams) (*AddressLotResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/address-lot"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AddressLotResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingAddressLotListAllPages: List address lots
//
// This method is a wrapper around the `NetworkingAddressLotList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingAddressLotListAllPages(ctx context.Context, params NetworkingAddressLotListParams) ([]AddressLot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AddressLot
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.NetworkingAddressLotList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingAddressLotCreate: Create address lot
func (c *Client) NetworkingAddressLotCreate(ctx context.Context, params NetworkingAddressLotCreateParams) (*AddressLotCreateResponse, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/address-lot"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AddressLotCreateResponse
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingAddressLotView: Fetch address lot
func (c *Client) NetworkingAddressLotView(ctx context.Context, params NetworkingAddressLotViewParams) (*AddressLotViewResponse, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/address-lot/{{.address_lot}}"),
		map[string]string{
			"address_lot": string(params.AddressLot),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AddressLotViewResponse
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingAddressLotDelete: Delete address lot
func (c *Client) NetworkingAddressLotDelete(ctx context.Context, params NetworkingAddressLotDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/address-lot/{{.address_lot}}"),
		map[string]string{
			"address_lot": string(params.AddressLot),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingAddressLotBlockList: List blocks in address lot
//
// To iterate over all pages, use the `NetworkingAddressLotBlockListAllPages` method, instead.
func (c *Client) NetworkingAddressLotBlockList(ctx context.Context, params NetworkingAddressLotBlockListParams) (*AddressLotBlockResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/address-lot/{{.address_lot}}/blocks"),
		map[string]string{
			"address_lot": string(params.AddressLot),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AddressLotBlockResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingAddressLotBlockListAllPages: List blocks in address lot
//
// This method is a wrapper around the `NetworkingAddressLotBlockList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingAddressLotBlockListAllPages(ctx context.Context, params NetworkingAddressLotBlockListParams) ([]AddressLotBlock, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AddressLotBlock
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.NetworkingAddressLotBlockList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingAllowListView: Get user-facing services IP allowlist
func (c *Client) NetworkingAllowListView(ctx context.Context) (*AllowList, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/allow-list"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AllowList
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingAllowListUpdate: Update user-facing services IP allowlist
func (c *Client) NetworkingAllowListUpdate(ctx context.Context, params NetworkingAllowListUpdateParams) (*AllowList, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/networking/allow-list"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AllowList
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBfdDisable: Disable a BFD session
func (c *Client) NetworkingBfdDisable(ctx context.Context, params NetworkingBfdDisableParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/bfd-disable"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingBfdEnable: Enable a BFD session
func (c *Client) NetworkingBfdEnable(ctx context.Context, params NetworkingBfdEnableParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/bfd-enable"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingBfdStatus: Get BFD status
func (c *Client) NetworkingBfdStatus(ctx context.Context) (*[]BfdStatus, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bfd-status"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BfdStatus
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpConfigList: List BGP configurations
//
// To iterate over all pages, use the `NetworkingBgpConfigListAllPages` method, instead.
func (c *Client) NetworkingBgpConfigList(ctx context.Context, params NetworkingBgpConfigListParams) (*BgpConfigResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body BgpConfigResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpConfigListAllPages: List BGP configurations
//
// This method is a wrapper around the `NetworkingBgpConfigList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingBgpConfigListAllPages(ctx context.Context, params NetworkingBgpConfigListParams) ([]BgpConfig, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []BgpConfig
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.NetworkingBgpConfigList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingBgpConfigCreate: Create new BGP configuration
func (c *Client) NetworkingBgpConfigCreate(ctx context.Context, params NetworkingBgpConfigCreateParams) (*BgpConfig, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/bgp"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body BgpConfig
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpConfigDelete: Delete BGP configuration
func (c *Client) NetworkingBgpConfigDelete(ctx context.Context, params NetworkingBgpConfigDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/bgp"),
		map[string]string{},
		map[string]string{
			"name_or_id": string(params.NameOrId),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingBgpAnnounceSetList: List BGP announce sets
//
// To iterate over all pages, use the `NetworkingBgpAnnounceSetListAllPages` method, instead.
func (c *Client) NetworkingBgpAnnounceSetList(ctx context.Context, params NetworkingBgpAnnounceSetListParams) (*[]BgpAnnounceSet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-announce-set"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BgpAnnounceSet
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpAnnounceSetUpdate: Update BGP announce set
// If the announce set exists, this endpoint replaces the existing announce set with the one specified.
func (c *Client) NetworkingBgpAnnounceSetUpdate(ctx context.Context, params NetworkingBgpAnnounceSetUpdateParams) (*BgpAnnounceSet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/networking/bgp-announce-set"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body BgpAnnounceSet
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpAnnounceSetDelete: Delete BGP announce set
func (c *Client) NetworkingBgpAnnounceSetDelete(ctx context.Context, params NetworkingBgpAnnounceSetDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/bgp-announce-set/{{.announce_set}}"),
		map[string]string{
			"announce_set": string(params.AnnounceSet),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingBgpAnnouncementList: Get originated routes for a specified BGP announce set
func (c *Client) NetworkingBgpAnnouncementList(ctx context.Context, params NetworkingBgpAnnouncementListParams) (*[]BgpAnnouncement, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-announce-set/{{.announce_set}}/announcement"),
		map[string]string{
			"announce_set": string(params.AnnounceSet),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BgpAnnouncement
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpExported: Get BGP exported routes
func (c *Client) NetworkingBgpExported(ctx context.Context) (*BgpExported, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-exported"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body BgpExported
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpMessageHistory: Get BGP router message history
func (c *Client) NetworkingBgpMessageHistory(ctx context.Context, params NetworkingBgpMessageHistoryParams) (*AggregateBgpMessageHistory, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-message-history"),
		map[string]string{},
		map[string]string{
			"asn": PointerIntToStr(params.Asn),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AggregateBgpMessageHistory
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpImportedRoutesIpv4: Get imported IPv4 BGP routes
func (c *Client) NetworkingBgpImportedRoutesIpv4(ctx context.Context, params NetworkingBgpImportedRoutesIpv4Params) (*[]BgpImportedRouteIpv4, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-routes-ipv4"),
		map[string]string{},
		map[string]string{
			"asn": PointerIntToStr(params.Asn),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BgpImportedRouteIpv4
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpStatus: Get BGP peer status
func (c *Client) NetworkingBgpStatus(ctx context.Context) (*[]BgpPeerStatus, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-status"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BgpPeerStatus
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingInboundIcmpView: Return whether API services can receive limited ICMP traffic
func (c *Client) NetworkingInboundIcmpView(ctx context.Context) (*ServiceIcmpConfig, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/inbound-icmp"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ServiceIcmpConfig
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingInboundIcmpUpdate: Set whether API services can receive limited ICMP traffic
func (c *Client) NetworkingInboundIcmpUpdate(ctx context.Context, params NetworkingInboundIcmpUpdateParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/networking/inbound-icmp"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingLoopbackAddressList: List loopback addresses
//
// To iterate over all pages, use the `NetworkingLoopbackAddressListAllPages` method, instead.
func (c *Client) NetworkingLoopbackAddressList(ctx context.Context, params NetworkingLoopbackAddressListParams) (*LoopbackAddressResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/loopback-address"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body LoopbackAddressResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingLoopbackAddressListAllPages: List loopback addresses
//
// This method is a wrapper around the `NetworkingLoopbackAddressList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingLoopbackAddressListAllPages(ctx context.Context, params NetworkingLoopbackAddressListParams) ([]LoopbackAddress, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []LoopbackAddress
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.NetworkingLoopbackAddressList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingLoopbackAddressCreate: Create loopback address
func (c *Client) NetworkingLoopbackAddressCreate(ctx context.Context, params NetworkingLoopbackAddressCreateParams) (*LoopbackAddress, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/loopback-address"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body LoopbackAddress
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingLoopbackAddressDelete: Delete loopback address
func (c *Client) NetworkingLoopbackAddressDelete(ctx context.Context, params NetworkingLoopbackAddressDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/loopback-address/{{.rack_id}}/{{.switch_location}}/{{.address}}/{{.subnet_mask}}"),
		map[string]string{
			"address":         params.Address,
			"rack_id":         params.RackId,
			"subnet_mask":     PointerIntToStr(params.SubnetMask),
			"switch_location": string(params.SwitchLocation),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingSwitchPortSettingsList: List switch port settings
//
// To iterate over all pages, use the `NetworkingSwitchPortSettingsListAllPages` method, instead.
func (c *Client) NetworkingSwitchPortSettingsList(ctx context.Context, params NetworkingSwitchPortSettingsListParams) (*SwitchPortSettingsIdentityResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/switch-port-settings"),
		map[string]string{},
		map[string]string{
			"limit":         PointerIntToStr(params.Limit),
			"page_token":    params.PageToken,
			"port_settings": string(params.PortSettings),
			"sort_by":       string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchPortSettingsIdentityResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortSettingsListAllPages: List switch port settings
//
// This method is a wrapper around the `NetworkingSwitchPortSettingsList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingSwitchPortSettingsListAllPages(ctx context.Context, params NetworkingSwitchPortSettingsListParams) ([]SwitchPortSettingsIdentity, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SwitchPortSettingsIdentity
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.NetworkingSwitchPortSettingsList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingSwitchPortSettingsCreate: Create switch port settings
func (c *Client) NetworkingSwitchPortSettingsCreate(ctx context.Context, params NetworkingSwitchPortSettingsCreateParams) (*SwitchPortSettings, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/switch-port-settings"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchPortSettings
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortSettingsDelete: Delete switch port settings
func (c *Client) NetworkingSwitchPortSettingsDelete(ctx context.Context, params NetworkingSwitchPortSettingsDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/switch-port-settings"),
		map[string]string{},
		map[string]string{
			"port_settings": string(params.PortSettings),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingSwitchPortSettingsView: Get information about switch port
func (c *Client) NetworkingSwitchPortSettingsView(ctx context.Context, params NetworkingSwitchPortSettingsViewParams) (*SwitchPortSettings, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/switch-port-settings/{{.port}}"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchPortSettings
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemPolicyView: Fetch top-level IAM policy
func (c *Client) SystemPolicyView(ctx context.Context) (*FleetRolePolicy, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemPolicyUpdate: Update top-level IAM policy
func (c *Client) SystemPolicyUpdate(ctx context.Context, params SystemPolicyUpdateParams) (*FleetRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ScimTokenList: List SCIM tokens
// Specify the silo by name or ID using the `silo` query parameter.
func (c *Client) ScimTokenList(ctx context.Context, params ScimTokenListParams) (*[]ScimClientBearerToken, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/scim/tokens"),
		map[string]string{},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []ScimClientBearerToken
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ScimTokenCreate: Create SCIM token
// Specify the silo by name or ID using the `silo` query parameter. Be sure to save the bearer token in the
// response. It will not be retrievable later through the token view and list endpoints.
func (c *Client) ScimTokenCreate(ctx context.Context, params ScimTokenCreateParams) (*ScimClientBearerTokenValue, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/system/scim/tokens"),
		map[string]string{},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ScimClientBearerTokenValue
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ScimTokenView: Fetch SCIM token
// Specify the silo by name or ID using the `silo` query parameter.
func (c *Client) ScimTokenView(ctx context.Context, params ScimTokenViewParams) (*ScimClientBearerToken, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/scim/tokens/{{.token_id}}"),
		map[string]string{
			"token_id": params.TokenId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ScimClientBearerToken
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ScimTokenDelete: Delete SCIM token
// Specify the silo by name or ID using the `silo` query parameter.
func (c *Client) ScimTokenDelete(ctx context.Context, params ScimTokenDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/scim/tokens/{{.token_id}}"),
		map[string]string{
			"token_id": params.TokenId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// SystemQuotasList: Lists resource quotas for all silos
//
// To iterate over all pages, use the `SystemQuotasListAllPages` method, instead.
func (c *Client) SystemQuotasList(ctx context.Context, params SystemQuotasListParams) (*SiloQuotasResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silo-quotas"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloQuotasResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemQuotasListAllPages: Lists resource quotas for all silos
//
// This method is a wrapper around the `SystemQuotasList` method.
// This method returns all the pages at once.
func (c *Client) SystemQuotasListAllPages(ctx context.Context, params SystemQuotasListParams) ([]SiloQuotas, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SiloQuotas
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SystemQuotasList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SiloList: List silos
// Lists silos that are discoverable based on the current permissions.
//
// To iterate over all pages, use the `SiloListAllPages` method, instead.
func (c *Client) SiloList(ctx context.Context, params SiloListParams) (*SiloResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloListAllPages: List silos
// Lists silos that are discoverable based on the current permissions.
//
// This method is a wrapper around the `SiloList` method.
// This method returns all the pages at once.
func (c *Client) SiloListAllPages(ctx context.Context, params SiloListParams) ([]Silo, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Silo
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SiloList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SiloCreate: Create a silo
func (c *Client) SiloCreate(ctx context.Context, params SiloCreateParams) (*Silo, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/silos"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Silo
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloView: Fetch silo
// Fetch silo by name or ID.
func (c *Client) SiloView(ctx context.Context, params SiloViewParams) (*Silo, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Silo
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloDelete: Delete a silo
// Delete a silo by name or ID.
func (c *Client) SiloDelete(ctx context.Context, params SiloDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// SiloIpPoolList: List IP pools linked to silo
// Linked IP pools are available to users in the specified silo. A silo can have at most one default pool. IPs
// are allocated from the default pool when users ask for one without specifying a pool.
//
// To iterate over all pages, use the `SiloIpPoolListAllPages` method, instead.
func (c *Client) SiloIpPoolList(ctx context.Context, params SiloIpPoolListParams) (*SiloIpPoolResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/ip-pools"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloIpPoolResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloIpPoolListAllPages: List IP pools linked to silo
// Linked IP pools are available to users in the specified silo. A silo can have at most one default pool. IPs
// are allocated from the default pool when users ask for one without specifying a pool.
//
// This method is a wrapper around the `SiloIpPoolList` method.
// This method returns all the pages at once.
func (c *Client) SiloIpPoolListAllPages(ctx context.Context, params SiloIpPoolListParams) ([]SiloIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SiloIpPool
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SiloIpPoolList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SiloPolicyView: Fetch silo IAM policy
func (c *Client) SiloPolicyView(ctx context.Context, params SiloPolicyViewParams) (*SiloRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/policy"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloPolicyUpdate: Update silo IAM policy
func (c *Client) SiloPolicyUpdate(ctx context.Context, params SiloPolicyUpdateParams) (*SiloRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/policy"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloQuotasView: Fetch resource quotas for silo
func (c *Client) SiloQuotasView(ctx context.Context, params SiloQuotasViewParams) (*SiloQuotas, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/quotas"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloQuotas
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloQuotasUpdate: Update resource quotas for silo
// If a quota value is not specified, it will remain unchanged.
func (c *Client) SiloQuotasUpdate(ctx context.Context, params SiloQuotasUpdateParams) (*SiloQuotas, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/quotas"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloQuotas
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemTimeseriesQuery: Run timeseries query
// Queries are written in OxQL.
func (c *Client) SystemTimeseriesQuery(ctx context.Context, params SystemTimeseriesQueryParams) (*OxqlQueryResult, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/timeseries/query"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OxqlQueryResult
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemTimeseriesSchemaList: List timeseries schemas
//
// To iterate over all pages, use the `SystemTimeseriesSchemaListAllPages` method, instead.
func (c *Client) SystemTimeseriesSchemaList(ctx context.Context, params SystemTimeseriesSchemaListParams) (*TimeseriesSchemaResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/timeseries/schemas"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body TimeseriesSchemaResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemTimeseriesSchemaListAllPages: List timeseries schemas
//
// This method is a wrapper around the `SystemTimeseriesSchemaList` method.
// This method returns all the pages at once.
func (c *Client) SystemTimeseriesSchemaListAllPages(ctx context.Context, params SystemTimeseriesSchemaListParams) ([]TimeseriesSchema, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []TimeseriesSchema
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SystemTimeseriesSchemaList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SystemUpdateRepositoryList: List all TUF repositories
// Returns a paginated list of all TUF repositories ordered by system version (newest first by default).
//
// To iterate over all pages, use the `SystemUpdateRepositoryListAllPages` method, instead.
func (c *Client) SystemUpdateRepositoryList(ctx context.Context, params SystemUpdateRepositoryListParams) (*TufRepoResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/update/repositories"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body TufRepoResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateRepositoryListAllPages: List all TUF repositories
// Returns a paginated list of all TUF repositories ordered by system version (newest first by default).
//
// This method is a wrapper around the `SystemUpdateRepositoryList` method.
// This method returns all the pages at once.
func (c *Client) SystemUpdateRepositoryListAllPages(ctx context.Context, params SystemUpdateRepositoryListParams) ([]TufRepo, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []TufRepo
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SystemUpdateRepositoryList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SystemUpdateRepositoryUpload: Upload system release repository
// System release repositories are verified by the updates trust store.
func (c *Client) SystemUpdateRepositoryUpload(ctx context.Context, params SystemUpdateRepositoryUploadParams) (*TufRepoUpload, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	b := params.Body

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/update/repositories"),
		map[string]string{},
		map[string]string{
			"file_name": params.FileName,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body TufRepoUpload
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateRepositoryView: Fetch system release repository by version
func (c *Client) SystemUpdateRepositoryView(ctx context.Context, params SystemUpdateRepositoryViewParams) (*TufRepo, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/update/repositories/{{.system_version}}"),
		map[string]string{
			"system_version": params.SystemVersion,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body TufRepo
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateStatus: Fetch system update status
// Returns information about the current target release and the progress of system software updates.
func (c *Client) SystemUpdateStatus(ctx context.Context) (*UpdateStatus, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/update/status"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateStatus
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// TargetReleaseUpdate: Set target release
// Set the current target release of the rack's system software. The rack reconfigurator will treat the software
// specified here as a goal state for the rack's software, and attempt to asynchronously update to that release.
// Use the update status endpoint to view the current target release.
func (c *Client) TargetReleaseUpdate(ctx context.Context, params TargetReleaseUpdateParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/update/target-release"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// SystemUpdateTrustRootList: List root roles in the updates trust store
// A root role is a JSON document describing the cryptographic keys that are trusted to sign system release repositories,
// as described by The Update Framework. Uploading a repository requires its metadata to be signed by keys trusted
// by the trust store.
//
// To iterate over all pages, use the `SystemUpdateTrustRootListAllPages` method, instead.
func (c *Client) SystemUpdateTrustRootList(ctx context.Context, params SystemUpdateTrustRootListParams) (*UpdatesTrustRootResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/update/trust-roots"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdatesTrustRootResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateTrustRootListAllPages: List root roles in the updates trust store
// A root role is a JSON document describing the cryptographic keys that are trusted to sign system release repositories,
// as described by The Update Framework. Uploading a repository requires its metadata to be signed by keys trusted
// by the trust store.
//
// This method is a wrapper around the `SystemUpdateTrustRootList` method.
// This method returns all the pages at once.
func (c *Client) SystemUpdateTrustRootListAllPages(ctx context.Context, params SystemUpdateTrustRootListParams) ([]UpdatesTrustRoot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []UpdatesTrustRoot
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SystemUpdateTrustRootList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SystemUpdateTrustRootCreate: Add trusted root role to updates trust store
func (c *Client) SystemUpdateTrustRootCreate(ctx context.Context, params SystemUpdateTrustRootCreateParams) (*UpdatesTrustRoot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/update/trust-roots"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdatesTrustRoot
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateTrustRootView: Fetch trusted root role
func (c *Client) SystemUpdateTrustRootView(ctx context.Context, params SystemUpdateTrustRootViewParams) (*UpdatesTrustRoot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/update/trust-roots/{{.trust_root_id}}"),
		map[string]string{
			"trust_root_id": params.TrustRootId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdatesTrustRoot
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateTrustRootDelete: Delete trusted root role
// Note that this method does not currently check for any uploaded system release repositories that would become
// untrusted after deleting the root role.
func (c *Client) SystemUpdateTrustRootDelete(ctx context.Context, params SystemUpdateTrustRootDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/update/trust-roots/{{.trust_root_id}}"),
		map[string]string{
			"trust_root_id": params.TrustRootId,
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// SiloUserList: List built-in (system) users in silo
//
// To iterate over all pages, use the `SiloUserListAllPages` method, instead.
func (c *Client) SiloUserList(ctx context.Context, params SiloUserListParams) (*UserResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/users"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"silo":       string(params.Silo),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUserListAllPages: List built-in (system) users in silo
//
// This method is a wrapper around the `SiloUserList` method.
// This method returns all the pages at once.
func (c *Client) SiloUserListAllPages(ctx context.Context, params SiloUserListParams) ([]User, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []User
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SiloUserList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// UserBuiltinList: List built-in users
//
// To iterate over all pages, use the `UserBuiltinListAllPages` method, instead.
func (c *Client) UserBuiltinList(ctx context.Context, params UserBuiltinListParams) (*UserBuiltinResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/users-builtin"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserBuiltinResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserBuiltinListAllPages: List built-in users
//
// This method is a wrapper around the `UserBuiltinList` method.
// This method returns all the pages at once.
func (c *Client) UserBuiltinListAllPages(ctx context.Context, params UserBuiltinListParams) ([]UserBuiltin, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []UserBuiltin
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.UserBuiltinList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// UserBuiltinView: Fetch built-in user
func (c *Client) UserBuiltinView(ctx context.Context, params UserBuiltinViewParams) (*UserBuiltin, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/users-builtin/{{.user}}"),
		map[string]string{
			"user": string(params.User),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserBuiltin
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUserView: Fetch built-in (system) user
func (c *Client) SiloUserView(ctx context.Context, params SiloUserViewParams) (*User, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/users/{{.user_id}}"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body User
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUtilizationList: List current utilization state for all silos
//
// To iterate over all pages, use the `SiloUtilizationListAllPages` method, instead.
func (c *Client) SiloUtilizationList(ctx context.Context, params SiloUtilizationListParams) (*SiloUtilizationResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/utilization/silos"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloUtilizationResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUtilizationListAllPages: List current utilization state for all silos
//
// This method is a wrapper around the `SiloUtilizationList` method.
// This method returns all the pages at once.
func (c *Client) SiloUtilizationListAllPages(ctx context.Context, params SiloUtilizationListParams) ([]SiloUtilization, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SiloUtilization
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.SiloUtilizationList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SiloUtilizationView: Fetch current utilization for given silo
func (c *Client) SiloUtilizationView(ctx context.Context, params SiloUtilizationViewParams) (*SiloUtilization, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/utilization/silos/{{.silo}}"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloUtilization
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserList: List users
//
// To iterate over all pages, use the `UserListAllPages` method, instead.
func (c *Client) UserList(ctx context.Context, params UserListParams) (*UserResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/users"),
		map[string]string{},
		map[string]string{
			"group":      params.Group,
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserListAllPages: List users
//
// This method is a wrapper around the `UserList` method.
// This method returns all the pages at once.
func (c *Client) UserListAllPages(ctx context.Context, params UserListParams) ([]User, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []User
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.UserList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// UserView: Fetch user
func (c *Client) UserView(ctx context.Context, params UserViewParams) (*User, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/users/{{.user_id}}"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body User
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserTokenList: List user's access tokens
//
// To iterate over all pages, use the `UserTokenListAllPages` method, instead.
func (c *Client) UserTokenList(ctx context.Context, params UserTokenListParams) (*DeviceAccessTokenResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/users/{{.user_id}}/access-tokens"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DeviceAccessTokenResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserTokenListAllPages: List user's access tokens
//
// This method is a wrapper around the `UserTokenList` method.
// This method returns all the pages at once.
func (c *Client) UserTokenListAllPages(ctx context.Context, params UserTokenListParams) ([]DeviceAccessToken, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []DeviceAccessToken
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.UserTokenList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// UserLogout: Log user out
// Silo admins can use this endpoint to log the specified user out by deleting all of their tokens AND sessions. This
// cannot be undone.
func (c *Client) UserLogout(ctx context.Context, params UserLogoutParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/users/{{.user_id}}/logout"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// UserSessionList: List user's console sessions
//
// To iterate over all pages, use the `UserSessionListAllPages` method, instead.
func (c *Client) UserSessionList(ctx context.Context, params UserSessionListParams) (*ConsoleSessionResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/users/{{.user_id}}/sessions"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ConsoleSessionResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserSessionListAllPages: List user's console sessions
//
// This method is a wrapper around the `UserSessionList` method.
// This method returns all the pages at once.
func (c *Client) UserSessionListAllPages(ctx context.Context, params UserSessionListParams) ([]ConsoleSession, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []ConsoleSession
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.UserSessionList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// UtilizationView: Fetch resource utilization for user's current silo
func (c *Client) UtilizationView(ctx context.Context) (*Utilization, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/utilization"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Utilization
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcFirewallRulesView: List firewall rules
func (c *Client) VpcFirewallRulesView(ctx context.Context, params VpcFirewallRulesViewParams) (*VpcFirewallRules, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-firewall-rules"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcFirewallRulesUpdate: Replace firewall rules
// The maximum number of rules per VPC is 1024.
//
// Targets are used to specify the set of instances to which a firewall rule applies. You can target instances directly
// by name, or specify a VPC, VPC subnet, IP, or IP subnet, which will apply the rule to traffic going to all
// matching instances. Targets are additive: the rule applies to instances matching ANY target. The maximum number
// of targets is 256.
//
// Filters reduce the scope of a firewall rule. Without filters, the rule applies to all packets to the targets
// (or from the targets, if it's an outbound rule). With multiple filters, the rule applies only to packets matching
// ALL filters. The maximum number of each type of filter is 256.
func (c *Client) VpcFirewallRulesUpdate(ctx context.Context, params VpcFirewallRulesUpdateParams) (*VpcFirewallRules, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpc-firewall-rules"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteList: List routes
// List the routes associated with a router in a particular VPC.
//
// To iterate over all pages, use the `VpcRouterRouteListAllPages` method, instead.
func (c *Client) VpcRouterRouteList(ctx context.Context, params VpcRouterRouteListParams) (*RouterRouteResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-router-routes"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"router":     string(params.Router),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRouteResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteListAllPages: List routes
// List the routes associated with a router in a particular VPC.
//
// This method is a wrapper around the `VpcRouterRouteList` method.
// This method returns all the pages at once.
func (c *Client) VpcRouterRouteListAllPages(ctx context.Context, params VpcRouterRouteListParams) ([]RouterRoute, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []RouterRoute
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.VpcRouterRouteList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcRouterRouteCreate: Create route
func (c *Client) VpcRouterRouteCreate(ctx context.Context, params VpcRouterRouteCreateParams) (*RouterRoute, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/vpc-router-routes"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteView: Fetch route
func (c *Client) VpcRouterRouteView(ctx context.Context, params VpcRouterRouteViewParams) (*RouterRoute, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-router-routes/{{.route}}"),
		map[string]string{
			"route": string(params.Route),
		},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteUpdate: Update route
func (c *Client) VpcRouterRouteUpdate(ctx context.Context, params VpcRouterRouteUpdateParams) (*RouterRoute, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpc-router-routes/{{.route}}"),
		map[string]string{
			"route": string(params.Route),
		},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteDelete: Delete route
func (c *Client) VpcRouterRouteDelete(ctx context.Context, params VpcRouterRouteDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/vpc-router-routes/{{.route}}"),
		map[string]string{
			"route": string(params.Route),
		},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// VpcRouterList: List routers
//
// To iterate over all pages, use the `VpcRouterListAllPages` method, instead.
func (c *Client) VpcRouterList(ctx context.Context, params VpcRouterListParams) (*VpcRouterResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-routers"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouterResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterListAllPages: List routers
//
// This method is a wrapper around the `VpcRouterList` method.
// This method returns all the pages at once.
func (c *Client) VpcRouterListAllPages(ctx context.Context, params VpcRouterListParams) ([]VpcRouter, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []VpcRouter
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.VpcRouterList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcRouterCreate: Create VPC router
func (c *Client) VpcRouterCreate(ctx context.Context, params VpcRouterCreateParams) (*VpcRouter, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/vpc-routers"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterView: Fetch router
func (c *Client) VpcRouterView(ctx context.Context, params VpcRouterViewParams) (*VpcRouter, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-routers/{{.router}}"),
		map[string]string{
			"router": string(params.Router),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterUpdate: Update router
func (c *Client) VpcRouterUpdate(ctx context.Context, params VpcRouterUpdateParams) (*VpcRouter, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpc-routers/{{.router}}"),
		map[string]string{
			"router": string(params.Router),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterDelete: Delete router
func (c *Client) VpcRouterDelete(ctx context.Context, params VpcRouterDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/vpc-routers/{{.router}}"),
		map[string]string{
			"router": string(params.Router),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// VpcSubnetList: List subnets
//
// To iterate over all pages, use the `VpcSubnetListAllPages` method, instead.
func (c *Client) VpcSubnetList(ctx context.Context, params VpcSubnetListParams) (*VpcSubnetResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-subnets"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnetResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetListAllPages: List subnets
//
// This method is a wrapper around the `VpcSubnetList` method.
// This method returns all the pages at once.
func (c *Client) VpcSubnetListAllPages(ctx context.Context, params VpcSubnetListParams) ([]VpcSubnet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []VpcSubnet
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.VpcSubnetList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcSubnetCreate: Create subnet
func (c *Client) VpcSubnetCreate(ctx context.Context, params VpcSubnetCreateParams) (*VpcSubnet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/vpc-subnets"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetView: Fetch subnet
func (c *Client) VpcSubnetView(ctx context.Context, params VpcSubnetViewParams) (*VpcSubnet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-subnets/{{.subnet}}"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetUpdate: Update subnet
func (c *Client) VpcSubnetUpdate(ctx context.Context, params VpcSubnetUpdateParams) (*VpcSubnet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpc-subnets/{{.subnet}}"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetDelete: Delete subnet
func (c *Client) VpcSubnetDelete(ctx context.Context, params VpcSubnetDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/vpc-subnets/{{.subnet}}"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// VpcSubnetListNetworkInterfaces: List network interfaces
//
// To iterate over all pages, use the `VpcSubnetListNetworkInterfacesAllPages` method, instead.
func (c *Client) VpcSubnetListNetworkInterfaces(ctx context.Context, params VpcSubnetListNetworkInterfacesParams) (*InstanceNetworkInterfaceResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-subnets/{{.subnet}}/network-interfaces"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterfaceResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetListNetworkInterfacesAllPages: List network interfaces
//
// This method is a wrapper around the `VpcSubnetListNetworkInterfaces` method.
// This method returns all the pages at once.
func (c *Client) VpcSubnetListNetworkInterfacesAllPages(ctx context.Context, params VpcSubnetListNetworkInterfacesParams) ([]InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InstanceNetworkInterface
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.VpcSubnetListNetworkInterfaces(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcList: List VPCs
//
// To iterate over all pages, use the `VpcListAllPages` method, instead.
func (c *Client) VpcList(ctx context.Context, params VpcListParams) (*VpcResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpcs"),
		map[string]string{},
		map[string]string{
			"limit":      PointerIntToStr(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcResultsPage
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcListAllPages: List VPCs
//
// This method is a wrapper around the `VpcList` method.
// This method returns all the pages at once.
func (c *Client) VpcListAllPages(ctx context.Context, params VpcListParams) ([]Vpc, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Vpc
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.VpcList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcCreate: Create VPC
func (c *Client) VpcCreate(ctx context.Context, params VpcCreateParams) (*Vpc, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/vpcs"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcView: Fetch VPC
func (c *Client) VpcView(ctx context.Context, params VpcViewParams) (*Vpc, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpcs/{{.vpc}}"),
		map[string]string{
			"vpc": string(params.Vpc),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcUpdate: Update a VPC
func (c *Client) VpcUpdate(ctx context.Context, params VpcUpdateParams) (*Vpc, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpcs/{{.vpc}}"),
		map[string]string{
			"vpc": string(params.Vpc),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcDelete: Delete VPC
func (c *Client) VpcDelete(ctx context.Context, params VpcDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/vpcs/{{.vpc}}"),
		map[string]string{
			"vpc": string(params.Vpc),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// WebhookReceiverCreate: Create webhook receiver
func (c *Client) WebhookReceiverCreate(ctx context.Context, params WebhookReceiverCreateParams) (*WebhookReceiver, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/webhook-receivers"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body WebhookReceiver
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// WebhookReceiverUpdate: Update webhook receiver
// Note that receiver secrets are NOT added or removed using this endpoint. Instead, use the `/v1/webhooks/{secrets}/?receiver={receiver}` endpoint
// to add and remove secrets.
func (c *Client) WebhookReceiverUpdate(ctx context.Context, params WebhookReceiverUpdateParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/webhook-receivers/{{.receiver}}"),
		map[string]string{
			"receiver": string(params.Receiver),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// WebhookSecretsList: List webhook receiver secret IDs
func (c *Client) WebhookSecretsList(ctx context.Context, params WebhookSecretsListParams) (*WebhookSecrets, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/webhook-secrets"),
		map[string]string{},
		map[string]string{
			"receiver": string(params.Receiver),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body WebhookSecrets
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// WebhookSecretsAdd: Add secret to webhook receiver
func (c *Client) WebhookSecretsAdd(ctx context.Context, params WebhookSecretsAddParams) (*WebhookSecret, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/webhook-secrets"),
		map[string]string{},
		map[string]string{
			"receiver": string(params.Receiver),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body WebhookSecret
	if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// WebhookSecretsDelete: Remove secret from webhook receiver
func (c *Client) WebhookSecretsDelete(ctx context.Context, params WebhookSecretsDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/webhook-secrets/{{.secret_id}}"),
		map[string]string{
			"secret_id": params.SecretId,
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}
