// Code generated by `generate`. DO NOT EDIT.

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package oxide

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"time"
)

// LoginSaml: Authenticate a user via SAML
func (c *Client) LoginSaml(ctx context.Context, params LoginSamlParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	b := params.Body

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/login/{{.silo_name}}/saml/{{.provider_name}}"),
		map[string]string{
			"provider_name": string(params.ProviderName),
			"silo_name":     string(params.SiloName),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// CertificateList: List certificates for external endpoints
// Returns a list of TLS certificates used for the external API (for the current Silo).  These are sorted by creation date, with the most recent certificates appearing first.
//
// To iterate over all pages, use the `CertificateListAllPages` method, instead.
func (c *Client) CertificateList(ctx context.Context, params CertificateListParams) (*CertificateResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/certificates"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body CertificateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateListAllPages: List certificates for external endpoints
// Returns a list of TLS certificates used for the external API (for the current Silo).  These are sorted by creation date, with the most recent certificates appearing first.
//
// This method is a wrapper around the `CertificateList` method.
// This method returns all the pages at once.
func (c *Client) CertificateListAllPages(ctx context.Context, params CertificateListParams) ([]Certificate, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Certificate
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.CertificateList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// CertificateCreate: Create new system-wide x.509 certificate
// This certificate is automatically used by the Oxide Control plane to serve external connections.
func (c *Client) CertificateCreate(ctx context.Context, params CertificateCreateParams) (*Certificate, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/certificates"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateView: Fetch certificate
// Returns the details of a specific certificate
func (c *Client) CertificateView(ctx context.Context, params CertificateViewParams) (*Certificate, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/certificates/{{.certificate}}"),
		map[string]string{
			"certificate": string(params.Certificate),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateDelete: Delete certificate
// Permanently delete a certificate. This operation cannot be undone.
func (c *Client) CertificateDelete(ctx context.Context, params CertificateDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/certificates/{{.certificate}}"),
		map[string]string{
			"certificate": string(params.Certificate),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskList: List disks
//
// To iterate over all pages, use the `DiskListAllPages` method, instead.
func (c *Client) DiskList(ctx context.Context, params DiskListParams) (*DiskResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/disks"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskListAllPages: List disks
//
// This method is a wrapper around the `DiskList` method.
// This method returns all the pages at once.
func (c *Client) DiskListAllPages(ctx context.Context, params DiskListParams) ([]Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Disk
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.DiskList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// DiskCreate: Create a disk
func (c *Client) DiskCreate(ctx context.Context, params DiskCreateParams) (*Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/disks"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskView: Fetch disk
func (c *Client) DiskView(ctx context.Context, params DiskViewParams) (*Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/disks/{{.disk}}"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskDelete: Delete disk
func (c *Client) DiskDelete(ctx context.Context, params DiskDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/disks/{{.disk}}"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskBulkWriteImport: Import blocks into disk
func (c *Client) DiskBulkWriteImport(ctx context.Context, params DiskBulkWriteImportParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/disks/{{.disk}}/bulk-write"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskBulkWriteImportStart: Start importing blocks into disk
// Start the process of importing blocks into a disk
func (c *Client) DiskBulkWriteImportStart(ctx context.Context, params DiskBulkWriteImportStartParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/disks/{{.disk}}/bulk-write-start"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskBulkWriteImportStop: Stop importing blocks into disk
// Stop the process of importing blocks into a disk
func (c *Client) DiskBulkWriteImportStop(ctx context.Context, params DiskBulkWriteImportStopParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/disks/{{.disk}}/bulk-write-stop"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskFinalizeImport: Confirm disk block import completion
func (c *Client) DiskFinalizeImport(ctx context.Context, params DiskFinalizeImportParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/disks/{{.disk}}/finalize"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// DiskMetricsList: Fetch disk metrics
//
// To iterate over all pages, use the `DiskMetricsListAllPages` method, instead.
func (c *Client) DiskMetricsList(ctx context.Context, params DiskMetricsListParams) (*MeasurementResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/disks/{{.disk}}/metrics/{{.metric}}"),
		map[string]string{
			"disk":   string(params.Disk),
			"metric": string(params.Metric),
		},
		map[string]string{
			"end_time":   params.EndTime.Format(time.RFC3339),
			"limit":      strconv.Itoa(params.Limit),
			"order":      string(params.Order),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"start_time": params.StartTime.Format(time.RFC3339),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body MeasurementResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskMetricsListAllPages: Fetch disk metrics
//
// This method is a wrapper around the `DiskMetricsList` method.
// This method returns all the pages at once.
func (c *Client) DiskMetricsListAllPages(ctx context.Context, params DiskMetricsListParams) ([]Measurement, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Measurement
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.DiskMetricsList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// FloatingIpList: List floating IPs
//
// To iterate over all pages, use the `FloatingIpListAllPages` method, instead.
func (c *Client) FloatingIpList(ctx context.Context, params FloatingIpListParams) (*FloatingIpResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/floating-ips"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIpResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpListAllPages: List floating IPs
//
// This method is a wrapper around the `FloatingIpList` method.
// This method returns all the pages at once.
func (c *Client) FloatingIpListAllPages(ctx context.Context, params FloatingIpListParams) ([]FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []FloatingIp
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.FloatingIpList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// FloatingIpCreate: Create floating IP
func (c *Client) FloatingIpCreate(ctx context.Context, params FloatingIpCreateParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/floating-ips"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpView: Fetch floating IP
func (c *Client) FloatingIpView(ctx context.Context, params FloatingIpViewParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpUpdate: Update floating IP
func (c *Client) FloatingIpUpdate(ctx context.Context, params FloatingIpUpdateParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpDelete: Delete floating IP
func (c *Client) FloatingIpDelete(ctx context.Context, params FloatingIpDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// FloatingIpAttach: Attach floating IP
// Attach floating IP to an instance or other resource.
func (c *Client) FloatingIpAttach(ctx context.Context, params FloatingIpAttachParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}/attach"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// FloatingIpDetach: Detach floating IP
func (c *Client) FloatingIpDetach(ctx context.Context, params FloatingIpDetachParams) (*FloatingIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/floating-ips/{{.floating_ip}}/detach"),
		map[string]string{
			"floating_ip": string(params.FloatingIp),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FloatingIp
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// GroupList: List groups
//
// To iterate over all pages, use the `GroupListAllPages` method, instead.
func (c *Client) GroupList(ctx context.Context, params GroupListParams) (*GroupResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/groups"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GroupResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// GroupListAllPages: List groups
//
// This method is a wrapper around the `GroupList` method.
// This method returns all the pages at once.
func (c *Client) GroupListAllPages(ctx context.Context, params GroupListParams) ([]Group, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Group
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.GroupList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// GroupView: Fetch group
func (c *Client) GroupView(ctx context.Context, params GroupViewParams) (*Group, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/groups/{{.group_id}}"),
		map[string]string{
			"group_id": params.GroupId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Group
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageList: List images
// List images which are global or scoped to the specified project. The images are returned sorted by creation date, with the most recent images appearing first.
//
// To iterate over all pages, use the `ImageListAllPages` method, instead.
func (c *Client) ImageList(ctx context.Context, params ImageListParams) (*ImageResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/images"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ImageResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageListAllPages: List images
// List images which are global or scoped to the specified project. The images are returned sorted by creation date, with the most recent images appearing first.
//
// This method is a wrapper around the `ImageList` method.
// This method returns all the pages at once.
func (c *Client) ImageListAllPages(ctx context.Context, params ImageListParams) ([]Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Image
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.ImageList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// ImageCreate: Create image
// Create a new image in a project.
func (c *Client) ImageCreate(ctx context.Context, params ImageCreateParams) (*Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/images"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageView: Fetch image
// Fetch the details for a specific image in a project.
func (c *Client) ImageView(ctx context.Context, params ImageViewParams) (*Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/images/{{.image}}"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageDelete: Delete image
// Permanently delete an image from a project. This operation cannot be undone. Any instances in the project using the image will continue to run, however new instances can not be created with this image.
func (c *Client) ImageDelete(ctx context.Context, params ImageDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/images/{{.image}}"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// ImageDemote: Demote silo image
// Demote silo image to be visible only to a specified project
func (c *Client) ImageDemote(ctx context.Context, params ImageDemoteParams) (*Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/images/{{.image}}/demote"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImagePromote: Promote project image
// Promote project image to be visible to all projects in the silo
func (c *Client) ImagePromote(ctx context.Context, params ImagePromoteParams) (*Image, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/images/{{.image}}/promote"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceList: List instances
//
// To iterate over all pages, use the `InstanceListAllPages` method, instead.
func (c *Client) InstanceList(ctx context.Context, params InstanceListParams) (*InstanceResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceListAllPages: List instances
//
// This method is a wrapper around the `InstanceList` method.
// This method returns all the pages at once.
func (c *Client) InstanceListAllPages(ctx context.Context, params InstanceListParams) ([]Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Instance
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InstanceList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceCreate: Create instance
func (c *Client) InstanceCreate(ctx context.Context, params InstanceCreateParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/instances"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceView: Fetch instance
func (c *Client) InstanceView(ctx context.Context, params InstanceViewParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceUpdate: Update instance
func (c *Client) InstanceUpdate(ctx context.Context, params InstanceUpdateParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/instances/{{.instance}}"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDelete: Delete instance
func (c *Client) InstanceDelete(ctx context.Context, params InstanceDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/instances/{{.instance}}"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InstanceDiskList: List disks for instance
//
// To iterate over all pages, use the `InstanceDiskListAllPages` method, instead.
func (c *Client) InstanceDiskList(ctx context.Context, params InstanceDiskListParams) (*DiskResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/disks"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskListAllPages: List disks for instance
//
// This method is a wrapper around the `InstanceDiskList` method.
// This method returns all the pages at once.
func (c *Client) InstanceDiskListAllPages(ctx context.Context, params InstanceDiskListParams) ([]Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Disk
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InstanceDiskList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceDiskAttach: Attach disk to instance
func (c *Client) InstanceDiskAttach(ctx context.Context, params InstanceDiskAttachParams) (*Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/disks/attach"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskDetach: Detach disk from instance
func (c *Client) InstanceDiskDetach(ctx context.Context, params InstanceDiskDetachParams) (*Disk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/disks/detach"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceExternalIpList: List external IP addresses
func (c *Client) InstanceExternalIpList(ctx context.Context, params InstanceExternalIpListParams) (*ExternalIpResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/external-ips"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ExternalIpResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceEphemeralIpAttach: Allocate and attach ephemeral IP to instance
func (c *Client) InstanceEphemeralIpAttach(ctx context.Context, params InstanceEphemeralIpAttachParams) (*ExternalIp, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/external-ips/ephemeral"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ExternalIp
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceEphemeralIpDetach: Detach and deallocate ephemeral IP from instance
func (c *Client) InstanceEphemeralIpDetach(ctx context.Context, params InstanceEphemeralIpDetachParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/external-ips/ephemeral"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InstanceReboot: Reboot an instance
func (c *Client) InstanceReboot(ctx context.Context, params InstanceRebootParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/reboot"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsole: Fetch instance serial console
func (c *Client) InstanceSerialConsole(ctx context.Context, params InstanceSerialConsoleParams) (*InstanceSerialConsoleData, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/serial-console"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"from_start":  strconv.Itoa(params.FromStart),
			"max_bytes":   strconv.Itoa(params.MaxBytes),
			"most_recent": strconv.Itoa(params.MostRecent),
			"project":     string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceSerialConsoleData
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsoleStream: Stream instance serial console
func (c *Client) InstanceSerialConsoleStream(ctx context.Context, params InstanceSerialConsoleStreamParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/serial-console/stream"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"most_recent": strconv.Itoa(params.MostRecent),
			"project":     string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InstanceSshPublicKeyList: List SSH public keys for instance
// List SSH public keys injected via cloud-init during instance creation. Note that this list is a snapshot in time and will not reflect updates made after the instance is created.
//
// To iterate over all pages, use the `InstanceSshPublicKeyListAllPages` method, instead.
func (c *Client) InstanceSshPublicKeyList(ctx context.Context, params InstanceSshPublicKeyListParams) (*SshKeyResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/ssh-public-keys"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKeyResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSshPublicKeyListAllPages: List SSH public keys for instance
// List SSH public keys injected via cloud-init during instance creation. Note that this list is a snapshot in time and will not reflect updates made after the instance is created.
//
// This method is a wrapper around the `InstanceSshPublicKeyList` method.
// This method returns all the pages at once.
func (c *Client) InstanceSshPublicKeyListAllPages(ctx context.Context, params InstanceSshPublicKeyListParams) ([]SshKey, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SshKey
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InstanceSshPublicKeyList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceStart: Boot instance
func (c *Client) InstanceStart(ctx context.Context, params InstanceStartParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/start"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceStop: Stop instance
func (c *Client) InstanceStop(ctx context.Context, params InstanceStopParams) (*Instance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"POST",
		resolveRelative(c.host, "/v1/instances/{{.instance}}/stop"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpAddressList: List IP addresses attached to internet gateway
//
// To iterate over all pages, use the `InternetGatewayIpAddressListAllPages` method, instead.
func (c *Client) InternetGatewayIpAddressList(ctx context.Context, params InternetGatewayIpAddressListParams) (*InternetGatewayIpAddressResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/internet-gateway-ip-addresses"),
		map[string]string{},
		map[string]string{
			"gateway":    string(params.Gateway),
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayIpAddressResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpAddressListAllPages: List IP addresses attached to internet gateway
//
// This method is a wrapper around the `InternetGatewayIpAddressList` method.
// This method returns all the pages at once.
func (c *Client) InternetGatewayIpAddressListAllPages(ctx context.Context, params InternetGatewayIpAddressListParams) ([]InternetGatewayIpAddress, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InternetGatewayIpAddress
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InternetGatewayIpAddressList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InternetGatewayIpAddressCreate: Attach IP address to internet gateway
func (c *Client) InternetGatewayIpAddressCreate(ctx context.Context, params InternetGatewayIpAddressCreateParams) (*InternetGatewayIpAddress, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/internet-gateway-ip-addresses"),
		map[string]string{},
		map[string]string{
			"gateway": string(params.Gateway),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayIpAddress
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpAddressDelete: Detach IP address from internet gateway
func (c *Client) InternetGatewayIpAddressDelete(ctx context.Context, params InternetGatewayIpAddressDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/internet-gateway-ip-addresses/{{.address}}"),
		map[string]string{
			"address": string(params.Address),
		},
		map[string]string{
			"cascade": strconv.FormatBool(*params.Cascade),
			"gateway": string(params.Gateway),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InternetGatewayIpPoolList: List IP pools attached to internet gateway
//
// To iterate over all pages, use the `InternetGatewayIpPoolListAllPages` method, instead.
func (c *Client) InternetGatewayIpPoolList(ctx context.Context, params InternetGatewayIpPoolListParams) (*InternetGatewayIpPoolResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/internet-gateway-ip-pools"),
		map[string]string{},
		map[string]string{
			"gateway":    string(params.Gateway),
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayIpPoolResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpPoolListAllPages: List IP pools attached to internet gateway
//
// This method is a wrapper around the `InternetGatewayIpPoolList` method.
// This method returns all the pages at once.
func (c *Client) InternetGatewayIpPoolListAllPages(ctx context.Context, params InternetGatewayIpPoolListParams) ([]InternetGatewayIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InternetGatewayIpPool
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InternetGatewayIpPoolList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InternetGatewayIpPoolCreate: Attach IP pool to internet gateway
func (c *Client) InternetGatewayIpPoolCreate(ctx context.Context, params InternetGatewayIpPoolCreateParams) (*InternetGatewayIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/internet-gateway-ip-pools"),
		map[string]string{},
		map[string]string{
			"gateway": string(params.Gateway),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayIpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayIpPoolDelete: Detach IP pool from internet gateway
func (c *Client) InternetGatewayIpPoolDelete(ctx context.Context, params InternetGatewayIpPoolDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/internet-gateway-ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{
			"cascade": strconv.FormatBool(*params.Cascade),
			"gateway": string(params.Gateway),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// InternetGatewayList: List internet gateways
//
// To iterate over all pages, use the `InternetGatewayListAllPages` method, instead.
func (c *Client) InternetGatewayList(ctx context.Context, params InternetGatewayListParams) (*InternetGatewayResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/internet-gateways"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGatewayResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayListAllPages: List internet gateways
//
// This method is a wrapper around the `InternetGatewayList` method.
// This method returns all the pages at once.
func (c *Client) InternetGatewayListAllPages(ctx context.Context, params InternetGatewayListParams) ([]InternetGateway, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InternetGateway
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InternetGatewayList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InternetGatewayCreate: Create VPC internet gateway
func (c *Client) InternetGatewayCreate(ctx context.Context, params InternetGatewayCreateParams) (*InternetGateway, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/internet-gateways"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGateway
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayView: Fetch internet gateway
func (c *Client) InternetGatewayView(ctx context.Context, params InternetGatewayViewParams) (*InternetGateway, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/internet-gateways/{{.gateway}}"),
		map[string]string{
			"gateway": string(params.Gateway),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InternetGateway
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InternetGatewayDelete: Delete internet gateway
func (c *Client) InternetGatewayDelete(ctx context.Context, params InternetGatewayDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/internet-gateways/{{.gateway}}"),
		map[string]string{
			"gateway": string(params.Gateway),
		},
		map[string]string{
			"cascade": strconv.FormatBool(*params.Cascade),
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// ProjectIpPoolList: List IP pools
//
// To iterate over all pages, use the `ProjectIpPoolListAllPages` method, instead.
func (c *Client) ProjectIpPoolList(ctx context.Context, params ProjectIpPoolListParams) (*SiloIpPoolResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/ip-pools"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloIpPoolResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectIpPoolListAllPages: List IP pools
//
// This method is a wrapper around the `ProjectIpPoolList` method.
// This method returns all the pages at once.
func (c *Client) ProjectIpPoolListAllPages(ctx context.Context, params ProjectIpPoolListParams) ([]SiloIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SiloIpPool
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.ProjectIpPoolList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// ProjectIpPoolView: Fetch IP pool
func (c *Client) ProjectIpPoolView(ctx context.Context, params ProjectIpPoolViewParams) (*SiloIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloIpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// LoginLocal: Authenticate a user via username and password
func (c *Client) LoginLocal(ctx context.Context, params LoginLocalParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/login/{{.silo_name}}/local"),
		map[string]string{
			"silo_name": string(params.SiloName),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// CurrentUserView: Fetch user for current session
func (c *Client) CurrentUserView(ctx context.Context) (*CurrentUser, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/me"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body CurrentUser
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserGroups: Fetch current user's groups
//
// To iterate over all pages, use the `CurrentUserGroupsAllPages` method, instead.
func (c *Client) CurrentUserGroups(ctx context.Context, params CurrentUserGroupsParams) (*GroupResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/me/groups"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GroupResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserGroupsAllPages: Fetch current user's groups
//
// This method is a wrapper around the `CurrentUserGroups` method.
// This method returns all the pages at once.
func (c *Client) CurrentUserGroupsAllPages(ctx context.Context, params CurrentUserGroupsParams) ([]Group, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Group
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.CurrentUserGroups(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// CurrentUserSshKeyList: List SSH public keys
// Lists SSH public keys for the currently authenticated user.
//
// To iterate over all pages, use the `CurrentUserSshKeyListAllPages` method, instead.
func (c *Client) CurrentUserSshKeyList(ctx context.Context, params CurrentUserSshKeyListParams) (*SshKeyResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/me/ssh-keys"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKeyResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserSshKeyListAllPages: List SSH public keys
// Lists SSH public keys for the currently authenticated user.
//
// This method is a wrapper around the `CurrentUserSshKeyList` method.
// This method returns all the pages at once.
func (c *Client) CurrentUserSshKeyListAllPages(ctx context.Context, params CurrentUserSshKeyListParams) ([]SshKey, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SshKey
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.CurrentUserSshKeyList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// CurrentUserSshKeyCreate: Create SSH public key
// Create an SSH public key for the currently authenticated user.
func (c *Client) CurrentUserSshKeyCreate(ctx context.Context, params CurrentUserSshKeyCreateParams) (*SshKey, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/me/ssh-keys"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKey
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserSshKeyView: Fetch SSH public key
// Fetch SSH public key associated with the currently authenticated user.
func (c *Client) CurrentUserSshKeyView(ctx context.Context, params CurrentUserSshKeyViewParams) (*SshKey, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/me/ssh-keys/{{.ssh_key}}"),
		map[string]string{
			"ssh_key": string(params.SshKey),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKey
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserSshKeyDelete: Delete SSH public key
// Delete an SSH public key associated with the currently authenticated user.
func (c *Client) CurrentUserSshKeyDelete(ctx context.Context, params CurrentUserSshKeyDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/me/ssh-keys/{{.ssh_key}}"),
		map[string]string{
			"ssh_key": string(params.SshKey),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// SiloMetric: View metrics
// View CPU, memory, or storage utilization metrics at the silo or project level.
//
// To iterate over all pages, use the `SiloMetricAllPages` method, instead.
func (c *Client) SiloMetric(ctx context.Context, params SiloMetricParams) (*MeasurementResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/metrics/{{.metric_name}}"),
		map[string]string{
			"metric_name": string(params.MetricName),
		},
		map[string]string{
			"end_time":   params.EndTime.Format(time.RFC3339),
			"limit":      strconv.Itoa(params.Limit),
			"order":      string(params.Order),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"start_time": params.StartTime.Format(time.RFC3339),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body MeasurementResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloMetricAllPages: View metrics
// View CPU, memory, or storage utilization metrics at the silo or project level.
//
// This method is a wrapper around the `SiloMetric` method.
// This method returns all the pages at once.
func (c *Client) SiloMetricAllPages(ctx context.Context, params SiloMetricParams) ([]Measurement, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Measurement
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SiloMetric(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceNetworkInterfaceList: List network interfaces
//
// To iterate over all pages, use the `InstanceNetworkInterfaceListAllPages` method, instead.
func (c *Client) InstanceNetworkInterfaceList(ctx context.Context, params InstanceNetworkInterfaceListParams) (*InstanceNetworkInterfaceResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/network-interfaces"),
		map[string]string{},
		map[string]string{
			"instance":   string(params.Instance),
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceListAllPages: List network interfaces
//
// This method is a wrapper around the `InstanceNetworkInterfaceList` method.
// This method returns all the pages at once.
func (c *Client) InstanceNetworkInterfaceListAllPages(ctx context.Context, params InstanceNetworkInterfaceListParams) ([]InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InstanceNetworkInterface
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InstanceNetworkInterfaceList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// InstanceNetworkInterfaceCreate: Create network interface
func (c *Client) InstanceNetworkInterfaceCreate(ctx context.Context, params InstanceNetworkInterfaceCreateParams) (*InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/network-interfaces"),
		map[string]string{},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceView: Fetch network interface
func (c *Client) InstanceNetworkInterfaceView(ctx context.Context, params InstanceNetworkInterfaceViewParams) (*InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/network-interfaces/{{.interface}}"),
		map[string]string{
			"interface": string(params.Interface),
		},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceUpdate: Update network interface
func (c *Client) InstanceNetworkInterfaceUpdate(ctx context.Context, params InstanceNetworkInterfaceUpdateParams) (*InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/network-interfaces/{{.interface}}"),
		map[string]string{
			"interface": string(params.Interface),
		},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceDelete: Delete network interface
// Note that the primary interface for an instance cannot be deleted if there are any secondary interfaces. A new primary interface must be designated first. The primary interface can be deleted if there are no secondary interfaces.
func (c *Client) InstanceNetworkInterfaceDelete(ctx context.Context, params InstanceNetworkInterfaceDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/network-interfaces/{{.interface}}"),
		map[string]string{
			"interface": string(params.Interface),
		},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// Ping: Ping API
// Always responds with Ok if it responds at all.
func (c *Client) Ping(ctx context.Context) (*Ping, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/ping"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Ping
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PolicyView: Fetch current silo's IAM policy
func (c *Client) PolicyView(ctx context.Context) (*SiloRolePolicy, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PolicyUpdate: Update current silo's IAM policy
func (c *Client) PolicyUpdate(ctx context.Context, params PolicyUpdateParams) (*SiloRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectList: List projects
//
// To iterate over all pages, use the `ProjectListAllPages` method, instead.
func (c *Client) ProjectList(ctx context.Context, params ProjectListParams) (*ProjectResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/projects"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectListAllPages: List projects
//
// This method is a wrapper around the `ProjectList` method.
// This method returns all the pages at once.
func (c *Client) ProjectListAllPages(ctx context.Context, params ProjectListParams) ([]Project, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Project
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.ProjectList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// ProjectCreate: Create project
func (c *Client) ProjectCreate(ctx context.Context, params ProjectCreateParams) (*Project, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/projects"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectView: Fetch project
func (c *Client) ProjectView(ctx context.Context, params ProjectViewParams) (*Project, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/projects/{{.project}}"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectUpdate: Update a project
func (c *Client) ProjectUpdate(ctx context.Context, params ProjectUpdateParams) (*Project, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/projects/{{.project}}"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectDelete: Delete project
func (c *Client) ProjectDelete(ctx context.Context, params ProjectDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/projects/{{.project}}"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// ProjectPolicyView: Fetch project's IAM policy
func (c *Client) ProjectPolicyView(ctx context.Context, params ProjectPolicyViewParams) (*ProjectRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/projects/{{.project}}/policy"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectPolicyUpdate: Update project's IAM policy
func (c *Client) ProjectPolicyUpdate(ctx context.Context, params ProjectPolicyUpdateParams) (*ProjectRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/projects/{{.project}}/policy"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotList: List snapshots
//
// To iterate over all pages, use the `SnapshotListAllPages` method, instead.
func (c *Client) SnapshotList(ctx context.Context, params SnapshotListParams) (*SnapshotResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/snapshots"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SnapshotResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotListAllPages: List snapshots
//
// This method is a wrapper around the `SnapshotList` method.
// This method returns all the pages at once.
func (c *Client) SnapshotListAllPages(ctx context.Context, params SnapshotListParams) ([]Snapshot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Snapshot
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SnapshotList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SnapshotCreate: Create snapshot
// Creates a point-in-time snapshot from a disk.
func (c *Client) SnapshotCreate(ctx context.Context, params SnapshotCreateParams) (*Snapshot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/snapshots"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotView: Fetch snapshot
func (c *Client) SnapshotView(ctx context.Context, params SnapshotViewParams) (*Snapshot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/snapshots/{{.snapshot}}"),
		map[string]string{
			"snapshot": string(params.Snapshot),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotDelete: Delete snapshot
func (c *Client) SnapshotDelete(ctx context.Context, params SnapshotDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/snapshots/{{.snapshot}}"),
		map[string]string{
			"snapshot": string(params.Snapshot),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// PhysicalDiskList: List physical disks
//
// To iterate over all pages, use the `PhysicalDiskListAllPages` method, instead.
func (c *Client) PhysicalDiskList(ctx context.Context, params PhysicalDiskListParams) (*PhysicalDiskResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/disks"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PhysicalDiskListAllPages: List physical disks
//
// This method is a wrapper around the `PhysicalDiskList` method.
// This method returns all the pages at once.
func (c *Client) PhysicalDiskListAllPages(ctx context.Context, params PhysicalDiskListParams) ([]PhysicalDisk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []PhysicalDisk
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.PhysicalDiskList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// PhysicalDiskView: Get a physical disk
func (c *Client) PhysicalDiskView(ctx context.Context, params PhysicalDiskViewParams) (*PhysicalDisk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/disks/{{.disk_id}}"),
		map[string]string{
			"disk_id": params.DiskId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDisk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RackList: List racks
//
// To iterate over all pages, use the `RackListAllPages` method, instead.
func (c *Client) RackList(ctx context.Context, params RackListParams) (*RackResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/racks"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RackResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RackListAllPages: List racks
//
// This method is a wrapper around the `RackList` method.
// This method returns all the pages at once.
func (c *Client) RackListAllPages(ctx context.Context, params RackListParams) ([]Rack, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Rack
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.RackList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// RackView: Fetch rack
func (c *Client) RackView(ctx context.Context, params RackViewParams) (*Rack, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/racks/{{.rack_id}}"),
		map[string]string{
			"rack_id": params.RackId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Rack
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledList: List sleds
//
// To iterate over all pages, use the `SledListAllPages` method, instead.
func (c *Client) SledList(ctx context.Context, params SledListParams) (*SledResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListAllPages: List sleds
//
// This method is a wrapper around the `SledList` method.
// This method returns all the pages at once.
func (c *Client) SledListAllPages(ctx context.Context, params SledListParams) ([]Sled, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Sled
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SledList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SledAdd: Add sled to initialized rack
func (c *Client) SledAdd(ctx context.Context, params SledAddParams) (*SledId, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/hardware/sleds"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledId
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListUninitialized: List uninitialized sleds
//
// To iterate over all pages, use the `SledListUninitializedAllPages` method, instead.
func (c *Client) SledListUninitialized(ctx context.Context, params SledListUninitializedParams) (*UninitializedSledResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds-uninitialized"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UninitializedSledResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListUninitializedAllPages: List uninitialized sleds
//
// This method is a wrapper around the `SledListUninitialized` method.
// This method returns all the pages at once.
func (c *Client) SledListUninitializedAllPages(ctx context.Context, params SledListUninitializedParams) ([]UninitializedSled, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []UninitializedSled
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SledListUninitialized(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SledView: Fetch sled
func (c *Client) SledView(ctx context.Context, params SledViewParams) (*Sled, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds/{{.sled_id}}"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Sled
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskList: List physical disks attached to sleds
//
// To iterate over all pages, use the `SledPhysicalDiskListAllPages` method, instead.
func (c *Client) SledPhysicalDiskList(ctx context.Context, params SledPhysicalDiskListParams) (*PhysicalDiskResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds/{{.sled_id}}/disks"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskListAllPages: List physical disks attached to sleds
//
// This method is a wrapper around the `SledPhysicalDiskList` method.
// This method returns all the pages at once.
func (c *Client) SledPhysicalDiskListAllPages(ctx context.Context, params SledPhysicalDiskListParams) ([]PhysicalDisk, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []PhysicalDisk
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SledPhysicalDiskList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SledInstanceList: List instances running on given sled
//
// To iterate over all pages, use the `SledInstanceListAllPages` method, instead.
func (c *Client) SledInstanceList(ctx context.Context, params SledInstanceListParams) (*SledInstanceResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/sleds/{{.sled_id}}/instances"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledInstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledInstanceListAllPages: List instances running on given sled
//
// This method is a wrapper around the `SledInstanceList` method.
// This method returns all the pages at once.
func (c *Client) SledInstanceListAllPages(ctx context.Context, params SledInstanceListParams) ([]SledInstance, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SledInstance
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SledInstanceList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SledSetProvisionPolicy: Set sled provision policy
func (c *Client) SledSetProvisionPolicy(ctx context.Context, params SledSetProvisionPolicyParams) (*SledProvisionPolicyResponse, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/hardware/sleds/{{.sled_id}}/provision-policy"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledProvisionPolicyResponse
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortList: List switch ports
//
// To iterate over all pages, use the `NetworkingSwitchPortListAllPages` method, instead.
func (c *Client) NetworkingSwitchPortList(ctx context.Context, params NetworkingSwitchPortListParams) (*SwitchPortResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/switch-port"),
		map[string]string{},
		map[string]string{
			"limit":          strconv.Itoa(params.Limit),
			"page_token":     params.PageToken,
			"sort_by":        string(params.SortBy),
			"switch_port_id": params.SwitchPortId,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchPortResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortListAllPages: List switch ports
//
// This method is a wrapper around the `NetworkingSwitchPortList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingSwitchPortListAllPages(ctx context.Context, params NetworkingSwitchPortListParams) ([]SwitchPort, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SwitchPort
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.NetworkingSwitchPortList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingSwitchPortApplySettings: Apply switch port settings
func (c *Client) NetworkingSwitchPortApplySettings(ctx context.Context, params NetworkingSwitchPortApplySettingsParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/hardware/switch-port/{{.port}}/settings"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{
			"rack_id":         params.RackId,
			"switch_location": string(params.SwitchLocation),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingSwitchPortClearSettings: Clear switch port settings
func (c *Client) NetworkingSwitchPortClearSettings(ctx context.Context, params NetworkingSwitchPortClearSettingsParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/hardware/switch-port/{{.port}}/settings"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{
			"rack_id":         params.RackId,
			"switch_location": string(params.SwitchLocation),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingSwitchPortStatus: Get switch port status
func (c *Client) NetworkingSwitchPortStatus(ctx context.Context, params NetworkingSwitchPortStatusParams) (*SwitchLinkState, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/switch-port/{{.port}}/status"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{
			"rack_id":         params.RackId,
			"switch_location": string(params.SwitchLocation),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchLinkState
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SwitchList: List switches
//
// To iterate over all pages, use the `SwitchListAllPages` method, instead.
func (c *Client) SwitchList(ctx context.Context, params SwitchListParams) (*SwitchResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/switches"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SwitchListAllPages: List switches
//
// This method is a wrapper around the `SwitchList` method.
// This method returns all the pages at once.
func (c *Client) SwitchListAllPages(ctx context.Context, params SwitchListParams) ([]Switch, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Switch
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SwitchList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SwitchView: Fetch switch
func (c *Client) SwitchView(ctx context.Context, params SwitchViewParams) (*Switch, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/hardware/switches/{{.switch_id}}"),
		map[string]string{
			"switch_id": params.SwitchId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Switch
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloIdentityProviderList: List a silo's IdP's name
//
// To iterate over all pages, use the `SiloIdentityProviderListAllPages` method, instead.
func (c *Client) SiloIdentityProviderList(ctx context.Context, params SiloIdentityProviderListParams) (*IdentityProviderResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/identity-providers"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"silo":       string(params.Silo),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IdentityProviderResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloIdentityProviderListAllPages: List a silo's IdP's name
//
// This method is a wrapper around the `SiloIdentityProviderList` method.
// This method returns all the pages at once.
func (c *Client) SiloIdentityProviderListAllPages(ctx context.Context, params SiloIdentityProviderListParams) ([]IdentityProvider, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IdentityProvider
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SiloIdentityProviderList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// LocalIdpUserCreate: Create user
// Users can only be created in Silos with `provision_type` == `Fixed`. Otherwise, Silo users are just-in-time (JIT) provisioned when a user first logs in using an external Identity Provider.
func (c *Client) LocalIdpUserCreate(ctx context.Context, params LocalIdpUserCreateParams) (*User, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/identity-providers/local/users"),
		map[string]string{},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// LocalIdpUserDelete: Delete user
func (c *Client) LocalIdpUserDelete(ctx context.Context, params LocalIdpUserDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/identity-providers/local/users/{{.user_id}}"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// LocalIdpUserSetPassword: Set or invalidate user's password
// Passwords can only be updated for users in Silos with identity mode `LocalOnly`.
func (c *Client) LocalIdpUserSetPassword(ctx context.Context, params LocalIdpUserSetPasswordParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/identity-providers/local/users/{{.user_id}}/set-password"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// SamlIdentityProviderCreate: Create SAML IdP
func (c *Client) SamlIdentityProviderCreate(ctx context.Context, params SamlIdentityProviderCreateParams) (*SamlIdentityProvider, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/identity-providers/saml"),
		map[string]string{},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SamlIdentityProvider
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SamlIdentityProviderView: Fetch SAML IdP
func (c *Client) SamlIdentityProviderView(ctx context.Context, params SamlIdentityProviderViewParams) (*SamlIdentityProvider, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/identity-providers/saml/{{.provider}}"),
		map[string]string{
			"provider": string(params.Provider),
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SamlIdentityProvider
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolList: List IP pools
//
// To iterate over all pages, use the `IpPoolListAllPages` method, instead.
func (c *Client) IpPoolList(ctx context.Context, params IpPoolListParams) (*IpPoolResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolListAllPages: List IP pools
//
// This method is a wrapper around the `IpPoolList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolListAllPages(ctx context.Context, params IpPoolListParams) ([]IpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IpPool
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.IpPoolList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// IpPoolCreate: Create IP pool
func (c *Client) IpPoolCreate(ctx context.Context, params IpPoolCreateParams) (*IpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceView: Fetch Oxide service IP pool
func (c *Client) IpPoolServiceView(ctx context.Context) (*IpPool, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools-service"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeList: List IP ranges for the Oxide service pool
// Ranges are ordered by their first address.
//
// To iterate over all pages, use the `IpPoolServiceRangeListAllPages` method, instead.
func (c *Client) IpPoolServiceRangeList(ctx context.Context, params IpPoolServiceRangeListParams) (*IpPoolRangeResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools-service/ranges"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRangeResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeListAllPages: List IP ranges for the Oxide service pool
// Ranges are ordered by their first address.
//
// This method is a wrapper around the `IpPoolServiceRangeList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolServiceRangeListAllPages(ctx context.Context, params IpPoolServiceRangeListParams) ([]IpPoolRange, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IpPoolRange
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.IpPoolServiceRangeList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// IpPoolServiceRangeAdd: Add IP range to Oxide service pool
// IPv6 ranges are not allowed yet.
func (c *Client) IpPoolServiceRangeAdd(ctx context.Context, params IpPoolServiceRangeAddParams) (*IpPoolRange, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools-service/ranges/add"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRange
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeRemove: Remove IP range from Oxide service pool
func (c *Client) IpPoolServiceRangeRemove(ctx context.Context, params IpPoolServiceRangeRemoveParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools-service/ranges/remove"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolView: Fetch IP pool
func (c *Client) IpPoolView(ctx context.Context, params IpPoolViewParams) (*IpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolUpdate: Update IP pool
func (c *Client) IpPoolUpdate(ctx context.Context, params IpPoolUpdateParams) (*IpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolDelete: Delete IP pool
func (c *Client) IpPoolDelete(ctx context.Context, params IpPoolDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolRangeList: List ranges for IP pool
// Ranges are ordered by their first address.
//
// To iterate over all pages, use the `IpPoolRangeListAllPages` method, instead.
func (c *Client) IpPoolRangeList(ctx context.Context, params IpPoolRangeListParams) (*IpPoolRangeResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/ranges"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRangeResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolRangeListAllPages: List ranges for IP pool
// Ranges are ordered by their first address.
//
// This method is a wrapper around the `IpPoolRangeList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolRangeListAllPages(ctx context.Context, params IpPoolRangeListParams) ([]IpPoolRange, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IpPoolRange
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.IpPoolRangeList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// IpPoolRangeAdd: Add range to IP pool
// IPv6 ranges are not allowed yet.
func (c *Client) IpPoolRangeAdd(ctx context.Context, params IpPoolRangeAddParams) (*IpPoolRange, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/ranges/add"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRange
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolRangeRemove: Remove range from IP pool
func (c *Client) IpPoolRangeRemove(ctx context.Context, params IpPoolRangeRemoveParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/ranges/remove"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolSiloList: List IP pool's linked silos
//
// To iterate over all pages, use the `IpPoolSiloListAllPages` method, instead.
func (c *Client) IpPoolSiloList(ctx context.Context, params IpPoolSiloListParams) (*IpPoolSiloLinkResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/silos"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolSiloLinkResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolSiloListAllPages: List IP pool's linked silos
//
// This method is a wrapper around the `IpPoolSiloList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolSiloListAllPages(ctx context.Context, params IpPoolSiloListParams) ([]IpPoolSiloLink, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IpPoolSiloLink
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.IpPoolSiloList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// IpPoolSiloLink: Link IP pool to silo
// Users in linked silos can allocate external IPs from this pool for their instances. A silo can have at most one default pool. IPs are allocated from the default pool when users ask for one without specifying a pool.
func (c *Client) IpPoolSiloLink(ctx context.Context, params IpPoolSiloLinkParams) (*IpPoolSiloLink, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/silos"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolSiloLink
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolSiloUpdate: Make IP pool default for silo
// When a user asks for an IP (e.g., at instance create time) without specifying a pool, the IP comes from the default pool if a default is configured. When a pool is made the default for a silo, any existing default will remain linked to the silo, but will no longer be the default.
func (c *Client) IpPoolSiloUpdate(ctx context.Context, params IpPoolSiloUpdateParams) (*IpPoolSiloLink, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/silos/{{.silo}}"),
		map[string]string{
			"pool": string(params.Pool),
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolSiloLink
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolSiloUnlink: Unlink IP pool from silo
// Will fail if there are any outstanding IPs allocated in the silo.
func (c *Client) IpPoolSiloUnlink(ctx context.Context, params IpPoolSiloUnlinkParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/silos/{{.silo}}"),
		map[string]string{
			"pool": string(params.Pool),
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolUtilizationView: Fetch IP pool utilization
func (c *Client) IpPoolUtilizationView(ctx context.Context, params IpPoolUtilizationViewParams) (*IpPoolUtilization, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}/utilization"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolUtilization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemMetric: View metrics
// View CPU, memory, or storage utilization metrics at the fleet or silo level.
//
// To iterate over all pages, use the `SystemMetricAllPages` method, instead.
func (c *Client) SystemMetric(ctx context.Context, params SystemMetricParams) (*MeasurementResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/metrics/{{.metric_name}}"),
		map[string]string{
			"metric_name": string(params.MetricName),
		},
		map[string]string{
			"end_time":   params.EndTime.Format(time.RFC3339),
			"limit":      strconv.Itoa(params.Limit),
			"order":      string(params.Order),
			"page_token": params.PageToken,
			"silo":       string(params.Silo),
			"start_time": params.StartTime.Format(time.RFC3339),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body MeasurementResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemMetricAllPages: View metrics
// View CPU, memory, or storage utilization metrics at the fleet or silo level.
//
// This method is a wrapper around the `SystemMetric` method.
// This method returns all the pages at once.
func (c *Client) SystemMetricAllPages(ctx context.Context, params SystemMetricParams) ([]Measurement, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Measurement
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SystemMetric(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingAddressLotList: List address lots
//
// To iterate over all pages, use the `NetworkingAddressLotListAllPages` method, instead.
func (c *Client) NetworkingAddressLotList(ctx context.Context, params NetworkingAddressLotListParams) (*AddressLotResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/address-lot"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AddressLotResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingAddressLotListAllPages: List address lots
//
// This method is a wrapper around the `NetworkingAddressLotList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingAddressLotListAllPages(ctx context.Context, params NetworkingAddressLotListParams) ([]AddressLot, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AddressLot
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.NetworkingAddressLotList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingAddressLotCreate: Create address lot
func (c *Client) NetworkingAddressLotCreate(ctx context.Context, params NetworkingAddressLotCreateParams) (*AddressLotCreateResponse, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/address-lot"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AddressLotCreateResponse
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingAddressLotDelete: Delete address lot
func (c *Client) NetworkingAddressLotDelete(ctx context.Context, params NetworkingAddressLotDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/address-lot/{{.address_lot}}"),
		map[string]string{
			"address_lot": string(params.AddressLot),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingAddressLotBlockList: List blocks in address lot
//
// To iterate over all pages, use the `NetworkingAddressLotBlockListAllPages` method, instead.
func (c *Client) NetworkingAddressLotBlockList(ctx context.Context, params NetworkingAddressLotBlockListParams) (*AddressLotBlockResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/address-lot/{{.address_lot}}/blocks"),
		map[string]string{
			"address_lot": string(params.AddressLot),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AddressLotBlockResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingAddressLotBlockListAllPages: List blocks in address lot
//
// This method is a wrapper around the `NetworkingAddressLotBlockList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingAddressLotBlockListAllPages(ctx context.Context, params NetworkingAddressLotBlockListParams) ([]AddressLotBlock, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []AddressLotBlock
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.NetworkingAddressLotBlockList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingAllowListView: Get user-facing services IP allowlist
func (c *Client) NetworkingAllowListView(ctx context.Context) (*AllowList, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/allow-list"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AllowList
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingAllowListUpdate: Update user-facing services IP allowlist
func (c *Client) NetworkingAllowListUpdate(ctx context.Context, params NetworkingAllowListUpdateParams) (*AllowList, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/networking/allow-list"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AllowList
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBfdDisable: Disable a BFD session
func (c *Client) NetworkingBfdDisable(ctx context.Context, params NetworkingBfdDisableParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/bfd-disable"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingBfdEnable: Enable a BFD session
func (c *Client) NetworkingBfdEnable(ctx context.Context, params NetworkingBfdEnableParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/bfd-enable"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingBfdStatus: Get BFD status
func (c *Client) NetworkingBfdStatus(ctx context.Context) (*[]BfdStatus, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bfd-status"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BfdStatus
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpConfigList: List BGP configurations
//
// To iterate over all pages, use the `NetworkingBgpConfigListAllPages` method, instead.
func (c *Client) NetworkingBgpConfigList(ctx context.Context, params NetworkingBgpConfigListParams) (*BgpConfigResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body BgpConfigResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpConfigListAllPages: List BGP configurations
//
// This method is a wrapper around the `NetworkingBgpConfigList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingBgpConfigListAllPages(ctx context.Context, params NetworkingBgpConfigListParams) ([]BgpConfig, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []BgpConfig
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.NetworkingBgpConfigList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingBgpConfigCreate: Create new BGP configuration
func (c *Client) NetworkingBgpConfigCreate(ctx context.Context, params NetworkingBgpConfigCreateParams) (*BgpConfig, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/bgp"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body BgpConfig
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpConfigDelete: Delete BGP configuration
func (c *Client) NetworkingBgpConfigDelete(ctx context.Context, params NetworkingBgpConfigDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/bgp"),
		map[string]string{},
		map[string]string{
			"name_or_id": string(params.NameOrId),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingBgpAnnounceSetList: List BGP announce sets
//
// To iterate over all pages, use the `NetworkingBgpAnnounceSetListAllPages` method, instead.
func (c *Client) NetworkingBgpAnnounceSetList(ctx context.Context, params NetworkingBgpAnnounceSetListParams) (*[]BgpAnnounceSet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-announce-set"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BgpAnnounceSet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpAnnounceSetUpdate: Update BGP announce set
// If the announce set exists, this endpoint replaces the existing announce set with the one specified.
func (c *Client) NetworkingBgpAnnounceSetUpdate(ctx context.Context, params NetworkingBgpAnnounceSetUpdateParams) (*BgpAnnounceSet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/networking/bgp-announce-set"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body BgpAnnounceSet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpAnnounceSetDelete: Delete BGP announce set
func (c *Client) NetworkingBgpAnnounceSetDelete(ctx context.Context, params NetworkingBgpAnnounceSetDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/bgp-announce-set/{{.announce_set}}"),
		map[string]string{
			"announce_set": string(params.AnnounceSet),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingBgpAnnouncementList: Get originated routes for a specified BGP announce set
func (c *Client) NetworkingBgpAnnouncementList(ctx context.Context, params NetworkingBgpAnnouncementListParams) (*[]BgpAnnouncement, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-announce-set/{{.announce_set}}/announcement"),
		map[string]string{
			"announce_set": string(params.AnnounceSet),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BgpAnnouncement
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpExported: Get BGP exported routes
func (c *Client) NetworkingBgpExported(ctx context.Context) (*BgpExported, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-exported"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body BgpExported
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpMessageHistory: Get BGP router message history
func (c *Client) NetworkingBgpMessageHistory(ctx context.Context, params NetworkingBgpMessageHistoryParams) (*AggregateBgpMessageHistory, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-message-history"),
		map[string]string{},
		map[string]string{
			"asn": strconv.Itoa(params.Asn),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body AggregateBgpMessageHistory
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpImportedRoutesIpv4: Get imported IPv4 BGP routes
func (c *Client) NetworkingBgpImportedRoutesIpv4(ctx context.Context, params NetworkingBgpImportedRoutesIpv4Params) (*[]BgpImportedRouteIpv4, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-routes-ipv4"),
		map[string]string{},
		map[string]string{
			"asn": strconv.Itoa(params.Asn),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BgpImportedRouteIpv4
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingBgpStatus: Get BGP peer status
func (c *Client) NetworkingBgpStatus(ctx context.Context) (*[]BgpPeerStatus, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/bgp-status"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body []BgpPeerStatus
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingLoopbackAddressList: List loopback addresses
//
// To iterate over all pages, use the `NetworkingLoopbackAddressListAllPages` method, instead.
func (c *Client) NetworkingLoopbackAddressList(ctx context.Context, params NetworkingLoopbackAddressListParams) (*LoopbackAddressResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/loopback-address"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body LoopbackAddressResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingLoopbackAddressListAllPages: List loopback addresses
//
// This method is a wrapper around the `NetworkingLoopbackAddressList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingLoopbackAddressListAllPages(ctx context.Context, params NetworkingLoopbackAddressListParams) ([]LoopbackAddress, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []LoopbackAddress
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.NetworkingLoopbackAddressList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingLoopbackAddressCreate: Create loopback address
func (c *Client) NetworkingLoopbackAddressCreate(ctx context.Context, params NetworkingLoopbackAddressCreateParams) (*LoopbackAddress, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/loopback-address"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body LoopbackAddress
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingLoopbackAddressDelete: Delete loopback address
func (c *Client) NetworkingLoopbackAddressDelete(ctx context.Context, params NetworkingLoopbackAddressDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/loopback-address/{{.rack_id}}/{{.switch_location}}/{{.address}}/{{.subnet_mask}}"),
		map[string]string{
			"address":         params.Address,
			"rack_id":         params.RackId,
			"subnet_mask":     strconv.Itoa(params.SubnetMask),
			"switch_location": string(params.SwitchLocation),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingSwitchPortSettingsList: List switch port settings
//
// To iterate over all pages, use the `NetworkingSwitchPortSettingsListAllPages` method, instead.
func (c *Client) NetworkingSwitchPortSettingsList(ctx context.Context, params NetworkingSwitchPortSettingsListParams) (*SwitchPortSettingsResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/switch-port-settings"),
		map[string]string{},
		map[string]string{
			"limit":         strconv.Itoa(params.Limit),
			"page_token":    params.PageToken,
			"port_settings": string(params.PortSettings),
			"sort_by":       string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchPortSettingsResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortSettingsListAllPages: List switch port settings
//
// This method is a wrapper around the `NetworkingSwitchPortSettingsList` method.
// This method returns all the pages at once.
func (c *Client) NetworkingSwitchPortSettingsListAllPages(ctx context.Context, params NetworkingSwitchPortSettingsListParams) ([]SwitchPortSettings, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SwitchPortSettings
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.NetworkingSwitchPortSettingsList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// NetworkingSwitchPortSettingsCreate: Create switch port settings
func (c *Client) NetworkingSwitchPortSettingsCreate(ctx context.Context, params NetworkingSwitchPortSettingsCreateParams) (*SwitchPortSettingsView, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/networking/switch-port-settings"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchPortSettingsView
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// NetworkingSwitchPortSettingsDelete: Delete switch port settings
func (c *Client) NetworkingSwitchPortSettingsDelete(ctx context.Context, params NetworkingSwitchPortSettingsDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/networking/switch-port-settings"),
		map[string]string{},
		map[string]string{
			"port_settings": string(params.PortSettings),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// NetworkingSwitchPortSettingsView: Get information about switch port
func (c *Client) NetworkingSwitchPortSettingsView(ctx context.Context, params NetworkingSwitchPortSettingsViewParams) (*SwitchPortSettingsView, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/networking/switch-port-settings/{{.port}}"),
		map[string]string{
			"port": string(params.Port),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SwitchPortSettingsView
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemPolicyView: Fetch top-level IAM policy
func (c *Client) SystemPolicyView(ctx context.Context) (*FleetRolePolicy, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemPolicyUpdate: Update top-level IAM policy
func (c *Client) SystemPolicyUpdate(ctx context.Context, params SystemPolicyUpdateParams) (*FleetRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RoleList: List built-in roles
//
// To iterate over all pages, use the `RoleListAllPages` method, instead.
func (c *Client) RoleList(ctx context.Context, params RoleListParams) (*RoleResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/roles"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RoleResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RoleListAllPages: List built-in roles
//
// This method is a wrapper around the `RoleList` method.
// This method returns all the pages at once.
func (c *Client) RoleListAllPages(ctx context.Context, params RoleListParams) ([]Role, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Role
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.RoleList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// RoleView: Fetch built-in role
func (c *Client) RoleView(ctx context.Context, params RoleViewParams) (*Role, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/roles/{{.role_name}}"),
		map[string]string{
			"role_name": params.RoleName,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Role
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemQuotasList: Lists resource quotas for all silos
//
// To iterate over all pages, use the `SystemQuotasListAllPages` method, instead.
func (c *Client) SystemQuotasList(ctx context.Context, params SystemQuotasListParams) (*SiloQuotasResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silo-quotas"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloQuotasResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemQuotasListAllPages: Lists resource quotas for all silos
//
// This method is a wrapper around the `SystemQuotasList` method.
// This method returns all the pages at once.
func (c *Client) SystemQuotasListAllPages(ctx context.Context, params SystemQuotasListParams) ([]SiloQuotas, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SiloQuotas
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SystemQuotasList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SiloList: List silos
// Lists silos that are discoverable based on the current permissions.
//
// To iterate over all pages, use the `SiloListAllPages` method, instead.
func (c *Client) SiloList(ctx context.Context, params SiloListParams) (*SiloResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloListAllPages: List silos
// Lists silos that are discoverable based on the current permissions.
//
// This method is a wrapper around the `SiloList` method.
// This method returns all the pages at once.
func (c *Client) SiloListAllPages(ctx context.Context, params SiloListParams) ([]Silo, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Silo
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SiloList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SiloCreate: Create a silo
func (c *Client) SiloCreate(ctx context.Context, params SiloCreateParams) (*Silo, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/silos"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Silo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloView: Fetch silo
// Fetch silo by name or ID.
func (c *Client) SiloView(ctx context.Context, params SiloViewParams) (*Silo, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Silo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloDelete: Delete a silo
// Delete a silo by name or ID.
func (c *Client) SiloDelete(ctx context.Context, params SiloDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// SiloIpPoolList: List IP pools linked to silo
// Linked IP pools are available to users in the specified silo. A silo can have at most one default pool. IPs are allocated from the default pool when users ask for one without specifying a pool.
//
// To iterate over all pages, use the `SiloIpPoolListAllPages` method, instead.
func (c *Client) SiloIpPoolList(ctx context.Context, params SiloIpPoolListParams) (*SiloIpPoolResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/ip-pools"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloIpPoolResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloIpPoolListAllPages: List IP pools linked to silo
// Linked IP pools are available to users in the specified silo. A silo can have at most one default pool. IPs are allocated from the default pool when users ask for one without specifying a pool.
//
// This method is a wrapper around the `SiloIpPoolList` method.
// This method returns all the pages at once.
func (c *Client) SiloIpPoolListAllPages(ctx context.Context, params SiloIpPoolListParams) ([]SiloIpPool, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SiloIpPool
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SiloIpPoolList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SiloPolicyView: Fetch silo IAM policy
func (c *Client) SiloPolicyView(ctx context.Context, params SiloPolicyViewParams) (*SiloRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/policy"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloPolicyUpdate: Update silo IAM policy
func (c *Client) SiloPolicyUpdate(ctx context.Context, params SiloPolicyUpdateParams) (*SiloRolePolicy, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/policy"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloQuotasView: Fetch resource quotas for silo
func (c *Client) SiloQuotasView(ctx context.Context, params SiloQuotasViewParams) (*SiloQuotas, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/quotas"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloQuotas
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloQuotasUpdate: Update resource quotas for silo
// If a quota value is not specified, it will remain unchanged.
func (c *Client) SiloQuotasUpdate(ctx context.Context, params SiloQuotasUpdateParams) (*SiloQuotas, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/system/silos/{{.silo}}/quotas"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloQuotas
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemTimeseriesQuery: Run timeseries query
// Queries are written in OxQL.
func (c *Client) SystemTimeseriesQuery(ctx context.Context, params SystemTimeseriesQueryParams) (*OxqlQueryResult, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/system/timeseries/query"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OxqlQueryResult
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemTimeseriesSchemaList: List timeseries schemas
//
// To iterate over all pages, use the `SystemTimeseriesSchemaListAllPages` method, instead.
func (c *Client) SystemTimeseriesSchemaList(ctx context.Context, params SystemTimeseriesSchemaListParams) (*TimeseriesSchemaResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/timeseries/schemas"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body TimeseriesSchemaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemTimeseriesSchemaListAllPages: List timeseries schemas
//
// This method is a wrapper around the `SystemTimeseriesSchemaList` method.
// This method returns all the pages at once.
func (c *Client) SystemTimeseriesSchemaListAllPages(ctx context.Context, params SystemTimeseriesSchemaListParams) ([]TimeseriesSchema, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []TimeseriesSchema
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SystemTimeseriesSchemaList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SiloUserList: List built-in (system) users in silo
//
// To iterate over all pages, use the `SiloUserListAllPages` method, instead.
func (c *Client) SiloUserList(ctx context.Context, params SiloUserListParams) (*UserResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/users"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"silo":       string(params.Silo),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUserListAllPages: List built-in (system) users in silo
//
// This method is a wrapper around the `SiloUserList` method.
// This method returns all the pages at once.
func (c *Client) SiloUserListAllPages(ctx context.Context, params SiloUserListParams) ([]User, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []User
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SiloUserList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// UserBuiltinList: List built-in users
//
// To iterate over all pages, use the `UserBuiltinListAllPages` method, instead.
func (c *Client) UserBuiltinList(ctx context.Context, params UserBuiltinListParams) (*UserBuiltinResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/users-builtin"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserBuiltinResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserBuiltinListAllPages: List built-in users
//
// This method is a wrapper around the `UserBuiltinList` method.
// This method returns all the pages at once.
func (c *Client) UserBuiltinListAllPages(ctx context.Context, params UserBuiltinListParams) ([]UserBuiltin, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []UserBuiltin
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.UserBuiltinList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// UserBuiltinView: Fetch built-in user
func (c *Client) UserBuiltinView(ctx context.Context, params UserBuiltinViewParams) (*UserBuiltin, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/users-builtin/{{.user}}"),
		map[string]string{
			"user": string(params.User),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserBuiltin
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUserView: Fetch built-in (system) user
func (c *Client) SiloUserView(ctx context.Context, params SiloUserViewParams) (*User, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/users/{{.user_id}}"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUtilizationList: List current utilization state for all silos
//
// To iterate over all pages, use the `SiloUtilizationListAllPages` method, instead.
func (c *Client) SiloUtilizationList(ctx context.Context, params SiloUtilizationListParams) (*SiloUtilizationResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/utilization/silos"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloUtilizationResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUtilizationListAllPages: List current utilization state for all silos
//
// This method is a wrapper around the `SiloUtilizationList` method.
// This method returns all the pages at once.
func (c *Client) SiloUtilizationListAllPages(ctx context.Context, params SiloUtilizationListParams) ([]SiloUtilization, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []SiloUtilization
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SiloUtilizationList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// SiloUtilizationView: Fetch current utilization for given silo
func (c *Client) SiloUtilizationView(ctx context.Context, params SiloUtilizationViewParams) (*SiloUtilization, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/system/utilization/silos/{{.silo}}"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloUtilization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserList: List users
//
// To iterate over all pages, use the `UserListAllPages` method, instead.
func (c *Client) UserList(ctx context.Context, params UserListParams) (*UserResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/users"),
		map[string]string{},
		map[string]string{
			"group":      params.Group,
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserListAllPages: List users
//
// This method is a wrapper around the `UserList` method.
// This method returns all the pages at once.
func (c *Client) UserListAllPages(ctx context.Context, params UserListParams) ([]User, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []User
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.UserList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// UtilizationView: Fetch resource utilization for user's current silo
func (c *Client) UtilizationView(ctx context.Context) (*Utilization, error) {
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/utilization"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Utilization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcFirewallRulesView: List firewall rules
func (c *Client) VpcFirewallRulesView(ctx context.Context, params VpcFirewallRulesViewParams) (*VpcFirewallRules, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-firewall-rules"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcFirewallRulesUpdate: Replace firewall rules
// The maximum number of rules per VPC is 1024.
//
// Targets are used to specify the set of instances to which a firewall rule applies. You can target instances directly by name, or specify a VPC, VPC subnet, IP, or IP subnet, which will apply the rule to traffic going to all matching instances. Targets are additive: the rule applies to instances matching ANY target. The maximum number of targets is 256.
//
// Filters reduce the scope of a firewall rule. Without filters, the rule applies to all packets to the targets (or from the targets, if it's an outbound rule). With multiple filters, the rule applies only to packets matching ALL filters. The maximum number of each type of filter is 256.
func (c *Client) VpcFirewallRulesUpdate(ctx context.Context, params VpcFirewallRulesUpdateParams) (*VpcFirewallRules, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpc-firewall-rules"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteList: List routes
// List the routes associated with a router in a particular VPC.
//
// To iterate over all pages, use the `VpcRouterRouteListAllPages` method, instead.
func (c *Client) VpcRouterRouteList(ctx context.Context, params VpcRouterRouteListParams) (*RouterRouteResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-router-routes"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"router":     string(params.Router),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRouteResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteListAllPages: List routes
// List the routes associated with a router in a particular VPC.
//
// This method is a wrapper around the `VpcRouterRouteList` method.
// This method returns all the pages at once.
func (c *Client) VpcRouterRouteListAllPages(ctx context.Context, params VpcRouterRouteListParams) ([]RouterRoute, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []RouterRoute
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcRouterRouteList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcRouterRouteCreate: Create route
func (c *Client) VpcRouterRouteCreate(ctx context.Context, params VpcRouterRouteCreateParams) (*RouterRoute, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/vpc-router-routes"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteView: Fetch route
func (c *Client) VpcRouterRouteView(ctx context.Context, params VpcRouterRouteViewParams) (*RouterRoute, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-router-routes/{{.route}}"),
		map[string]string{
			"route": string(params.Route),
		},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteUpdate: Update route
func (c *Client) VpcRouterRouteUpdate(ctx context.Context, params VpcRouterRouteUpdateParams) (*RouterRoute, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpc-router-routes/{{.route}}"),
		map[string]string{
			"route": string(params.Route),
		},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteDelete: Delete route
func (c *Client) VpcRouterRouteDelete(ctx context.Context, params VpcRouterRouteDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/vpc-router-routes/{{.route}}"),
		map[string]string{
			"route": string(params.Route),
		},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// VpcRouterList: List routers
//
// To iterate over all pages, use the `VpcRouterListAllPages` method, instead.
func (c *Client) VpcRouterList(ctx context.Context, params VpcRouterListParams) (*VpcRouterResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-routers"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouterResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterListAllPages: List routers
//
// This method is a wrapper around the `VpcRouterList` method.
// This method returns all the pages at once.
func (c *Client) VpcRouterListAllPages(ctx context.Context, params VpcRouterListParams) ([]VpcRouter, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []VpcRouter
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcRouterList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcRouterCreate: Create VPC router
func (c *Client) VpcRouterCreate(ctx context.Context, params VpcRouterCreateParams) (*VpcRouter, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/vpc-routers"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterView: Fetch router
func (c *Client) VpcRouterView(ctx context.Context, params VpcRouterViewParams) (*VpcRouter, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-routers/{{.router}}"),
		map[string]string{
			"router": string(params.Router),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterUpdate: Update router
func (c *Client) VpcRouterUpdate(ctx context.Context, params VpcRouterUpdateParams) (*VpcRouter, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpc-routers/{{.router}}"),
		map[string]string{
			"router": string(params.Router),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterDelete: Delete router
func (c *Client) VpcRouterDelete(ctx context.Context, params VpcRouterDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/vpc-routers/{{.router}}"),
		map[string]string{
			"router": string(params.Router),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// VpcSubnetList: List subnets
//
// To iterate over all pages, use the `VpcSubnetListAllPages` method, instead.
func (c *Client) VpcSubnetList(ctx context.Context, params VpcSubnetListParams) (*VpcSubnetResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-subnets"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnetResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetListAllPages: List subnets
//
// This method is a wrapper around the `VpcSubnetList` method.
// This method returns all the pages at once.
func (c *Client) VpcSubnetListAllPages(ctx context.Context, params VpcSubnetListParams) ([]VpcSubnet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []VpcSubnet
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcSubnetList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcSubnetCreate: Create subnet
func (c *Client) VpcSubnetCreate(ctx context.Context, params VpcSubnetCreateParams) (*VpcSubnet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/vpc-subnets"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetView: Fetch subnet
func (c *Client) VpcSubnetView(ctx context.Context, params VpcSubnetViewParams) (*VpcSubnet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-subnets/{{.subnet}}"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetUpdate: Update subnet
func (c *Client) VpcSubnetUpdate(ctx context.Context, params VpcSubnetUpdateParams) (*VpcSubnet, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpc-subnets/{{.subnet}}"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetDelete: Delete subnet
func (c *Client) VpcSubnetDelete(ctx context.Context, params VpcSubnetDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/vpc-subnets/{{.subnet}}"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}

// VpcSubnetListNetworkInterfaces: List network interfaces
//
// To iterate over all pages, use the `VpcSubnetListNetworkInterfacesAllPages` method, instead.
func (c *Client) VpcSubnetListNetworkInterfaces(ctx context.Context, params VpcSubnetListNetworkInterfacesParams) (*InstanceNetworkInterfaceResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpc-subnets/{{.subnet}}/network-interfaces"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceNetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetListNetworkInterfacesAllPages: List network interfaces
//
// This method is a wrapper around the `VpcSubnetListNetworkInterfaces` method.
// This method returns all the pages at once.
func (c *Client) VpcSubnetListNetworkInterfacesAllPages(ctx context.Context, params VpcSubnetListNetworkInterfacesParams) ([]InstanceNetworkInterface, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []InstanceNetworkInterface
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcSubnetListNetworkInterfaces(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcList: List VPCs
//
// To iterate over all pages, use the `VpcListAllPages` method, instead.
func (c *Client) VpcList(ctx context.Context, params VpcListParams) (*VpcResultsPage, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpcs"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcListAllPages: List VPCs
//
// This method is a wrapper around the `VpcList` method.
// This method returns all the pages at once.
func (c *Client) VpcListAllPages(ctx context.Context, params VpcListParams) ([]Vpc, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []Vpc
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// VpcCreate: Create VPC
func (c *Client) VpcCreate(ctx context.Context, params VpcCreateParams) (*Vpc, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"POST",
		resolveRelative(c.host, "/v1/vpcs"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcView: Fetch VPC
func (c *Client) VpcView(ctx context.Context, params VpcViewParams) (*Vpc, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"GET",
		resolveRelative(c.host, "/v1/vpcs/{{.vpc}}"),
		map[string]string{
			"vpc": string(params.Vpc),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcUpdate: Update a VPC
func (c *Client) VpcUpdate(ctx context.Context, params VpcUpdateParams) (*Vpc, error) {
	if err := params.Validate(); err != nil {
		return nil, err
	}
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := c.buildRequest(
		ctx,
		b,
		"PUT",
		resolveRelative(c.host, "/v1/vpcs/{{.vpc}}"),
		map[string]string{
			"vpc": string(params.Vpc),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcDelete: Delete VPC
func (c *Client) VpcDelete(ctx context.Context, params VpcDeleteParams) error {
	if err := params.Validate(); err != nil {
		return err
	}
	// Create the request
	req, err := c.buildRequest(
		ctx,
		nil,
		"DELETE",
		resolveRelative(c.host, "/v1/vpcs/{{.vpc}}"),
		map[string]string{
			"vpc": string(params.Vpc),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Create and return an HTTPError when an error response code is received.
	if err := NewHTTPError(resp); err != nil {
		return err
	}

	return nil
}
