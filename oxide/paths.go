// Code generated by `generate`. DO NOT EDIT.

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package oxide

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
)

// LoginLocal: Authenticate a user (i.e., log in) via username and password
func (c *Client) LoginLocal(params LoginLocalParams) error {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/login/{{.silo_name}}/local"),
		map[string]string{
			"silo_name": string(params.SiloName),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// LoginSamlBegin: Prompt user login
// Either display a page asking a user for their credentials, or redirect them to their identity provider.
func (c *Client) LoginSamlBegin(params LoginSamlBeginParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/login/{{.silo_name}}/saml/{{.provider_name}}"),
		map[string]string{
			"provider_name": string(params.ProviderName),
			"silo_name":     string(params.SiloName),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// LoginSaml: Authenticate a user (i.e., log in) via SAML
func (c *Client) LoginSaml(params LoginSamlParams) error {
	b := params.Body

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/login/{{.silo_name}}/saml/{{.provider_name}}"),
		map[string]string{
			"provider_name": string(params.ProviderName),
			"silo_name":     string(params.SiloName),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemImageViewById: Fetch a system-wide image by id
func (c *Client) SystemImageViewById(params SystemImageViewByIdParams) (*GlobalImage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/system/by-id/images/{{.id}}"),
		map[string]string{
			"id": params.Id,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GlobalImage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemImageList: List system-wide images
// Returns a list of all the system-wide images. System-wide images are returned sorted by creation date, with the most recent images appearing first.
//
// To iterate over all pages, use the `SystemImageListAllPages` method, instead.
func (c *Client) SystemImageList(params SystemImageListParams) (*GlobalImageResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/system/images"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GlobalImageResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemImageListAllPages: List system-wide images
// Returns a list of all the system-wide images. System-wide images are returned sorted by creation date, with the most recent images appearing first.
//
// This method is a wrapper around the `SystemImageList` method.
// This method returns all the pages at once.
func (c *Client) SystemImageListAllPages(params SystemImageListParams) (*[]GlobalImage, error) {
	var allPages []GlobalImage
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SystemImageList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemImageCreate: Create a system-wide image
// Create a new system-wide image. This image can then be used by any user in any silo as a base for instances.
func (c *Client) SystemImageCreate(params SystemImageCreateParams) (*GlobalImage, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/system/images"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GlobalImage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemImageView: Fetch a system-wide image
// Returns the details of a specific system-wide image.
func (c *Client) SystemImageView(params SystemImageViewParams) (*GlobalImage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/system/images/{{.image_name}}"),
		map[string]string{
			"image_name": string(params.ImageName),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GlobalImage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemImageDelete: Delete a system-wide image
// Permanently delete a system-wide image. This operation cannot be undone. Any instances using the system-wide image will continue to run, however new instances can not be created with this image.
func (c *Client) SystemImageDelete(params SystemImageDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/system/images/{{.image_name}}"),
		map[string]string{
			"image_name": string(params.ImageName),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// DiskList: List disks
//
// To iterate over all pages, use the `DiskListAllPages` method, instead.
func (c *Client) DiskList(params DiskListParams) (*DiskResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/disks"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskListAllPages: List disks
//
// This method is a wrapper around the `DiskList` method.
// This method returns all the pages at once.
func (c *Client) DiskListAllPages(params DiskListParams) (*[]Disk, error) {
	var allPages []Disk
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.DiskList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// DiskCreate: Create a disk
func (c *Client) DiskCreate(params DiskCreateParams) (*Disk, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/disks"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskView: Fetch a disk
func (c *Client) DiskView(params DiskViewParams) (*Disk, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/disks/{{.disk}}"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskDelete: Delete a disk
func (c *Client) DiskDelete(params DiskDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/disks/{{.disk}}"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// DiskBulkWriteImport: Import blocks into a disk
func (c *Client) DiskBulkWriteImport(params DiskBulkWriteImportParams) error {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/disks/{{.disk}}/bulk-write"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// DiskBulkWriteImportStart: Start the process of importing blocks into a disk
func (c *Client) DiskBulkWriteImportStart(params DiskBulkWriteImportStartParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"POST",
		resolveRelative(c.server, "/v1/disks/{{.disk}}/bulk-write-start"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// DiskBulkWriteImportStop: Stop the process of importing blocks into a disk
func (c *Client) DiskBulkWriteImportStop(params DiskBulkWriteImportStopParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"POST",
		resolveRelative(c.server, "/v1/disks/{{.disk}}/bulk-write-stop"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// DiskFinalizeImport: Finalize disk when imports are done
func (c *Client) DiskFinalizeImport(params DiskFinalizeImportParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"POST",
		resolveRelative(c.server, "/v1/disks/{{.disk}}/finalize"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project":       string(params.Project),
			"snapshot_name": params.SnapshotName,
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// DiskImportBlocksFromUrl: Send request to import blocks from URL
func (c *Client) DiskImportBlocksFromUrl(params DiskImportBlocksFromUrlParams) error {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/disks/{{.disk}}/import"),
		map[string]string{
			"disk": string(params.Disk),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// DiskMetricsList: Fetch disk metrics
//
// To iterate over all pages, use the `DiskMetricsListAllPages` method, instead.
func (c *Client) DiskMetricsList(params DiskMetricsListParams) (*MeasurementResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/disks/{{.disk}}/metrics/{{.metric}}"),
		map[string]string{
			"disk":   string(params.Disk),
			"metric": string(params.Metric),
		},
		map[string]string{
			"end_time":   params.EndTime.String(),
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"start_time": params.StartTime.String(),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body MeasurementResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskMetricsListAllPages: Fetch disk metrics
//
// This method is a wrapper around the `DiskMetricsList` method.
// This method returns all the pages at once.
func (c *Client) DiskMetricsListAllPages(params DiskMetricsListParams) (*[]Measurement, error) {
	var allPages []Measurement
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.DiskMetricsList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// GroupList: List groups
//
// To iterate over all pages, use the `GroupListAllPages` method, instead.
func (c *Client) GroupList(params GroupListParams) (*GroupResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/groups"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GroupResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// GroupListAllPages: List groups
//
// This method is a wrapper around the `GroupList` method.
// This method returns all the pages at once.
func (c *Client) GroupListAllPages(params GroupListParams) (*[]Group, error) {
	var allPages []Group
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.GroupList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// GroupView: Fetch group
func (c *Client) GroupView(params GroupViewParams) (*Group, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/groups/{{.group}}"),
		map[string]string{
			"group": params.Group,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Group
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageList: List images
// List images which are global or scoped to the specified project. The images are returned sorted by creation date, with the most recent images appearing first.
//
// To iterate over all pages, use the `ImageListAllPages` method, instead.
func (c *Client) ImageList(params ImageListParams) (*ImageResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/images"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ImageResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageListAllPages: List images
// List images which are global or scoped to the specified project. The images are returned sorted by creation date, with the most recent images appearing first.
//
// This method is a wrapper around the `ImageList` method.
// This method returns all the pages at once.
func (c *Client) ImageListAllPages(params ImageListParams) (*[]Image, error) {
	var allPages []Image
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.ImageList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// ImageCreate: Create an image
// Create a new image in a project.
func (c *Client) ImageCreate(params ImageCreateParams) (*Image, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/images"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageView: Fetch an image
// Fetch the details for a specific image in a project.
func (c *Client) ImageView(params ImageViewParams) (*Image, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/images/{{.image}}"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageDelete: Delete an image
// Permanently delete an image from a project. This operation cannot be undone. Any instances in the project using the image will continue to run, however new instances can not be created with this image.
func (c *Client) ImageDelete(params ImageDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/images/{{.image}}"),
		map[string]string{
			"image": string(params.Image),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceList: List instances
//
// To iterate over all pages, use the `InstanceListAllPages` method, instead.
func (c *Client) InstanceList(params InstanceListParams) (*InstanceResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/instances"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceListAllPages: List instances
//
// This method is a wrapper around the `InstanceList` method.
// This method returns all the pages at once.
func (c *Client) InstanceListAllPages(params InstanceListParams) (*[]Instance, error) {
	var allPages []Instance
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InstanceList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceCreate: Create an instance
func (c *Client) InstanceCreate(params InstanceCreateParams) (*Instance, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/instances"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceView: Fetch an instance
func (c *Client) InstanceView(params InstanceViewParams) (*Instance, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/instances/{{.instance}}"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDelete: Delete an instance
func (c *Client) InstanceDelete(params InstanceDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/instances/{{.instance}}"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceDiskList: List an instance's disks
//
// To iterate over all pages, use the `InstanceDiskListAllPages` method, instead.
func (c *Client) InstanceDiskList(params InstanceDiskListParams) (*DiskResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/disks"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskListAllPages: List an instance's disks
//
// This method is a wrapper around the `InstanceDiskList` method.
// This method returns all the pages at once.
func (c *Client) InstanceDiskListAllPages(params InstanceDiskListParams) (*[]Disk, error) {
	var allPages []Disk
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InstanceDiskList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceDiskAttach: Attach a disk to an instance
func (c *Client) InstanceDiskAttach(params InstanceDiskAttachParams) (*Disk, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/disks/attach"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskDetach: Detach a disk from an instance
func (c *Client) InstanceDiskDetach(params InstanceDiskDetachParams) (*Disk, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/disks/detach"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceExternalIpList: List external IP addresses
func (c *Client) InstanceExternalIpList(params InstanceExternalIpListParams) (*ExternalIpResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/external-ips"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ExternalIpResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceMigrate: Migrate an instance
func (c *Client) InstanceMigrate(params InstanceMigrateParams) (*Instance, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/migrate"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceReboot: Reboot an instance
func (c *Client) InstanceReboot(params InstanceRebootParams) (*Instance, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"POST",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/reboot"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsole: Fetch an instance's serial console
func (c *Client) InstanceSerialConsole(params InstanceSerialConsoleParams) (*InstanceSerialConsoleData, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/serial-console"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"from_start":  strconv.Itoa(params.FromStart),
			"max_bytes":   strconv.Itoa(params.MaxBytes),
			"most_recent": strconv.Itoa(params.MostRecent),
			"project":     string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceSerialConsoleData
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsoleStream: Stream an instance's serial console
func (c *Client) InstanceSerialConsoleStream(params InstanceSerialConsoleStreamParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/serial-console/stream"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"from_start":  strconv.Itoa(params.FromStart),
			"max_bytes":   strconv.Itoa(params.MaxBytes),
			"most_recent": strconv.Itoa(params.MostRecent),
			"project":     string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceStart: Boot an instance
func (c *Client) InstanceStart(params InstanceStartParams) (*Instance, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"POST",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/start"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceStop: Stop an instance
func (c *Client) InstanceStop(params InstanceStopParams) (*Instance, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"POST",
		resolveRelative(c.server, "/v1/instances/{{.instance}}/stop"),
		map[string]string{
			"instance": string(params.Instance),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserView: Fetch the user associated with the current session
func (c *Client) CurrentUserView() (*CurrentUser, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/me"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body CurrentUser
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserGroups: Fetch the silo groups the current user belongs to
//
// To iterate over all pages, use the `CurrentUserGroupsAllPages` method, instead.
func (c *Client) CurrentUserGroups(params CurrentUserGroupsParams) (*GroupResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/me/groups"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GroupResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserGroupsAllPages: Fetch the silo groups the current user belongs to
//
// This method is a wrapper around the `CurrentUserGroups` method.
// This method returns all the pages at once.
func (c *Client) CurrentUserGroupsAllPages(params CurrentUserGroupsParams) (*[]Group, error) {
	var allPages []Group
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.CurrentUserGroups(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// CurrentUserSshKeyList: List SSH public keys
// Lists SSH public keys for the currently authenticated user.
//
// To iterate over all pages, use the `CurrentUserSshKeyListAllPages` method, instead.
func (c *Client) CurrentUserSshKeyList(params CurrentUserSshKeyListParams) (*SshKeyResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/me/ssh-keys"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKeyResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserSshKeyListAllPages: List SSH public keys
// Lists SSH public keys for the currently authenticated user.
//
// This method is a wrapper around the `CurrentUserSshKeyList` method.
// This method returns all the pages at once.
func (c *Client) CurrentUserSshKeyListAllPages(params CurrentUserSshKeyListParams) (*[]SshKey, error) {
	var allPages []SshKey
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.CurrentUserSshKeyList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// CurrentUserSshKeyCreate: Create an SSH public key
// Create an SSH public key for the currently authenticated user.
func (c *Client) CurrentUserSshKeyCreate(params CurrentUserSshKeyCreateParams) (*SshKey, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/me/ssh-keys"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKey
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserSshKeyView: Fetch an SSH public key
// Fetch an SSH public key associated with the currently authenticated user.
func (c *Client) CurrentUserSshKeyView(params CurrentUserSshKeyViewParams) (*SshKey, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/me/ssh-keys/{{.ssh_key}}"),
		map[string]string{
			"ssh_key": string(params.SshKey),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKey
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CurrentUserSshKeyDelete: Delete an SSH public key
// Delete an SSH public key associated with the currently authenticated user.
func (c *Client) CurrentUserSshKeyDelete(params CurrentUserSshKeyDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/me/ssh-keys/{{.ssh_key}}"),
		map[string]string{
			"ssh_key": string(params.SshKey),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceNetworkInterfaceList: List network interfaces
//
// To iterate over all pages, use the `InstanceNetworkInterfaceListAllPages` method, instead.
func (c *Client) InstanceNetworkInterfaceList(params InstanceNetworkInterfaceListParams) (*NetworkInterfaceResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/network-interfaces"),
		map[string]string{},
		map[string]string{
			"instance":   string(params.Instance),
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceListAllPages: List network interfaces
//
// This method is a wrapper around the `InstanceNetworkInterfaceList` method.
// This method returns all the pages at once.
func (c *Client) InstanceNetworkInterfaceListAllPages(params InstanceNetworkInterfaceListParams) (*[]NetworkInterface, error) {
	var allPages []NetworkInterface
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.InstanceNetworkInterfaceList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceNetworkInterfaceCreate: Create a network interface
func (c *Client) InstanceNetworkInterfaceCreate(params InstanceNetworkInterfaceCreateParams) (*NetworkInterface, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/network-interfaces"),
		map[string]string{},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceView: Fetch a network interface
func (c *Client) InstanceNetworkInterfaceView(params InstanceNetworkInterfaceViewParams) (*NetworkInterface, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/network-interfaces/{{.interface}}"),
		map[string]string{
			"interface": string(params.Interface),
		},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceUpdate: Update a network interface
func (c *Client) InstanceNetworkInterfaceUpdate(params InstanceNetworkInterfaceUpdateParams) (*NetworkInterface, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/network-interfaces/{{.interface}}"),
		map[string]string{
			"interface": string(params.Interface),
		},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceDelete: Delete a network interface
// Note that the primary interface for an instance cannot be deleted if there are any secondary interfaces. A new primary interface must be designated first. The primary interface can be deleted if there are no secondary interfaces.
func (c *Client) InstanceNetworkInterfaceDelete(params InstanceNetworkInterfaceDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/network-interfaces/{{.interface}}"),
		map[string]string{
			"interface": string(params.Interface),
		},
		map[string]string{
			"instance": string(params.Instance),
			"project":  string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// PolicyView: Fetch the current silo's IAM policy
func (c *Client) PolicyView() (*SiloRolePolicy, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PolicyUpdate: Update the current silo's IAM policy
func (c *Client) PolicyUpdate(params PolicyUpdateParams) (*SiloRolePolicy, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectList: List projects
//
// To iterate over all pages, use the `ProjectListAllPages` method, instead.
func (c *Client) ProjectList(params ProjectListParams) (*ProjectResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/projects"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectListAllPages: List projects
//
// This method is a wrapper around the `ProjectList` method.
// This method returns all the pages at once.
func (c *Client) ProjectListAllPages(params ProjectListParams) (*[]Project, error) {
	var allPages []Project
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.ProjectList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// ProjectCreate: Create a project
func (c *Client) ProjectCreate(params ProjectCreateParams) (*Project, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/projects"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectView: Fetch a project
func (c *Client) ProjectView(params ProjectViewParams) (*Project, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/projects/{{.project}}"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectUpdate: Update a project
func (c *Client) ProjectUpdate(params ProjectUpdateParams) (*Project, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/projects/{{.project}}"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectDelete: Delete a project
func (c *Client) ProjectDelete(params ProjectDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/projects/{{.project}}"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// ProjectPolicyView: Fetch a project's IAM policy
func (c *Client) ProjectPolicyView(params ProjectPolicyViewParams) (*ProjectRolePolicy, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/projects/{{.project}}/policy"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectPolicyUpdate: Update a project's IAM policy
func (c *Client) ProjectPolicyUpdate(params ProjectPolicyUpdateParams) (*ProjectRolePolicy, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/projects/{{.project}}/policy"),
		map[string]string{
			"project": string(params.Project),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotList: List snapshots
//
// To iterate over all pages, use the `SnapshotListAllPages` method, instead.
func (c *Client) SnapshotList(params SnapshotListParams) (*SnapshotResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/snapshots"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SnapshotResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotListAllPages: List snapshots
//
// This method is a wrapper around the `SnapshotList` method.
// This method returns all the pages at once.
func (c *Client) SnapshotListAllPages(params SnapshotListParams) (*[]Snapshot, error) {
	var allPages []Snapshot
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SnapshotList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// SnapshotCreate: Create a snapshot
// Creates a point-in-time snapshot from a disk.
func (c *Client) SnapshotCreate(params SnapshotCreateParams) (*Snapshot, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/snapshots"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotView: Fetch a snapshot
func (c *Client) SnapshotView(params SnapshotViewParams) (*Snapshot, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/snapshots/{{.snapshot}}"),
		map[string]string{
			"snapshot": string(params.Snapshot),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotDelete: Delete a snapshot
func (c *Client) SnapshotDelete(params SnapshotDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/snapshots/{{.snapshot}}"),
		map[string]string{
			"snapshot": string(params.Snapshot),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// CertificateList: List system-wide certificates
// Returns a list of all the system-wide certificates. System-wide certificates are returned sorted by creation date, with the most recent certificates appearing first.
//
// To iterate over all pages, use the `CertificateListAllPages` method, instead.
func (c *Client) CertificateList(params CertificateListParams) (*CertificateResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/certificates"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body CertificateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateListAllPages: List system-wide certificates
// Returns a list of all the system-wide certificates. System-wide certificates are returned sorted by creation date, with the most recent certificates appearing first.
//
// This method is a wrapper around the `CertificateList` method.
// This method returns all the pages at once.
func (c *Client) CertificateListAllPages(params CertificateListParams) (*[]Certificate, error) {
	var allPages []Certificate
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.CertificateList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// CertificateCreate: Create a new system-wide x.509 certificate.
// This certificate is automatically used by the Oxide Control plane to serve external connections.
func (c *Client) CertificateCreate(params CertificateCreateParams) (*Certificate, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/certificates"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateView: Fetch a certificate
// Returns the details of a specific certificate
func (c *Client) CertificateView(params CertificateViewParams) (*Certificate, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/certificates/{{.certificate}}"),
		map[string]string{
			"certificate": string(params.Certificate),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateDelete: Delete a certificate
// Permanently delete a certificate. This operation cannot be undone.
func (c *Client) CertificateDelete(params CertificateDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/system/certificates/{{.certificate}}"),
		map[string]string{
			"certificate": string(params.Certificate),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// PhysicalDiskList: List physical disks
//
// To iterate over all pages, use the `PhysicalDiskListAllPages` method, instead.
func (c *Client) PhysicalDiskList(params PhysicalDiskListParams) (*PhysicalDiskResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/hardware/disks"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PhysicalDiskListAllPages: List physical disks
//
// This method is a wrapper around the `PhysicalDiskList` method.
// This method returns all the pages at once.
func (c *Client) PhysicalDiskListAllPages(params PhysicalDiskListParams) (*[]PhysicalDisk, error) {
	var allPages []PhysicalDisk
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.PhysicalDiskList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// RackList: List racks
//
// To iterate over all pages, use the `RackListAllPages` method, instead.
func (c *Client) RackList(params RackListParams) (*RackResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/hardware/racks"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RackResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RackListAllPages: List racks
//
// This method is a wrapper around the `RackList` method.
// This method returns all the pages at once.
func (c *Client) RackListAllPages(params RackListParams) (*[]Rack, error) {
	var allPages []Rack
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.RackList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// RackView: Fetch a rack
func (c *Client) RackView(params RackViewParams) (*Rack, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/hardware/racks/{{.rack_id}}"),
		map[string]string{
			"rack_id": params.RackId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Rack
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledList: List sleds
//
// To iterate over all pages, use the `SledListAllPages` method, instead.
func (c *Client) SledList(params SledListParams) (*SledResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/hardware/sleds"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListAllPages: List sleds
//
// This method is a wrapper around the `SledList` method.
// This method returns all the pages at once.
func (c *Client) SledListAllPages(params SledListParams) (*[]Sled, error) {
	var allPages []Sled
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SledList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// SledView: Fetch a sled
func (c *Client) SledView(params SledViewParams) (*Sled, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/hardware/sleds/{{.sled_id}}"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Sled
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskList: List physical disks attached to sleds
//
// To iterate over all pages, use the `SledPhysicalDiskListAllPages` method, instead.
func (c *Client) SledPhysicalDiskList(params SledPhysicalDiskListParams) (*PhysicalDiskResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/hardware/sleds/{{.sled_id}}/disks"),
		map[string]string{
			"sled_id": params.SledId,
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskListAllPages: List physical disks attached to sleds
//
// This method is a wrapper around the `SledPhysicalDiskList` method.
// This method returns all the pages at once.
func (c *Client) SledPhysicalDiskListAllPages(params SledPhysicalDiskListParams) (*[]PhysicalDisk, error) {
	var allPages []PhysicalDisk
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SledPhysicalDiskList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// SiloIdentityProviderList: List a silo's IDPs_name
//
// To iterate over all pages, use the `SiloIdentityProviderListAllPages` method, instead.
func (c *Client) SiloIdentityProviderList(params SiloIdentityProviderListParams) (*IdentityProviderResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/identity-providers"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"silo":       string(params.Silo),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IdentityProviderResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloIdentityProviderListAllPages: List a silo's IDPs_name
//
// This method is a wrapper around the `SiloIdentityProviderList` method.
// This method returns all the pages at once.
func (c *Client) SiloIdentityProviderListAllPages(params SiloIdentityProviderListParams) (*[]IdentityProvider, error) {
	var allPages []IdentityProvider
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SiloIdentityProviderList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// LocalIdpUserCreate: Create a user
// Users can only be created in Silos with `provision_type` == `Fixed`. Otherwise, Silo users are just-in-time (JIT) provisioned when a user first logs in using an external Identity Provider.
func (c *Client) LocalIdpUserCreate(params LocalIdpUserCreateParams) (*User, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/identity-providers/local/users"),
		map[string]string{},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// LocalIdpUserDelete: Delete a user
func (c *Client) LocalIdpUserDelete(params LocalIdpUserDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/system/identity-providers/local/users/{{.user_id}}"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// LocalIdpUserSetPassword: Set or invalidate a user's password
// Passwords can only be updated for users in Silos with identity mode `LocalOnly`.
func (c *Client) LocalIdpUserSetPassword(params LocalIdpUserSetPasswordParams) error {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/identity-providers/local/users/{{.user_id}}/set-password"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SamlIdentityProviderCreate: Create a SAML IDP
func (c *Client) SamlIdentityProviderCreate(params SamlIdentityProviderCreateParams) (*SamlIdentityProvider, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/identity-providers/saml"),
		map[string]string{},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SamlIdentityProvider
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SamlIdentityProviderView: Fetch a SAML IDP
func (c *Client) SamlIdentityProviderView(params SamlIdentityProviderViewParams) (*SamlIdentityProvider, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/identity-providers/saml/{{.provider}}"),
		map[string]string{
			"provider": string(params.Provider),
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SamlIdentityProvider
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolList: List IP pools
//
// To iterate over all pages, use the `IpPoolListAllPages` method, instead.
func (c *Client) IpPoolList(params IpPoolListParams) (*IpPoolResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/ip-pools"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolListAllPages: List IP pools
//
// This method is a wrapper around the `IpPoolList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolListAllPages(params IpPoolListParams) (*[]IpPool, error) {
	var allPages []IpPool
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.IpPoolList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// IpPoolCreate: Create an IP pool
func (c *Client) IpPoolCreate(params IpPoolCreateParams) (*IpPool, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/ip-pools"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceView: Fetch the IP pool used for Oxide services.
func (c *Client) IpPoolServiceView() (*IpPool, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/ip-pools-service"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeList: List ranges for the IP pool used for Oxide services.
// Ranges are ordered by their first address.
//
// To iterate over all pages, use the `IpPoolServiceRangeListAllPages` method, instead.
func (c *Client) IpPoolServiceRangeList(params IpPoolServiceRangeListParams) (*IpPoolRangeResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/ip-pools-service/ranges"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRangeResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeListAllPages: List ranges for the IP pool used for Oxide services.
// Ranges are ordered by their first address.
//
// This method is a wrapper around the `IpPoolServiceRangeList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolServiceRangeListAllPages(params IpPoolServiceRangeListParams) (*[]IpPoolRange, error) {
	var allPages []IpPoolRange
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.IpPoolServiceRangeList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// IpPoolServiceRangeAdd: Add a range to an IP pool used for Oxide services.
func (c *Client) IpPoolServiceRangeAdd(params IpPoolServiceRangeAddParams) (*IpPoolRange, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/ip-pools-service/ranges/add"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRange
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeRemove: Remove a range from an IP pool used for Oxide services.
func (c *Client) IpPoolServiceRangeRemove(params IpPoolServiceRangeRemoveParams) error {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/ip-pools-service/ranges/remove"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolView: Fetch an IP pool
func (c *Client) IpPoolView(params IpPoolViewParams) (*IpPool, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolUpdate: Update an IP Pool
func (c *Client) IpPoolUpdate(params IpPoolUpdateParams) (*IpPool, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/system/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolDelete: Delete an IP Pool
func (c *Client) IpPoolDelete(params IpPoolDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/system/ip-pools/{{.pool}}"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolRangeList: List ranges for an IP pool
// Ranges are ordered by their first address.
//
// To iterate over all pages, use the `IpPoolRangeListAllPages` method, instead.
func (c *Client) IpPoolRangeList(params IpPoolRangeListParams) (*IpPoolRangeResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/ip-pools/{{.pool}}/ranges"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRangeResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolRangeListAllPages: List ranges for an IP pool
// Ranges are ordered by their first address.
//
// This method is a wrapper around the `IpPoolRangeList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolRangeListAllPages(params IpPoolRangeListParams) (*[]IpPoolRange, error) {
	var allPages []IpPoolRange
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.IpPoolRangeList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// IpPoolRangeAdd: Add a range to an IP pool
func (c *Client) IpPoolRangeAdd(params IpPoolRangeAddParams) (*IpPoolRange, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/ip-pools/{{.pool}}/ranges/add"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRange
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolRangeRemove: Remove a range from an IP pool
func (c *Client) IpPoolRangeRemove(params IpPoolRangeRemoveParams) error {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/ip-pools/{{.pool}}/ranges/remove"),
		map[string]string{
			"pool": string(params.Pool),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemMetric: Access metrics data
//
// To iterate over all pages, use the `SystemMetricAllPages` method, instead.
func (c *Client) SystemMetric(params SystemMetricParams) (*MeasurementResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/metrics/{{.metric_name}}"),
		map[string]string{
			"metric_name": string(params.MetricName),
		},
		map[string]string{
			"end_time":   params.EndTime.String(),
			"id":         params.Id,
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"start_time": params.StartTime.String(),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body MeasurementResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemMetricAllPages: Access metrics data
//
// This method is a wrapper around the `SystemMetric` method.
// This method returns all the pages at once.
func (c *Client) SystemMetricAllPages(params SystemMetricParams) (*[]Measurement, error) {
	var allPages []Measurement
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SystemMetric(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemPolicyView: Fetch the top-level IAM policy
func (c *Client) SystemPolicyView() (*FleetRolePolicy, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemPolicyUpdate: Update the top-level IAM policy
func (c *Client) SystemPolicyUpdate(params SystemPolicyUpdateParams) (*FleetRolePolicy, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/system/policy"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RoleList: List built-in roles
//
// To iterate over all pages, use the `RoleListAllPages` method, instead.
func (c *Client) RoleList(params RoleListParams) (*RoleResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/roles"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RoleResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RoleListAllPages: List built-in roles
//
// This method is a wrapper around the `RoleList` method.
// This method returns all the pages at once.
func (c *Client) RoleListAllPages(params RoleListParams) (*[]Role, error) {
	var allPages []Role
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.RoleList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// RoleView: Fetch a built-in role
func (c *Client) RoleView(params RoleViewParams) (*Role, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/roles/{{.role_name}}"),
		map[string]string{
			"role_name": params.RoleName,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Role
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SagaList: List sagas
//
// To iterate over all pages, use the `SagaListAllPages` method, instead.
func (c *Client) SagaList(params SagaListParams) (*SagaResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/sagas"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SagaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SagaListAllPages: List sagas
//
// This method is a wrapper around the `SagaList` method.
// This method returns all the pages at once.
func (c *Client) SagaListAllPages(params SagaListParams) (*[]Saga, error) {
	var allPages []Saga
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SagaList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// SagaView: Fetch a saga
func (c *Client) SagaView(params SagaViewParams) (*Saga, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/sagas/{{.saga_id}}"),
		map[string]string{
			"saga_id": params.SagaId,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Saga
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloList: List silos
// Lists silos that are discoverable based on the current permissions.
//
// To iterate over all pages, use the `SiloListAllPages` method, instead.
func (c *Client) SiloList(params SiloListParams) (*SiloResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/silos"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloListAllPages: List silos
// Lists silos that are discoverable based on the current permissions.
//
// This method is a wrapper around the `SiloList` method.
// This method returns all the pages at once.
func (c *Client) SiloListAllPages(params SiloListParams) (*[]Silo, error) {
	var allPages []Silo
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SiloList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// SiloCreate: Create a silo
func (c *Client) SiloCreate(params SiloCreateParams) (*Silo, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/silos"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Silo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloView: Fetch a silo
// Fetch a silo by name.
func (c *Client) SiloView(params SiloViewParams) (*Silo, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/silos/{{.silo}}"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Silo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloDelete: Delete a silo
// Delete a silo by name.
func (c *Client) SiloDelete(params SiloDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/system/silos/{{.silo}}"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SiloPolicyView: Fetch a silo's IAM policy
func (c *Client) SiloPolicyView(params SiloPolicyViewParams) (*SiloRolePolicy, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/silos/{{.silo}}/policy"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloPolicyUpdate: Update a silo's IAM policy
func (c *Client) SiloPolicyUpdate(params SiloPolicyUpdateParams) (*SiloRolePolicy, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/system/silos/{{.silo}}/policy"),
		map[string]string{
			"silo": string(params.Silo),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemComponentVersionList: View version and update status of component tree
//
// To iterate over all pages, use the `SystemComponentVersionListAllPages` method, instead.
func (c *Client) SystemComponentVersionList(params SystemComponentVersionListParams) (*UpdateableComponentResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/update/components"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateableComponentResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemComponentVersionListAllPages: View version and update status of component tree
//
// This method is a wrapper around the `SystemComponentVersionList` method.
// This method returns all the pages at once.
func (c *Client) SystemComponentVersionListAllPages(params SystemComponentVersionListParams) (*[]UpdateableComponent, error) {
	var allPages []UpdateableComponent
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SystemComponentVersionList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// UpdateDeploymentsList: List all update deployments
//
// To iterate over all pages, use the `UpdateDeploymentsListAllPages` method, instead.
func (c *Client) UpdateDeploymentsList(params UpdateDeploymentsListParams) (*UpdateDeploymentResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/update/deployments"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateDeploymentResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UpdateDeploymentsListAllPages: List all update deployments
//
// This method is a wrapper around the `UpdateDeploymentsList` method.
// This method returns all the pages at once.
func (c *Client) UpdateDeploymentsListAllPages(params UpdateDeploymentsListParams) (*[]UpdateDeployment, error) {
	var allPages []UpdateDeployment
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.UpdateDeploymentsList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// UpdateDeploymentView: Fetch a system update deployment
func (c *Client) UpdateDeploymentView(params UpdateDeploymentViewParams) (*UpdateDeployment, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/update/deployments/{{.id}}"),
		map[string]string{
			"id": params.Id,
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateDeployment
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateRefresh: Refresh update data
func (c *Client) SystemUpdateRefresh() error {
	// Create the request
	req, err := buildRequest(
		nil,
		"POST",
		resolveRelative(c.server, "/v1/system/update/refresh"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemUpdateStart: Start system update
func (c *Client) SystemUpdateStart(params SystemUpdateStartParams) (*UpdateDeployment, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/system/update/start"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateDeployment
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateStop: Stop system update
// If there is no update in progress, do nothing.
func (c *Client) SystemUpdateStop() error {
	// Create the request
	req, err := buildRequest(
		nil,
		"POST",
		resolveRelative(c.server, "/v1/system/update/stop"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemUpdateList: List all updates
//
// To iterate over all pages, use the `SystemUpdateListAllPages` method, instead.
func (c *Client) SystemUpdateList(params SystemUpdateListParams) (*SystemUpdateResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/update/updates"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SystemUpdateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateListAllPages: List all updates
//
// This method is a wrapper around the `SystemUpdateList` method.
// This method returns all the pages at once.
func (c *Client) SystemUpdateListAllPages(params SystemUpdateListParams) (*[]SystemUpdate, error) {
	var allPages []SystemUpdate
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SystemUpdateList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemUpdateView: View system update
func (c *Client) SystemUpdateView(params SystemUpdateViewParams) (*SystemUpdate, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/update/updates/{{.version}}"),
		map[string]string{
			"version": string(params.Version),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SystemUpdate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateComponentsList: View system update component tree
func (c *Client) SystemUpdateComponentsList(params SystemUpdateComponentsListParams) (*ComponentUpdateResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/update/updates/{{.version}}/components"),
		map[string]string{
			"version": string(params.Version),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ComponentUpdateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemVersion: View system version and update status
func (c *Client) SystemVersion() (*SystemVersion, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/update/version"),
		map[string]string{},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SystemVersion
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUserList: List users in a silo
//
// To iterate over all pages, use the `SiloUserListAllPages` method, instead.
func (c *Client) SiloUserList(params SiloUserListParams) (*UserResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/users"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"silo":       string(params.Silo),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUserListAllPages: List users in a silo
//
// This method is a wrapper around the `SiloUserList` method.
// This method returns all the pages at once.
func (c *Client) SiloUserListAllPages(params SiloUserListParams) (*[]User, error) {
	var allPages []User
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.SiloUserList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// UserBuiltinList: List built-in users
//
// To iterate over all pages, use the `UserBuiltinListAllPages` method, instead.
func (c *Client) UserBuiltinList(params UserBuiltinListParams) (*UserBuiltinResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/users-builtin"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserBuiltinResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserBuiltinListAllPages: List built-in users
//
// This method is a wrapper around the `UserBuiltinList` method.
// This method returns all the pages at once.
func (c *Client) UserBuiltinListAllPages(params UserBuiltinListParams) (*[]UserBuiltin, error) {
	var allPages []UserBuiltin
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.UserBuiltinList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// UserBuiltinView: Fetch a built-in user
func (c *Client) UserBuiltinView(params UserBuiltinViewParams) (*UserBuiltin, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/users-builtin/{{.user}}"),
		map[string]string{
			"user": string(params.User),
		},
		map[string]string{},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserBuiltin
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUserView: Fetch a user
func (c *Client) SiloUserView(params SiloUserViewParams) (*User, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/system/users/{{.user_id}}"),
		map[string]string{
			"user_id": params.UserId,
		},
		map[string]string{
			"silo": string(params.Silo),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserList: List users
//
// To iterate over all pages, use the `UserListAllPages` method, instead.
func (c *Client) UserList(params UserListParams) (*UserResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/users"),
		map[string]string{},
		map[string]string{
			"group":      params.Group,
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserListAllPages: List users
//
// This method is a wrapper around the `UserList` method.
// This method returns all the pages at once.
func (c *Client) UserListAllPages(params UserListParams) (*[]User, error) {
	var allPages []User
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.UserList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcFirewallRulesView: List firewall rules
func (c *Client) VpcFirewallRulesView(params VpcFirewallRulesViewParams) (*VpcFirewallRules, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpc-firewall-rules"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcFirewallRulesUpdate: Replace firewall rules
func (c *Client) VpcFirewallRulesUpdate(params VpcFirewallRulesUpdateParams) (*VpcFirewallRules, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/vpc-firewall-rules"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteList: List routes
// List the routes associated with a router in a particular VPC.
//
// To iterate over all pages, use the `VpcRouterRouteListAllPages` method, instead.
func (c *Client) VpcRouterRouteList(params VpcRouterRouteListParams) (*RouterRouteResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpc-router-routes"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"router":     string(params.Router),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRouteResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteListAllPages: List routes
// List the routes associated with a router in a particular VPC.
//
// This method is a wrapper around the `VpcRouterRouteList` method.
// This method returns all the pages at once.
func (c *Client) VpcRouterRouteListAllPages(params VpcRouterRouteListParams) (*[]RouterRoute, error) {
	var allPages []RouterRoute
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcRouterRouteList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcRouterRouteCreate: Create a router
func (c *Client) VpcRouterRouteCreate(params VpcRouterRouteCreateParams) (*RouterRoute, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/vpc-router-routes"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteView: Fetch a route
func (c *Client) VpcRouterRouteView(params VpcRouterRouteViewParams) (*RouterRoute, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpc-router-routes/{{.route}}"),
		map[string]string{
			"route": string(params.Route),
		},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteUpdate: Update a route
func (c *Client) VpcRouterRouteUpdate(params VpcRouterRouteUpdateParams) (*RouterRoute, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/vpc-router-routes/{{.route}}"),
		map[string]string{
			"route": string(params.Route),
		},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteDelete: Delete a route
func (c *Client) VpcRouterRouteDelete(params VpcRouterRouteDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/vpc-router-routes/{{.route}}"),
		map[string]string{
			"route": string(params.Route),
		},
		map[string]string{
			"project": string(params.Project),
			"router":  string(params.Router),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcRouterList: List routers
//
// To iterate over all pages, use the `VpcRouterListAllPages` method, instead.
func (c *Client) VpcRouterList(params VpcRouterListParams) (*VpcRouterResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpc-routers"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouterResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterListAllPages: List routers
//
// This method is a wrapper around the `VpcRouterList` method.
// This method returns all the pages at once.
func (c *Client) VpcRouterListAllPages(params VpcRouterListParams) (*[]VpcRouter, error) {
	var allPages []VpcRouter
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcRouterList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcRouterCreate: Create a VPC router
func (c *Client) VpcRouterCreate(params VpcRouterCreateParams) (*VpcRouter, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/vpc-routers"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterView: Get a router
func (c *Client) VpcRouterView(params VpcRouterViewParams) (*VpcRouter, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpc-routers/{{.router}}"),
		map[string]string{
			"router": string(params.Router),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterUpdate: Update a router
func (c *Client) VpcRouterUpdate(params VpcRouterUpdateParams) (*VpcRouter, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/vpc-routers/{{.router}}"),
		map[string]string{
			"router": string(params.Router),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterDelete: Delete a router
func (c *Client) VpcRouterDelete(params VpcRouterDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/vpc-routers/{{.router}}"),
		map[string]string{
			"router": string(params.Router),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcSubnetList: Fetch a subnet
//
// To iterate over all pages, use the `VpcSubnetListAllPages` method, instead.
func (c *Client) VpcSubnetList(params VpcSubnetListParams) (*VpcSubnetResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpc-subnets"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnetResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetListAllPages: Fetch a subnet
//
// This method is a wrapper around the `VpcSubnetList` method.
// This method returns all the pages at once.
func (c *Client) VpcSubnetListAllPages(params VpcSubnetListParams) (*[]VpcSubnet, error) {
	var allPages []VpcSubnet
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcSubnetList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcSubnetCreate: Create a subnet
func (c *Client) VpcSubnetCreate(params VpcSubnetCreateParams) (*VpcSubnet, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/vpc-subnets"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetView: Fetch a subnet
func (c *Client) VpcSubnetView(params VpcSubnetViewParams) (*VpcSubnet, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpc-subnets/{{.subnet}}"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetUpdate: Update a subnet
func (c *Client) VpcSubnetUpdate(params VpcSubnetUpdateParams) (*VpcSubnet, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/vpc-subnets/{{.subnet}}"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetDelete: Delete a subnet
func (c *Client) VpcSubnetDelete(params VpcSubnetDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/vpc-subnets/{{.subnet}}"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"project": string(params.Project),
			"vpc":     string(params.Vpc),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcSubnetListNetworkInterfaces: List network interfaces
//
// To iterate over all pages, use the `VpcSubnetListNetworkInterfacesAllPages` method, instead.
func (c *Client) VpcSubnetListNetworkInterfaces(params VpcSubnetListNetworkInterfacesParams) (*NetworkInterfaceResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpc-subnets/{{.subnet}}/network-interfaces"),
		map[string]string{
			"subnet": string(params.Subnet),
		},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
			"vpc":        string(params.Vpc),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetListNetworkInterfacesAllPages: List network interfaces
//
// This method is a wrapper around the `VpcSubnetListNetworkInterfaces` method.
// This method returns all the pages at once.
func (c *Client) VpcSubnetListNetworkInterfacesAllPages(params VpcSubnetListNetworkInterfacesParams) (*[]NetworkInterface, error) {
	var allPages []NetworkInterface
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcSubnetListNetworkInterfaces(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcList: List VPCs
//
// To iterate over all pages, use the `VpcListAllPages` method, instead.
func (c *Client) VpcList(params VpcListParams) (*VpcResultsPage, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpcs"),
		map[string]string{},
		map[string]string{
			"limit":      strconv.Itoa(params.Limit),
			"page_token": params.PageToken,
			"project":    string(params.Project),
			"sort_by":    string(params.SortBy),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcListAllPages: List VPCs
//
// This method is a wrapper around the `VpcList` method.
// This method returns all the pages at once.
func (c *Client) VpcListAllPages(params VpcListParams) (*[]Vpc, error) {
	var allPages []Vpc
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.VpcList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcCreate: Create a VPC
func (c *Client) VpcCreate(params VpcCreateParams) (*Vpc, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"POST",
		resolveRelative(c.server, "/v1/vpcs"),
		map[string]string{},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcView: Fetch a VPC
func (c *Client) VpcView(params VpcViewParams) (*Vpc, error) {
	// Create the request
	req, err := buildRequest(
		nil,
		"GET",
		resolveRelative(c.server, "/v1/vpcs/{{.vpc}}"),
		map[string]string{
			"vpc": string(params.Vpc),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcUpdate: Update a VPC
func (c *Client) VpcUpdate(params VpcUpdateParams) (*Vpc, error) {
	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(params.Body); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request
	req, err := buildRequest(
		b,
		"PUT",
		resolveRelative(c.server, "/v1/vpcs/{{.vpc}}"),
		map[string]string{
			"vpc": string(params.Vpc),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcDelete: Delete a VPC
func (c *Client) VpcDelete(params VpcDeleteParams) error {
	// Create the request
	req, err := buildRequest(
		nil,
		"DELETE",
		resolveRelative(c.server, "/v1/vpcs/{{.vpc}}"),
		map[string]string{
			"vpc": string(params.Vpc),
		},
		map[string]string{
			"project": string(params.Project),
		},
	)
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}
