// Code generated by `generate`. DO NOT EDIT.

package oxide

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strconv"
	"time"
)

// DiskViewById: Fetch a disk by id
// Use `GET /v1/disks/{disk}` instead
//
// Parameters
// - `id`
func (c *Client) DiskViewById(id string) (*Disk, error) {
	// Create the url.
	path := "/by-id/disks/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageViewById: Fetch an image by id
//
// Parameters
// - `id`
func (c *Client) ImageViewById(id string) (*Image, error) {
	// Create the url.
	path := "/by-id/images/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceViewById: Fetch an instance by id
// Use `GET /v1/instances/{instance}` instead
//
// Parameters
// - `id`
func (c *Client) InstanceViewById(id string) (*Instance, error) {
	// Create the url.
	path := "/by-id/instances/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceViewById: Fetch a network interface by id
// Use `GET /v1/network-interfaces/{interface}` instead
//
// Parameters
// - `id`
func (c *Client) InstanceNetworkInterfaceViewById(id string) (*NetworkInterface, error) {
	// Create the url.
	path := "/by-id/network-interfaces/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationViewById: Fetch an organization by id
// Use `GET /v1/organizations/{organization}` instead
//
// Parameters
// - `id`
func (c *Client) OrganizationViewById(id string) (*Organization, error) {
	// Create the url.
	path := "/by-id/organizations/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectViewById: Fetch a project by id
// Use `GET /v1/projects/{project}` instead
//
// Parameters
// - `id`
func (c *Client) ProjectViewById(id string) (*Project, error) {
	// Create the url.
	path := "/by-id/projects/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotViewById: Fetch a snapshot by id
// Use `GET /v1/snapshots/{snapshot}` instead.
//
// Parameters
// - `id`
func (c *Client) SnapshotViewById(id string) (*Snapshot, error) {
	// Create the url.
	path := "/by-id/snapshots/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteViewById: Fetch a route by id
// Use `GET /v1/vpc-router-routes/{route}` instead
//
// Parameters
// - `id`
func (c *Client) VpcRouterRouteViewById(id string) (*RouterRoute, error) {
	// Create the url.
	path := "/by-id/vpc-router-routes/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterViewById: Get a router by id
// Use `GET /v1/vpc-routers/{router}` instead
//
// Parameters
// - `id`
func (c *Client) VpcRouterViewById(id string) (*VpcRouter, error) {
	// Create the url.
	path := "/by-id/vpc-routers/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetViewById: Fetch a subnet by id
// Use `GET /v1/vpc-subnets/{id}` instead
//
// Parameters
// - `id`
func (c *Client) VpcSubnetViewById(id string) (*VpcSubnet, error) {
	// Create the url.
	path := "/by-id/vpc-subnets/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcViewById: Fetch a VPC
// Use `GET /v1/vpcs/{id}` instead
//
// Parameters
// - `id`
func (c *Client) VpcViewById(id string) (*Vpc, error) {
	// Create the url.
	path := "/by-id/vpcs/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// GroupList: List groups
//
// To iterate over all pages, use the `GroupListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) GroupList(limit int, pageToken string, sortBy IdSortMode) (*GroupResultsPage, error) {
	// Create the url.
	path := "/groups"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GroupResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// GroupListAllPages: List groups
//
// This method is a wrapper around the `GroupList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) GroupListAllPages(sortBy IdSortMode) (*[]Group, error) {
	var allPages []Group
	pageToken := ""
	limit := 100
	for {
		page, err := c.GroupList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// LoginLocal: Authenticate a user (i.e., log in) via username and password
//
// Parameters
// - `siloName`
func (c *Client) LoginLocal(siloName Name, j *UsernamePasswordCredentials) error {
	// Create the url.
	path := "/login/{{.silo_name}}/local"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// LoginSamlBegin: Prompt user login
// Either display a page asking a user for their credentials, or redirect them to their identity provider.
//
// Parameters
// - `providerName`
// - `siloName`
func (c *Client) LoginSamlBegin(providerName Name, siloName Name) error {
	// Create the url.
	path := "/login/{{.silo_name}}/saml/{{.provider_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider_name": string(providerName),
		"silo_name":     string(siloName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// LoginSaml: Authenticate a user (i.e., log in) via SAML
//
// Parameters
// - `providerName`
// - `siloName`
func (c *Client) LoginSaml(providerName Name, siloName Name, b io.Reader) error {
	// Create the url.
	path := "/login/{{.silo_name}}/saml/{{.provider_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider_name": string(providerName),
		"silo_name":     string(siloName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// OrganizationList: List organizations
// Use `GET /v1/organizations` instead
//
// To iterate over all pages, use the `OrganizationListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) OrganizationList(limit int, pageToken string, sortBy NameOrIdSortMode) (*OrganizationResultsPage, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OrganizationResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationListAllPages: List organizations
// Use `GET /v1/organizations` instead
//
// This method is a wrapper around the `OrganizationList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) OrganizationListAllPages(sortBy NameOrIdSortMode) (*[]Organization, error) {
	var allPages []Organization
	pageToken := ""
	limit := 100
	for {
		page, err := c.OrganizationList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// OrganizationCreate: Create an organization
// Use `POST /v1/organizations` instead
func (c *Client) OrganizationCreate(j *OrganizationCreate) (*Organization, error) {
	// Create the url.
	path := "/organizations"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationView: Fetch an organization
// Use `GET /v1/organizations/{organization}` instead
//
// Parameters
// - `organizationName` The organization's unique name.
func (c *Client) OrganizationView(organizationName Name) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationUpdate: Update an organization
// Use `PUT /v1/organizations/{organization}` instead
//
// Parameters
// - `organizationName` The organization's unique name.
func (c *Client) OrganizationUpdate(organizationName Name, j *OrganizationUpdate) (*Organization, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationDelete: Delete an organization
// Use `DELETE /v1/organizations/{organization}` instead
//
// Parameters
// - `organizationName` The organization's unique name.
func (c *Client) OrganizationDelete(organizationName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// OrganizationPolicyView: Fetch an organization's IAM policy
// Use `GET /v1/organizations/{organization}/policy` instead
//
// Parameters
// - `organizationName` The organization's unique name.
func (c *Client) OrganizationPolicyView(organizationName Name) (*OrganizationRolePolicy, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OrganizationRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationPolicyUpdate: Update an organization's IAM policy
// Use `PUT /v1/organizations/{organization}/policy` instead
//
// Parameters
// - `organizationName` The organization's unique name.
func (c *Client) OrganizationPolicyUpdate(organizationName Name, j *OrganizationRolePolicy) (*OrganizationRolePolicy, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OrganizationRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectList: List projects
// Use `GET /v1/projects` instead
//
// To iterate over all pages, use the `ProjectListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName` The organization's unique name.
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) ProjectList(limit int, pageToken string, sortBy NameOrIdSortMode, organizationName Name) (*ProjectResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectListAllPages: List projects
// Use `GET /v1/projects` instead
//
// This method is a wrapper around the `ProjectList` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName` The organization's unique name.
// - `sortBy`
func (c *Client) ProjectListAllPages(sortBy NameOrIdSortMode, organizationName Name) (*[]Project, error) {
	var allPages []Project
	pageToken := ""
	limit := 100
	for {
		page, err := c.ProjectList(limit, pageToken, sortBy, organizationName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// ProjectCreate: Create a project
// Use `POST /v1/projects` instead
//
// Parameters
// - `organizationName` The organization's unique name.
func (c *Client) ProjectCreate(organizationName Name, j *ProjectCreate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectView: Fetch a project
// Use `GET /v1/projects/{project}` instead
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) ProjectView(organizationName Name, projectName Name) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectUpdate: Update a project
// Use `PUT /v1/projects/{project}` instead
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) ProjectUpdate(organizationName Name, projectName Name, j *ProjectUpdate) (*Project, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectDelete: Delete a project
// Use `DELETE /v1/projects/{project}` instead
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) ProjectDelete(organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// DiskList: List disks
// Use `GET /v1/disks` instead
//
// To iterate over all pages, use the `DiskListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName` The organization's unique name.
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) DiskList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskListAllPages: List disks
// Use `GET /v1/disks` instead
//
// This method is a wrapper around the `DiskList` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) DiskListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Disk, error) {
	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := c.DiskList(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// DiskCreate: Use `POST /v1/disks` instead
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) DiskCreate(organizationName Name, projectName Name, j *DiskCreate) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskView: Fetch a disk
// Use `GET /v1/disks/{disk}` instead
//
// Parameters
// - `diskName`
// - `organizationName`
// - `projectName`
func (c *Client) DiskView(diskName Name, organizationName Name, projectName Name) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk_name":         string(diskName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskDelete: Use `DELETE /v1/disks/{disk}` instead
//
// Parameters
// - `diskName`
// - `organizationName`
// - `projectName`
func (c *Client) DiskDelete(diskName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk_name":         string(diskName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// DiskMetricsList: Fetch disk metrics
//
// To iterate over all pages, use the `DiskMetricsListAllPages` method, instead.
//
// Parameters
// - `diskName`
// - `endTime` An exclusive end time of metrics.
// - `limit` Maximum number of items returned by a single call
// - `metricName`
// - `organizationName`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName`
// - `startTime` An inclusive start time of metrics.
func (c *Client) DiskMetricsList(diskName Name, metricName DiskMetricName, organizationName Name, projectName Name, endTime *time.Time, limit int, pageToken string, startTime *time.Time) (*MeasurementResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/disks/{{.disk_name}}/metrics/{{.metric_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk_name":         string(diskName),
		"metric_name":       string(metricName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"end_time":   endTime.String(),
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"start_time": startTime.String(),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body MeasurementResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskMetricsListAllPages: Fetch disk metrics
//
// This method is a wrapper around the `DiskMetricsList` method.
// This method returns all the pages at once.
//
// Parameters
// - `diskName`
// - `endTime` An exclusive end time of metrics.
// - `metricName`
// - `organizationName`
// - `projectName`
// - `startTime` An inclusive start time of metrics.
func (c *Client) DiskMetricsListAllPages(diskName Name, metricName DiskMetricName, organizationName Name, projectName Name, endTime *time.Time, startTime *time.Time) (*[]Measurement, error) {
	var allPages []Measurement
	pageToken := ""
	limit := 100
	for {
		page, err := c.DiskMetricsList(diskName, metricName, organizationName, projectName, endTime, limit, pageToken, startTime)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// ImageList: List images
// List images in a project. The images are returned sorted by creation date, with the most recent images appearing first.
//
// To iterate over all pages, use the `ImageListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName` The organization's unique name.
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) ImageList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*ImageResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/images"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ImageResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageListAllPages: List images
// List images in a project. The images are returned sorted by creation date, with the most recent images appearing first.
//
// This method is a wrapper around the `ImageList` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) ImageListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Image, error) {
	var allPages []Image
	pageToken := ""
	limit := 100
	for {
		page, err := c.ImageList(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// ImageCreate: Create an image
// Create a new image in a project.
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) ImageCreate(organizationName Name, projectName Name, j *ImageCreate) (*Image, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/images"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageView: Fetch an image
// Fetch the details for a specific image in a project.
//
// Parameters
// - `imageName`
// - `organizationName`
// - `projectName`
func (c *Client) ImageView(imageName Name, organizationName Name, projectName Name) (*Image, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/images/{{.image_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"image_name":        string(imageName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Image
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ImageDelete: Delete an image
// Permanently delete an image from a project. This operation cannot be undone. Any instances in the project using the image will continue to run, however new instances can not be created with this image.
//
// Parameters
// - `imageName`
// - `organizationName`
// - `projectName`
func (c *Client) ImageDelete(imageName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/images/{{.image_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"image_name":        string(imageName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceList: List instances
// Use `GET /v1/instances` instead
//
// To iterate over all pages, use the `InstanceListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName` The organization's unique name.
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) InstanceList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*InstanceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceListAllPages: List instances
// Use `GET /v1/instances` instead
//
// This method is a wrapper around the `InstanceList` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) InstanceListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Instance, error) {
	var allPages []Instance
	pageToken := ""
	limit := 100
	for {
		page, err := c.InstanceList(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceCreate: Create an instance
// Use `POST /v1/instances` instead
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) InstanceCreate(organizationName Name, projectName Name, j *InstanceCreate) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceView: Fetch an instance
// Use `GET /v1/instances/{instance}` instead
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceView(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDelete: Delete an instance
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceDelete(instanceName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceDiskList: List an instance's disks
// Use `GET /v1/instances/{instance}/disks` instead
//
// To iterate over all pages, use the `InstanceDiskListAllPages` method, instead.
//
// Parameters
// - `instanceName`
// - `limit` Maximum number of items returned by a single call
// - `organizationName`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName`
// - `sortBy`
func (c *Client) InstanceDiskList(limit int, pageToken string, sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*DiskResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskListAllPages: List an instance's disks
// Use `GET /v1/instances/{instance}/disks` instead
//
// This method is a wrapper around the `InstanceDiskList` method.
// This method returns all the pages at once.
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
// - `sortBy`
func (c *Client) InstanceDiskListAllPages(sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*[]Disk, error) {
	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := c.InstanceDiskList(limit, pageToken, sortBy, instanceName, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceDiskAttach: Attach a disk to an instance
// Use `POST /v1/instances/{instance}/disks/attach` instead
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceDiskAttach(instanceName Name, organizationName Name, projectName Name, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/attach"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskDetach: Detach a disk from an instance
// Use `POST /v1/disks/{disk}/detach` instead
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceDiskDetach(instanceName Name, organizationName Name, projectName Name, j *DiskIdentifier) (*Disk, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/disks/detach"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceExternalIpList: List external IP addresses
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceExternalIpList(instanceName Name, organizationName Name, projectName Name) (*ExternalIpResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/external-ips"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ExternalIpResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceMigrate: Migrate an instance
// Use `POST /v1/instances/{instance}/migrate` instead
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceMigrate(instanceName Name, organizationName Name, projectName Name, j *InstanceMigrate) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/migrate"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceList: List network interfaces
// Use `GET /v1/network-interfaces` instead
//
// To iterate over all pages, use the `InstanceNetworkInterfaceListAllPages` method, instead.
//
// Parameters
// - `instanceName`
// - `limit` Maximum number of items returned by a single call
// - `organizationName`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName`
// - `sortBy`
func (c *Client) InstanceNetworkInterfaceList(limit int, pageToken string, sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*NetworkInterfaceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceListAllPages: List network interfaces
// Use `GET /v1/network-interfaces` instead
//
// This method is a wrapper around the `InstanceNetworkInterfaceList` method.
// This method returns all the pages at once.
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
// - `sortBy`
func (c *Client) InstanceNetworkInterfaceListAllPages(sortBy NameSortMode, instanceName Name, organizationName Name, projectName Name) (*[]NetworkInterface, error) {
	var allPages []NetworkInterface
	pageToken := ""
	limit := 100
	for {
		page, err := c.InstanceNetworkInterfaceList(limit, pageToken, sortBy, instanceName, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceNetworkInterfaceCreate: Create a network interface
// Use `POST /v1/network-interfaces` instead
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceNetworkInterfaceCreate(instanceName Name, organizationName Name, projectName Name, j *NetworkInterfaceCreate) (*NetworkInterface, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceView: Fetch a network interface
// Use `GET /v1/network-interfaces/{interface}` instead
//
// Parameters
// - `instanceName`
// - `interfaceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceNetworkInterfaceView(instanceName Name, interfaceName Name, organizationName Name, projectName Name) (*NetworkInterface, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces/{{.interface_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"interface_name":    string(interfaceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceUpdate: Update a network interface
// Use `PUT /v1/network-interfaces/{interface}` instead
//
// Parameters
// - `instanceName`
// - `interfaceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceNetworkInterfaceUpdate(instanceName Name, interfaceName Name, organizationName Name, projectName Name, j *NetworkInterfaceUpdate) (*NetworkInterface, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces/{{.interface_name}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"interface_name":    string(interfaceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceDelete: Delete a network interface
// Note that the primary interface for an instance cannot be deleted if there are any secondary interfaces. A new primary interface must be designated first. The primary interface can be deleted if there are no secondary interfaces.
// Use `DELETE /v1/network-interfaces/{interface}` instead
//
// Parameters
// - `instanceName`
// - `interfaceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceNetworkInterfaceDelete(instanceName Name, interfaceName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/network-interfaces/{{.interface_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"interface_name":    string(interfaceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceReboot: Reboot an instance
// Use `POST /v1/instances/{instance}/reboot` instead
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceReboot(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/reboot"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsole: Fetch an instance's serial console
// Use `GET /v1/instances/{instance}/serial-console` instead
//
// Parameters
// - `fromStart` Character index in the serial buffer from which to read, counting the bytes output since instance start. If this is not provided, `most_recent` must be provided, and if this *is* provided, `most_recent` must *not* be provided.
// - `instanceName`
// - `maxBytes` Maximum number of bytes of buffered serial console contents to return. If the requested range runs to the end of the available buffer, the data returned will be shorter than `max_bytes`.
// - `mostRecent` Character index in the serial buffer from which to read, counting *backward* from the most recently buffered data retrieved from the instance. (See note on `from_start` about mutual exclusivity)
// - `organizationName`
// - `projectName`
func (c *Client) InstanceSerialConsole(instanceName Name, organizationName Name, projectName Name, fromStart int, maxBytes int, mostRecent int) (*InstanceSerialConsoleData, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/serial-console"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"from_start":  strconv.Itoa(fromStart),
		"max_bytes":   strconv.Itoa(maxBytes),
		"most_recent": strconv.Itoa(mostRecent),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceSerialConsoleData
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsoleStream: Connect to an instance's serial console
// Use `GET /v1/instances/{instance}/serial-console/stream` instead
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceSerialConsoleStream(instanceName Name, organizationName Name, projectName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/serial-console/stream"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceStart: Boot an instance
// Use `POST /v1/instances/{instance}/start` instead
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceStart(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/start"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceStop: Halt an instance
// Use `POST /v1/instances/{instance}/stop` instead
//
// Parameters
// - `instanceName`
// - `organizationName`
// - `projectName`
func (c *Client) InstanceStop(instanceName Name, organizationName Name, projectName Name) (*Instance, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/instances/{{.instance_name}}/stop"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance_name":     string(instanceName),
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectPolicyView: Fetch a project's IAM policy
// Use `GET /v1/projects/{project}/policy` instead
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) ProjectPolicyView(organizationName Name, projectName Name) (*ProjectRolePolicy, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectPolicyUpdate: Update a project's IAM policy
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) ProjectPolicyUpdate(organizationName Name, projectName Name, j *ProjectRolePolicy) (*ProjectRolePolicy, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotList: List snapshots
// Use `GET /v1/snapshots` instead.
//
// To iterate over all pages, use the `SnapshotListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName` The organization's unique name.
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) SnapshotList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*SnapshotResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SnapshotResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotListAllPages: List snapshots
// Use `GET /v1/snapshots` instead.
//
// This method is a wrapper around the `SnapshotList` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) SnapshotListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Snapshot, error) {
	var allPages []Snapshot
	pageToken := ""
	limit := 100
	for {
		page, err := c.SnapshotList(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SnapshotCreate: Create a snapshot
// Use `POST /v1/snapshots` instead.
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) SnapshotCreate(organizationName Name, projectName Name, j *SnapshotCreate) (*Snapshot, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotView: Fetch a snapshot
// Use `GET /v1/snapshots/{snapshot}` instead.
//
// Parameters
// - `organizationName`
// - `projectName`
// - `snapshotName`
func (c *Client) SnapshotView(organizationName Name, projectName Name, snapshotName Name) (*Snapshot, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots/{{.snapshot_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"snapshot_name":     string(snapshotName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotDelete: Delete a snapshot
// Use `DELETE /v1/snapshots/{snapshot}` instead.
//
// Parameters
// - `organizationName`
// - `projectName`
// - `snapshotName`
func (c *Client) SnapshotDelete(organizationName Name, projectName Name, snapshotName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/snapshots/{{.snapshot_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"snapshot_name":     string(snapshotName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcList: List VPCs
// Use `GET /v1/vpcs` instead
//
// To iterate over all pages, use the `VpcListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName` The organization's unique name.
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) VpcList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name) (*VpcResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcListAllPages: List VPCs
// Use `GET /v1/vpcs` instead
//
// This method is a wrapper around the `VpcList` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
// - `sortBy`
func (c *Client) VpcListAllPages(sortBy NameSortMode, organizationName Name, projectName Name) (*[]Vpc, error) {
	var allPages []Vpc
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcList(limit, pageToken, sortBy, organizationName, projectName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcCreate: Create a VPC
// Use `POST /v1/vpcs` instead
//
// Parameters
// - `organizationName` The organization's unique name.
// - `projectName` The project's unique name within the organization.
func (c *Client) VpcCreate(organizationName Name, projectName Name, j *VpcCreate) (*Vpc, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcView: Fetch a VPC
// Use `GET /v1/vpcs/{vpc}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `vpcName`
func (c *Client) VpcView(organizationName Name, projectName Name, vpcName Name) (*Vpc, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcUpdate: Update a VPC
// Use `PUT /v1/vpcs/{vpc}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `vpcName`
func (c *Client) VpcUpdate(organizationName Name, projectName Name, vpcName Name, j *VpcUpdate) (*Vpc, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcDelete: Delete a VPC
// Use `DELETE /v1/vpcs/{vpc}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `vpcName`
func (c *Client) VpcDelete(organizationName Name, projectName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcFirewallRulesView: List firewall rules
// Use `GET /v1/vpc-firewall-rules` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `vpcName`
func (c *Client) VpcFirewallRulesView(organizationName Name, projectName Name, vpcName Name) (*VpcFirewallRules, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcFirewallRulesUpdate: Replace firewall rules
// Use `PUT /v1/vpc-firewall-rules` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `vpcName`
func (c *Client) VpcFirewallRulesUpdate(organizationName Name, projectName Name, vpcName Name, j *VpcFirewallRuleUpdateParams) (*VpcFirewallRules, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/firewall/rules"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterList: List routers
// Use `GET /v1/vpc-routers` instead
//
// To iterate over all pages, use the `VpcRouterListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName`
// - `sortBy`
// - `vpcName`
func (c *Client) VpcRouterList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*VpcRouterResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouterResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterListAllPages: List routers
// Use `GET /v1/vpc-routers` instead
//
// This method is a wrapper around the `VpcRouterList` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName`
// - `projectName`
// - `sortBy`
// - `vpcName`
func (c *Client) VpcRouterListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]VpcRouter, error) {
	var allPages []VpcRouter
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcRouterList(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcRouterCreate: Create a router
// Use `POST /v1/vpc-routers` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `vpcName`
func (c *Client) VpcRouterCreate(organizationName Name, projectName Name, vpcName Name, j *VpcRouterCreate) (*VpcRouter, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterView: Get a router
// Use `GET /v1/vpc-routers/{router}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `routerName`
// - `vpcName`
func (c *Client) VpcRouterView(organizationName Name, projectName Name, routerName Name, vpcName Name) (*VpcRouter, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterUpdate: Update a router
//
// Parameters
// - `organizationName`
// - `projectName`
// - `routerName`
// - `vpcName`
func (c *Client) VpcRouterUpdate(organizationName Name, projectName Name, routerName Name, vpcName Name, j *VpcRouterUpdate) (*VpcRouter, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterDelete: Delete a router
// Use `DELETE /v1/vpc-routers/{router}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `routerName`
// - `vpcName`
func (c *Client) VpcRouterDelete(organizationName Name, projectName Name, routerName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcRouterRouteList: List routes
// List the routes associated with a router in a particular VPC. Use `GET /v1/vpc-router-routes` instead.
//
// To iterate over all pages, use the `VpcRouterRouteListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName`
// - `routerName`
// - `sortBy`
// - `vpcName`
func (c *Client) VpcRouterRouteList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, routerName Name, vpcName Name) (*RouterRouteResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRouteResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteListAllPages: List routes
// List the routes associated with a router in a particular VPC. Use `GET /v1/vpc-router-routes` instead.
//
// This method is a wrapper around the `VpcRouterRouteList` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName`
// - `projectName`
// - `routerName`
// - `sortBy`
// - `vpcName`
func (c *Client) VpcRouterRouteListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, routerName Name, vpcName Name) (*[]RouterRoute, error) {
	var allPages []RouterRoute
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcRouterRouteList(limit, pageToken, sortBy, organizationName, projectName, routerName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcRouterRouteCreate: Create a router
// Use `POST /v1/vpc-router-routes` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `routerName`
// - `vpcName`
func (c *Client) VpcRouterRouteCreate(organizationName Name, projectName Name, routerName Name, vpcName Name, j *RouterRouteCreate) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteView: Fetch a route
// Use `GET /v1/vpc-router-routes/{route}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `routeName`
// - `routerName`
// - `vpcName`
func (c *Client) VpcRouterRouteView(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"route_name":        string(routeName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteUpdate: Update a route
// Use `PUT /v1/vpc-router-routes/{route}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `routeName`
// - `routerName`
// - `vpcName`
func (c *Client) VpcRouterRouteUpdate(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name, j *RouterRouteUpdate) (*RouterRoute, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"route_name":        string(routeName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteDelete: Delete a route
// Use `DELETE /v1/vpc-router-routes/{route}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `routeName`
// - `routerName`
// - `vpcName`
func (c *Client) VpcRouterRouteDelete(organizationName Name, projectName Name, routeName Name, routerName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/routers/{{.router_name}}/routes/{{.route_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"route_name":        string(routeName),
		"router_name":       string(routerName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcSubnetList: List subnets
// Use `GET /v1/vpc-subnets` instead
//
// To iterate over all pages, use the `VpcSubnetListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName`
// - `sortBy`
// - `vpcName`
func (c *Client) VpcSubnetList(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*VpcSubnetResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnetResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetListAllPages: List subnets
// Use `GET /v1/vpc-subnets` instead
//
// This method is a wrapper around the `VpcSubnetList` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName`
// - `projectName`
// - `sortBy`
// - `vpcName`
func (c *Client) VpcSubnetListAllPages(sortBy NameSortMode, organizationName Name, projectName Name, vpcName Name) (*[]VpcSubnet, error) {
	var allPages []VpcSubnet
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcSubnetList(limit, pageToken, sortBy, organizationName, projectName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcSubnetCreate: Create a subnet
// Use `POST /v1/vpc-subnets` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `vpcName`
func (c *Client) VpcSubnetCreate(organizationName Name, projectName Name, vpcName Name, j *VpcSubnetCreate) (*VpcSubnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetView: Fetch a subnet
// Use `GET /v1/vpc-subnets/{subnet}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `subnetName`
// - `vpcName`
func (c *Client) VpcSubnetView(organizationName Name, projectName Name, subnetName Name, vpcName Name) (*VpcSubnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"subnet_name":       string(subnetName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetUpdate: Update a subnet
// Use `PUT /v1/vpc-subnets/{subnet}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `subnetName`
// - `vpcName`
func (c *Client) VpcSubnetUpdate(organizationName Name, projectName Name, subnetName Name, vpcName Name, j *VpcSubnetUpdate) (*VpcSubnet, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"subnet_name":       string(subnetName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetDelete: Delete a subnet
// Use `DELETE /v1/vpc-subnets/{subnet}` instead
//
// Parameters
// - `organizationName`
// - `projectName`
// - `subnetName`
// - `vpcName`
func (c *Client) VpcSubnetDelete(organizationName Name, projectName Name, subnetName Name, vpcName Name) error {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"subnet_name":       string(subnetName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcSubnetListNetworkInterfaces: List network interfaces
//
// To iterate over all pages, use the `VpcSubnetListNetworkInterfacesAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organizationName`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `projectName`
// - `sortBy`
// - `subnetName`
// - `vpcName`
func (c *Client) VpcSubnetListNetworkInterfaces(limit int, pageToken string, sortBy NameSortMode, organizationName Name, projectName Name, subnetName Name, vpcName Name) (*NetworkInterfaceResultsPage, error) {
	// Create the url.
	path := "/organizations/{{.organization_name}}/projects/{{.project_name}}/vpcs/{{.vpc_name}}/subnets/{{.subnet_name}}/network-interfaces"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization_name": string(organizationName),
		"project_name":      string(projectName),
		"subnet_name":       string(subnetName),
		"vpc_name":          string(vpcName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetListNetworkInterfacesAllPages: List network interfaces
//
// This method is a wrapper around the `VpcSubnetListNetworkInterfaces` method.
// This method returns all the pages at once.
//
// Parameters
// - `organizationName`
// - `projectName`
// - `sortBy`
// - `subnetName`
// - `vpcName`
func (c *Client) VpcSubnetListNetworkInterfacesAllPages(sortBy NameSortMode, organizationName Name, projectName Name, subnetName Name, vpcName Name) (*[]NetworkInterface, error) {
	var allPages []NetworkInterface
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcSubnetListNetworkInterfaces(limit, pageToken, sortBy, organizationName, projectName, subnetName, vpcName)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// PolicyView: Fetch the current silo's IAM policy
// Use `GET /v1/policy` instead
func (c *Client) PolicyView() (*SiloRolePolicy, error) {
	// Create the url.
	path := "/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PolicyUpdate: Update the current silo's IAM policy
// Use `PUT /v1/policy` instead
func (c *Client) PolicyUpdate(j *SiloRolePolicy) (*SiloRolePolicy, error) {
	// Create the url.
	path := "/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RoleList: List built-in roles
//
// To iterate over all pages, use the `RoleListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
func (c *Client) RoleList(limit int, pageToken string) (*RoleResultsPage, error) {
	// Create the url.
	path := "/roles"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RoleResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RoleListAllPages: List built-in roles
//
// This method is a wrapper around the `RoleList` method.
// This method returns all the pages at once.
func (c *Client) RoleListAllPages() (*[]Role, error) {
	var allPages []Role
	pageToken := ""
	limit := 100
	for {
		page, err := c.RoleList(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// RoleView: Fetch a built-in role
//
// Parameters
// - `roleName` The built-in role's unique name.
func (c *Client) RoleView(roleName string) (*Role, error) {
	// Create the url.
	path := "/roles/{{.role_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"role_name": roleName,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Role
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SessionSshkeyList: List SSH public keys
// Lists SSH public keys for the currently authenticated user.
//
// To iterate over all pages, use the `SessionSshkeyListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SessionSshkeyList(limit int, pageToken string, sortBy NameSortMode) (*SshKeyResultsPage, error) {
	// Create the url.
	path := "/session/me/sshkeys"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKeyResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SessionSshkeyListAllPages: List SSH public keys
// Lists SSH public keys for the currently authenticated user.
//
// This method is a wrapper around the `SessionSshkeyList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SessionSshkeyListAllPages(sortBy NameSortMode) (*[]SshKey, error) {
	var allPages []SshKey
	pageToken := ""
	limit := 100
	for {
		page, err := c.SessionSshkeyList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SessionSshkeyCreate: Create an SSH public key
// Create an SSH public key for the currently authenticated user.
func (c *Client) SessionSshkeyCreate(j *SshKeyCreate) (*SshKey, error) {
	// Create the url.
	path := "/session/me/sshkeys"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKey
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SessionSshkeyView: Fetch an SSH public key
// Fetch an SSH public key associated with the currently authenticated user.
//
// Parameters
// - `sshKeyName`
func (c *Client) SessionSshkeyView(sshKeyName Name) (*SshKey, error) {
	// Create the url.
	path := "/session/me/sshkeys/{{.ssh_key_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"ssh_key_name": string(sshKeyName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SshKey
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SessionSshkeyDelete: Delete an SSH public key
// Delete an SSH public key associated with the currently authenticated user.
//
// Parameters
// - `sshKeyName`
func (c *Client) SessionSshkeyDelete(sshKeyName Name) error {
	// Create the url.
	path := "/session/me/sshkeys/{{.ssh_key_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"ssh_key_name": string(sshKeyName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemImageViewById: Fetch a system-wide image by id
//
// Parameters
// - `id`
func (c *Client) SystemImageViewById(id string) (*GlobalImage, error) {
	// Create the url.
	path := "/system/by-id/images/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GlobalImage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolViewById: Fetch an IP pool by id
//
// Parameters
// - `id`
func (c *Client) IpPoolViewById(id string) (*IpPool, error) {
	// Create the url.
	path := "/system/by-id/ip-pools/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloViewById: Fetch a silo by id
//
// Parameters
// - `id`
func (c *Client) SiloViewById(id string) (*Silo, error) {
	// Create the url.
	path := "/system/by-id/silos/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Silo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateList: List system-wide certificates
// Returns a list of all the system-wide certificates. System-wide certificates are returned sorted by creation date, with the most recent certificates appearing first. Use `GET /v1/system/certificates` instead
//
// To iterate over all pages, use the `CertificateListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) CertificateList(limit int, pageToken string, sortBy NameOrIdSortMode) (*CertificateResultsPage, error) {
	// Create the url.
	path := "/system/certificates"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body CertificateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateListAllPages: List system-wide certificates
// Returns a list of all the system-wide certificates. System-wide certificates are returned sorted by creation date, with the most recent certificates appearing first. Use `GET /v1/system/certificates` instead
//
// This method is a wrapper around the `CertificateList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) CertificateListAllPages(sortBy NameOrIdSortMode) (*[]Certificate, error) {
	var allPages []Certificate
	pageToken := ""
	limit := 100
	for {
		page, err := c.CertificateList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// CertificateCreate: Create a new system-wide x.509 certificate.
// This certificate is automatically used by the Oxide Control plane to serve external connections. Use `POST /v1/system/certificates` instead
func (c *Client) CertificateCreate(j *CertificateCreate) (*Certificate, error) {
	// Create the url.
	path := "/system/certificates"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateView: Fetch a certificate
// Returns the details of a specific certificate Use `GET /v1/system/certificates/{certificate}` instead
//
// Parameters
// - `certificate`
func (c *Client) CertificateView(certificate NameOrId) (*Certificate, error) {
	// Create the url.
	path := "/system/certificates/{{.certificate}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"certificate": certificate.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateDelete: Delete a certificate
// Permanently delete a certificate. This operation cannot be undone. Use `DELETE /v1/system/certificates/{certificate}` instead
//
// Parameters
// - `certificate`
func (c *Client) CertificateDelete(certificate NameOrId) error {
	// Create the url.
	path := "/system/certificates/{{.certificate}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"certificate": certificate.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// PhysicalDiskList: List physical disks
// Use `GET /v1/system/hardware/disks` instead
//
// To iterate over all pages, use the `PhysicalDiskListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) PhysicalDiskList(limit int, pageToken string, sortBy IdSortMode) (*PhysicalDiskResultsPage, error) {
	// Create the url.
	path := "/system/hardware/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PhysicalDiskListAllPages: List physical disks
// Use `GET /v1/system/hardware/disks` instead
//
// This method is a wrapper around the `PhysicalDiskList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) PhysicalDiskListAllPages(sortBy IdSortMode) (*[]PhysicalDisk, error) {
	var allPages []PhysicalDisk
	pageToken := ""
	limit := 100
	for {
		page, err := c.PhysicalDiskList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// RackList: List racks
// Use `GET /v1/system/hardware/racks` instead
//
// To iterate over all pages, use the `RackListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) RackList(limit int, pageToken string, sortBy IdSortMode) (*RackResultsPage, error) {
	// Create the url.
	path := "/system/hardware/racks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RackResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RackListAllPages: List racks
// Use `GET /v1/system/hardware/racks` instead
//
// This method is a wrapper around the `RackList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) RackListAllPages(sortBy IdSortMode) (*[]Rack, error) {
	var allPages []Rack
	pageToken := ""
	limit := 100
	for {
		page, err := c.RackList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// RackView: Fetch a rack
// Use `GET /v1/system/hardware/racks/{rack_id}` instead
//
// Parameters
// - `rackId` The rack's unique ID.
func (c *Client) RackView(rackId string) (*Rack, error) {
	// Create the url.
	path := "/system/hardware/racks/{{.rack_id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"rack_id": rackId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Rack
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledList: List sleds
// Use `GET /v1/system/hardware/sleds instead`
//
// To iterate over all pages, use the `SledListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SledList(limit int, pageToken string, sortBy IdSortMode) (*SledResultsPage, error) {
	// Create the url.
	path := "/system/hardware/sleds"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListAllPages: List sleds
// Use `GET /v1/system/hardware/sleds instead`
//
// This method is a wrapper around the `SledList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SledListAllPages(sortBy IdSortMode) (*[]Sled, error) {
	var allPages []Sled
	pageToken := ""
	limit := 100
	for {
		page, err := c.SledList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SledView: Fetch a sled
// Use `GET /v1/system/hardware/sleds/{sled_id}` instead
//
// Parameters
// - `sledId` The sled's unique ID.
func (c *Client) SledView(sledId string) (*Sled, error) {
	// Create the url.
	path := "/system/hardware/sleds/{{.sled_id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sled_id": sledId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Sled
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskList: List physical disks attached to sleds
// Use `GET /v1/system/hardware/sleds/{sled_id}/disks` instead
//
// To iterate over all pages, use the `SledPhysicalDiskListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sledId` The sled's unique ID.
// - `sortBy`
func (c *Client) SledPhysicalDiskList(sledId string, limit int, pageToken string, sortBy IdSortMode) (*PhysicalDiskResultsPage, error) {
	// Create the url.
	path := "/system/hardware/sleds/{{.sled_id}}/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sled_id": sledId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskListAllPages: List physical disks attached to sleds
// Use `GET /v1/system/hardware/sleds/{sled_id}/disks` instead
//
// This method is a wrapper around the `SledPhysicalDiskList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sledId` The sled's unique ID.
// - `sortBy`
func (c *Client) SledPhysicalDiskListAllPages(sledId string, sortBy IdSortMode) (*[]PhysicalDisk, error) {
	var allPages []PhysicalDisk
	pageToken := ""
	limit := 100
	for {
		page, err := c.SledPhysicalDiskList(sledId, limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemImageList: List system-wide images
// Returns a list of all the system-wide images. System-wide images are returned sorted by creation date, with the most recent images appearing first.
//
// To iterate over all pages, use the `SystemImageListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SystemImageList(limit int, pageToken string, sortBy NameSortMode) (*GlobalImageResultsPage, error) {
	// Create the url.
	path := "/system/images"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GlobalImageResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemImageListAllPages: List system-wide images
// Returns a list of all the system-wide images. System-wide images are returned sorted by creation date, with the most recent images appearing first.
//
// This method is a wrapper around the `SystemImageList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SystemImageListAllPages(sortBy NameSortMode) (*[]GlobalImage, error) {
	var allPages []GlobalImage
	pageToken := ""
	limit := 100
	for {
		page, err := c.SystemImageList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemImageCreate: Create a system-wide image
// Create a new system-wide image. This image can then be used by any user in any silo as a base for instances.
func (c *Client) SystemImageCreate(j *GlobalImageCreate) (*GlobalImage, error) {
	// Create the url.
	path := "/system/images"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GlobalImage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemImageView: Fetch a system-wide image
// Returns the details of a specific system-wide image.
//
// Parameters
// - `imageName`
func (c *Client) SystemImageView(imageName Name) (*GlobalImage, error) {
	// Create the url.
	path := "/system/images/{{.image_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"image_name": string(imageName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body GlobalImage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemImageDelete: Delete a system-wide image
// Permanently delete a system-wide image. This operation cannot be undone. Any instances using the system-wide image will continue to run, however new instances can not be created with this image.
//
// Parameters
// - `imageName`
func (c *Client) SystemImageDelete(imageName Name) error {
	// Create the url.
	path := "/system/images/{{.image_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"image_name": string(imageName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolList: List IP pools
//
// To iterate over all pages, use the `IpPoolListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) IpPoolList(limit int, pageToken string, sortBy NameOrIdSortMode) (*IpPoolResultsPage, error) {
	// Create the url.
	path := "/system/ip-pools"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolListAllPages: List IP pools
//
// This method is a wrapper around the `IpPoolList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) IpPoolListAllPages(sortBy NameOrIdSortMode) (*[]IpPool, error) {
	var allPages []IpPool
	pageToken := ""
	limit := 100
	for {
		page, err := c.IpPoolList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// IpPoolCreate: Create an IP pool
func (c *Client) IpPoolCreate(j *IpPoolCreate) (*IpPool, error) {
	// Create the url.
	path := "/system/ip-pools"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceView: Fetch the IP pool used for Oxide services.
func (c *Client) IpPoolServiceView() (*IpPool, error) {
	// Create the url.
	path := "/system/ip-pools-service"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeList: List ranges for the IP pool used for Oxide services.
// Ranges are ordered by their first address.
//
// To iterate over all pages, use the `IpPoolServiceRangeListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
func (c *Client) IpPoolServiceRangeList(limit int, pageToken string) (*IpPoolRangeResultsPage, error) {
	// Create the url.
	path := "/system/ip-pools-service/ranges"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRangeResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeListAllPages: List ranges for the IP pool used for Oxide services.
// Ranges are ordered by their first address.
//
// This method is a wrapper around the `IpPoolServiceRangeList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolServiceRangeListAllPages() (*[]IpPoolRange, error) {
	var allPages []IpPoolRange
	pageToken := ""
	limit := 100
	for {
		page, err := c.IpPoolServiceRangeList(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// IpPoolServiceRangeAdd: Add a range to an IP pool used for Oxide services.
func (c *Client) IpPoolServiceRangeAdd(j *IpRange) (*IpPoolRange, error) {
	// Create the url.
	path := "/system/ip-pools-service/ranges/add"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRange
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolServiceRangeRemove: Remove a range from an IP pool used for Oxide services.
func (c *Client) IpPoolServiceRangeRemove(j *IpRange) error {
	// Create the url.
	path := "/system/ip-pools-service/ranges/remove"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolView: Fetch an IP pool
//
// Parameters
// - `poolName`
func (c *Client) IpPoolView(poolName Name) (*IpPool, error) {
	// Create the url.
	path := "/system/ip-pools/{{.pool_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"pool_name": string(poolName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolUpdate: Update an IP Pool
//
// Parameters
// - `poolName`
func (c *Client) IpPoolUpdate(poolName Name, j *IpPoolUpdate) (*IpPool, error) {
	// Create the url.
	path := "/system/ip-pools/{{.pool_name}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"pool_name": string(poolName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPool
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolDelete: Delete an IP Pool
//
// Parameters
// - `poolName`
func (c *Client) IpPoolDelete(poolName Name) error {
	// Create the url.
	path := "/system/ip-pools/{{.pool_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"pool_name": string(poolName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// IpPoolRangeList: List ranges for an IP pool
// Ranges are ordered by their first address.
//
// To iterate over all pages, use the `IpPoolRangeListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `poolName`
func (c *Client) IpPoolRangeList(poolName Name, limit int, pageToken string) (*IpPoolRangeResultsPage, error) {
	// Create the url.
	path := "/system/ip-pools/{{.pool_name}}/ranges"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"pool_name": string(poolName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRangeResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolRangeListAllPages: List ranges for an IP pool
// Ranges are ordered by their first address.
//
// This method is a wrapper around the `IpPoolRangeList` method.
// This method returns all the pages at once.
//
// Parameters
// - `poolName`
func (c *Client) IpPoolRangeListAllPages(poolName Name) (*[]IpPoolRange, error) {
	var allPages []IpPoolRange
	pageToken := ""
	limit := 100
	for {
		page, err := c.IpPoolRangeList(poolName, limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// IpPoolRangeAdd: Add a range to an IP pool
//
// Parameters
// - `poolName`
func (c *Client) IpPoolRangeAdd(poolName Name, j *IpRange) (*IpPoolRange, error) {
	// Create the url.
	path := "/system/ip-pools/{{.pool_name}}/ranges/add"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"pool_name": string(poolName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IpPoolRange
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// IpPoolRangeRemove: Remove a range from an IP pool
//
// Parameters
// - `poolName`
func (c *Client) IpPoolRangeRemove(poolName Name, j *IpRange) error {
	// Create the url.
	path := "/system/ip-pools/{{.pool_name}}/ranges/remove"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"pool_name": string(poolName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemMetric: Access metrics data
//
// To iterate over all pages, use the `SystemMetricAllPages` method, instead.
//
// Parameters
// - `endTime` An exclusive end time of metrics.
// - `id` The UUID of the container being queried
// - `limit` Maximum number of items returned by a single call
// - `metricName`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `startTime` An inclusive start time of metrics.
func (c *Client) SystemMetric(metricName SystemMetricName, endTime *time.Time, id string, limit int, pageToken string, startTime *time.Time) (*MeasurementResultsPage, error) {
	// Create the url.
	path := "/system/metrics/{{.metric_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"metric_name": string(metricName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"end_time":   endTime.String(),
		"id":         id,
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"start_time": startTime.String(),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body MeasurementResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemMetricAllPages: Access metrics data
//
// This method is a wrapper around the `SystemMetric` method.
// This method returns all the pages at once.
//
// Parameters
// - `endTime` An exclusive end time of metrics.
// - `id` The UUID of the container being queried
// - `metricName`
// - `startTime` An inclusive start time of metrics.
func (c *Client) SystemMetricAllPages(metricName SystemMetricName, endTime *time.Time, id string, startTime *time.Time) (*[]Measurement, error) {
	var allPages []Measurement
	pageToken := ""
	limit := 100
	for {
		page, err := c.SystemMetric(metricName, endTime, id, limit, pageToken, startTime)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemPolicyView: Fetch the top-level IAM policy
// Use `GET /v1/system/policy` instead
func (c *Client) SystemPolicyView() (*FleetRolePolicy, error) {
	// Create the url.
	path := "/system/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemPolicyUpdate: Update the top-level IAM policy
// Use 'PUT /v1/system/policy' instead
func (c *Client) SystemPolicyUpdate(j *FleetRolePolicy) (*FleetRolePolicy, error) {
	// Create the url.
	path := "/system/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SagaList: List sagas
// Use `GET v1/system/sagas` instead
//
// To iterate over all pages, use the `SagaListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SagaList(limit int, pageToken string, sortBy IdSortMode) (*SagaResultsPage, error) {
	// Create the url.
	path := "/system/sagas"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SagaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SagaListAllPages: List sagas
// Use `GET v1/system/sagas` instead
//
// This method is a wrapper around the `SagaList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SagaListAllPages(sortBy IdSortMode) (*[]Saga, error) {
	var allPages []Saga
	pageToken := ""
	limit := 100
	for {
		page, err := c.SagaList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SagaView: Fetch a saga
// Use `GET v1/system/sagas/{saga_id}` instead
//
// Parameters
// - `sagaId`
func (c *Client) SagaView(sagaId string) (*Saga, error) {
	// Create the url.
	path := "/system/sagas/{{.saga_id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"saga_id": sagaId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Saga
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloList: List silos
// Lists silos that are discoverable based on the current permissions.
//
// To iterate over all pages, use the `SiloListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SiloList(limit int, pageToken string, sortBy NameOrIdSortMode) (*SiloResultsPage, error) {
	// Create the url.
	path := "/system/silos"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloListAllPages: List silos
// Lists silos that are discoverable based on the current permissions.
//
// This method is a wrapper around the `SiloList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SiloListAllPages(sortBy NameOrIdSortMode) (*[]Silo, error) {
	var allPages []Silo
	pageToken := ""
	limit := 100
	for {
		page, err := c.SiloList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SiloCreate: Create a silo
func (c *Client) SiloCreate(j *SiloCreate) (*Silo, error) {
	// Create the url.
	path := "/system/silos"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Silo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloView: Fetch a silo
// Fetch a silo by name.
//
// Parameters
// - `siloName` The silo's unique name.
func (c *Client) SiloView(siloName Name) (*Silo, error) {
	// Create the url.
	path := "/system/silos/{{.silo_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Silo
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloDelete: Delete a silo
// Delete a silo by name.
//
// Parameters
// - `siloName` The silo's unique name.
func (c *Client) SiloDelete(siloName Name) error {
	// Create the url.
	path := "/system/silos/{{.silo_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SiloIdentityProviderList: List a silo's IDPs
//
// To iterate over all pages, use the `SiloIdentityProviderListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `siloName` The silo's unique name.
// - `sortBy`
func (c *Client) SiloIdentityProviderList(siloName Name, limit int, pageToken string, sortBy NameSortMode) (*IdentityProviderResultsPage, error) {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/identity-providers"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body IdentityProviderResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloIdentityProviderListAllPages: List a silo's IDPs
//
// This method is a wrapper around the `SiloIdentityProviderList` method.
// This method returns all the pages at once.
//
// Parameters
// - `siloName` The silo's unique name.
// - `sortBy`
func (c *Client) SiloIdentityProviderListAllPages(siloName Name, sortBy NameSortMode) (*[]IdentityProvider, error) {
	var allPages []IdentityProvider
	pageToken := ""
	limit := 100
	for {
		page, err := c.SiloIdentityProviderList(siloName, limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// LocalIdpUserCreate: Create a user
// Users can only be created in Silos with `provision_type` == `Fixed`. Otherwise, Silo users are just-in-time (JIT) provisioned when a user first logs in using an external Identity Provider.
//
// Parameters
// - `siloName` The silo's unique name.
func (c *Client) LocalIdpUserCreate(siloName Name, j *UserCreate) (*User, error) {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/identity-providers/local/users"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// LocalIdpUserDelete: Delete a user
//
// Parameters
// - `siloName` The silo's unique name.
// - `userId` The user's internal id
func (c *Client) LocalIdpUserDelete(siloName Name, userId string) error {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/identity-providers/local/users/{{.user_id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
		"user_id":   userId,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// LocalIdpUserSetPassword: Set or invalidate a user's password
// Passwords can only be updated for users in Silos with identity mode `LocalOnly`.
//
// Parameters
// - `siloName` The silo's unique name.
// - `userId` The user's internal id
func (c *Client) LocalIdpUserSetPassword(siloName Name, userId string, j *UserPassword) error {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/identity-providers/local/users/{{.user_id}}/set-password"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
		"user_id":   userId,
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SamlIdentityProviderCreate: Create a SAML IDP
//
// Parameters
// - `siloName` The silo's unique name.
func (c *Client) SamlIdentityProviderCreate(siloName Name, j *SamlIdentityProviderCreate) (*SamlIdentityProvider, error) {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/identity-providers/saml"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SamlIdentityProvider
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SamlIdentityProviderView: Fetch a SAML IDP
//
// Parameters
// - `providerName` The SAML identity provider's name
// - `siloName` The silo's unique name.
func (c *Client) SamlIdentityProviderView(providerName Name, siloName Name) (*SamlIdentityProvider, error) {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/identity-providers/saml/{{.provider_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"provider_name": string(providerName),
		"silo_name":     string(siloName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SamlIdentityProvider
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloPolicyView: Fetch a silo's IAM policy
//
// Parameters
// - `siloName` The silo's unique name.
func (c *Client) SiloPolicyView(siloName Name) (*SiloRolePolicy, error) {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloPolicyUpdate: Update a silo's IAM policy
//
// Parameters
// - `siloName` The silo's unique name.
func (c *Client) SiloPolicyUpdate(siloName Name, j *SiloRolePolicy) (*SiloRolePolicy, error) {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUsersList: List users in a silo
//
// To iterate over all pages, use the `SiloUsersListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `siloName` The silo's unique name.
// - `sortBy`
func (c *Client) SiloUsersList(siloName Name, limit int, pageToken string, sortBy IdSortMode) (*UserResultsPage, error) {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/users/all"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SiloUsersListAllPages: List users in a silo
//
// This method is a wrapper around the `SiloUsersList` method.
// This method returns all the pages at once.
//
// Parameters
// - `siloName` The silo's unique name.
// - `sortBy`
func (c *Client) SiloUsersListAllPages(siloName Name, sortBy IdSortMode) (*[]User, error) {
	var allPages []User
	pageToken := ""
	limit := 100
	for {
		page, err := c.SiloUsersList(siloName, limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SiloUserView: Fetch a user
//
// Parameters
// - `siloName` The silo's unique name.
// - `userId` The user's internal id
func (c *Client) SiloUserView(siloName Name, userId string) (*User, error) {
	// Create the url.
	path := "/system/silos/{{.silo_name}}/users/id/{{.user_id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"silo_name": string(siloName),
		"user_id":   userId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body User
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUserList: List built-in users
//
// To iterate over all pages, use the `SystemUserListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SystemUserList(limit int, pageToken string, sortBy NameSortMode) (*UserBuiltinResultsPage, error) {
	// Create the url.
	path := "/system/user"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserBuiltinResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUserListAllPages: List built-in users
//
// This method is a wrapper around the `SystemUserList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SystemUserListAllPages(sortBy NameSortMode) (*[]UserBuiltin, error) {
	var allPages []UserBuiltin
	pageToken := ""
	limit := 100
	for {
		page, err := c.SystemUserList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemUserView: Fetch a built-in user
//
// Parameters
// - `userName` The built-in user's unique name.
func (c *Client) SystemUserView(userName Name) (*UserBuiltin, error) {
	// Create the url.
	path := "/system/user/{{.user_name}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"user_name": string(userName),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserBuiltin
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// TimeseriesSchemaGet: List timeseries schema
//
// To iterate over all pages, use the `TimeseriesSchemaGetAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
func (c *Client) TimeseriesSchemaGet(limit int, pageToken string) (*TimeseriesSchemaResultsPage, error) {
	// Create the url.
	path := "/timeseries/schema"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body TimeseriesSchemaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// TimeseriesSchemaGetAllPages: List timeseries schema
//
// This method is a wrapper around the `TimeseriesSchemaGet` method.
// This method returns all the pages at once.
func (c *Client) TimeseriesSchemaGetAllPages() (*[]TimeseriesSchema, error) {
	var allPages []TimeseriesSchema
	pageToken := ""
	limit := 100
	for {
		page, err := c.TimeseriesSchemaGet(limit, pageToken)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// UserList: List users
//
// To iterate over all pages, use the `UserListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) UserList(limit int, pageToken string, sortBy IdSortMode) (*UserResultsPage, error) {
	// Create the url.
	path := "/users"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UserResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UserListAllPages: List users
//
// This method is a wrapper around the `UserList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) UserListAllPages(sortBy IdSortMode) (*[]User, error) {
	var allPages []User
	pageToken := ""
	limit := 100
	for {
		page, err := c.UserList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// DiskListV1: List disks
//
// To iterate over all pages, use the `DiskListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
func (c *Client) DiskListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode) (*DiskResultsPage, error) {
	// Create the url.
	path := "/v1/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskListV1AllPages: List disks
//
// This method is a wrapper around the `DiskListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `project`
// - `sortBy`
func (c *Client) DiskListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode) (*[]Disk, error) {
	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := c.DiskListV1(limit, organization, pageToken, project, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// DiskCreateV1: Create a disk
//
// Parameters
// - `organization`
// - `project`
func (c *Client) DiskCreateV1(organization NameOrId, project NameOrId, j *DiskCreate) (*Disk, error) {
	// Create the url.
	path := "/v1/disks"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskViewV1: Fetch a disk
//
// Parameters
// - `disk`
// - `organization`
// - `project`
func (c *Client) DiskViewV1(disk NameOrId, organization NameOrId, project NameOrId) (*Disk, error) {
	// Create the url.
	path := "/v1/disks/{{.disk}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk": disk.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// DiskDeleteV1: Delete a disk
//
// Parameters
// - `disk`
// - `organization`
// - `project`
func (c *Client) DiskDeleteV1(disk NameOrId, organization NameOrId, project NameOrId) error {
	// Create the url.
	path := "/v1/disks/{{.disk}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"disk": disk.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceListV1: List instances
//
// To iterate over all pages, use the `InstanceListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
func (c *Client) InstanceListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode) (*InstanceResultsPage, error) {
	// Create the url.
	path := "/v1/instances"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceListV1AllPages: List instances
//
// This method is a wrapper around the `InstanceListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `project`
// - `sortBy`
func (c *Client) InstanceListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode) (*[]Instance, error) {
	var allPages []Instance
	pageToken := ""
	limit := 100
	for {
		page, err := c.InstanceListV1(limit, organization, pageToken, project, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceCreateV1: Create an instance
//
// Parameters
// - `organization`
// - `project`
func (c *Client) InstanceCreateV1(organization NameOrId, project NameOrId, j *InstanceCreate) (*Instance, error) {
	// Create the url.
	path := "/v1/instances"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceViewV1: Fetch an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceViewV1(organization NameOrId, project NameOrId, instance NameOrId) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDeleteV1: Delete an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceDeleteV1(organization NameOrId, project NameOrId, instance NameOrId) error {
	// Create the url.
	path := "/v1/instances/{{.instance}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceDiskListV1: List an instance's disks
//
// To iterate over all pages, use the `InstanceDiskListV1AllPages` method, instead.
//
// Parameters
// - `instance`
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
func (c *Client) InstanceDiskListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode, instance NameOrId) (*DiskResultsPage, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body DiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskListV1AllPages: List an instance's disks
//
// This method is a wrapper around the `InstanceDiskListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `instance`
// - `organization`
// - `project`
// - `sortBy`
func (c *Client) InstanceDiskListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode, instance NameOrId) (*[]Disk, error) {
	var allPages []Disk
	pageToken := ""
	limit := 100
	for {
		page, err := c.InstanceDiskListV1(limit, organization, pageToken, project, sortBy, instance)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceDiskAttachV1: Attach a disk to an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceDiskAttachV1(instance NameOrId, organization NameOrId, project NameOrId, j *DiskPath) (*Disk, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/disks/attach"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceDiskDetachV1: Detach a disk from an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceDiskDetachV1(instance NameOrId, organization NameOrId, project NameOrId, j *DiskPath) (*Disk, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/disks/detach"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Disk
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceMigrateV1: Migrate an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceMigrateV1(organization NameOrId, project NameOrId, instance NameOrId, j *InstanceMigrate) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/migrate"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceRebootV1: Reboot an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceRebootV1(organization NameOrId, project NameOrId, instance NameOrId) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/reboot"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsoleV1: Fetch an instance's serial console
//
// Parameters
// - `fromStart` Character index in the serial buffer from which to read, counting the bytes output since instance start. If this is not provided, `most_recent` must be provided, and if this *is* provided, `most_recent` must *not* be provided.
// - `instance`
// - `maxBytes` Maximum number of bytes of buffered serial console contents to return. If the requested range runs to the end of the available buffer, the data returned will be shorter than `max_bytes`.
// - `mostRecent` Character index in the serial buffer from which to read, counting *backward* from the most recently buffered data retrieved from the instance. (See note on `from_start` about mutual exclusivity)
// - `organization`
// - `project`
func (c *Client) InstanceSerialConsoleV1(instance NameOrId, fromStart int, maxBytes int, mostRecent int, organization NameOrId, project NameOrId) (*InstanceSerialConsoleData, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/serial-console"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"from_start":   strconv.Itoa(fromStart),
		"max_bytes":    strconv.Itoa(maxBytes),
		"most_recent":  strconv.Itoa(mostRecent),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body InstanceSerialConsoleData
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceSerialConsoleStreamV1: Stream an instance's serial console
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceSerialConsoleStreamV1(instance NameOrId, organization NameOrId, project NameOrId) error {
	// Create the url.
	path := "/v1/instances/{{.instance}}/serial-console/stream"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// InstanceStartV1: Boot an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceStartV1(organization NameOrId, project NameOrId, instance NameOrId) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/start"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceStopV1: Stop an instance
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceStopV1(organization NameOrId, project NameOrId, instance NameOrId) (*Instance, error) {
	// Create the url.
	path := "/v1/instances/{{.instance}}/stop"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"instance": instance.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Instance
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceListV1: List network interfaces
//
// To iterate over all pages, use the `InstanceNetworkInterfaceListV1AllPages` method, instead.
//
// Parameters
// - `instance`
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
func (c *Client) InstanceNetworkInterfaceListV1(instance NameOrId, limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode) (*NetworkInterfaceResultsPage, error) {
	// Create the url.
	path := "/v1/network-interfaces"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"instance":     instance.(string),
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterfaceResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceListV1AllPages: List network interfaces
//
// This method is a wrapper around the `InstanceNetworkInterfaceListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `instance`
// - `organization`
// - `project`
// - `sortBy`
func (c *Client) InstanceNetworkInterfaceListV1AllPages(instance NameOrId, organization NameOrId, project NameOrId, sortBy NameOrIdSortMode) (*[]NetworkInterface, error) {
	var allPages []NetworkInterface
	pageToken := ""
	limit := 100
	for {
		page, err := c.InstanceNetworkInterfaceListV1(instance, limit, organization, pageToken, project, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// InstanceNetworkInterfaceCreateV1: Create a network interface
//
// Parameters
// - `instance`
// - `organization`
// - `project`
func (c *Client) InstanceNetworkInterfaceCreateV1(instance NameOrId, organization NameOrId, project NameOrId, j *NetworkInterfaceCreate) (*NetworkInterface, error) {
	// Create the url.
	path := "/v1/network-interfaces"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceViewV1: Fetch a network interface
//
// Parameters
// - `instance`
// - `itf`
// - `organization`
// - `project`
func (c *Client) InstanceNetworkInterfaceViewV1(itf NameOrId, instance NameOrId, organization NameOrId, project NameOrId) (*NetworkInterface, error) {
	// Create the url.
	path := "/v1/network-interfaces/{{.interface}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"interface": itf.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceUpdateV1: Update a network interface
//
// Parameters
// - `instance`
// - `itf`
// - `organization`
// - `project`
func (c *Client) InstanceNetworkInterfaceUpdateV1(itf NameOrId, instance NameOrId, organization NameOrId, project NameOrId, j *NetworkInterfaceUpdate) (*NetworkInterface, error) {
	// Create the url.
	path := "/v1/network-interfaces/{{.interface}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"interface": itf.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body NetworkInterface
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// InstanceNetworkInterfaceDeleteV1: Delete a network interface
// Note that the primary interface for an instance cannot be deleted if there are any secondary interfaces. A new primary interface must be designated first. The primary interface can be deleted if there are no secondary interfaces.
//
// Parameters
// - `instance`
// - `itf`
// - `organization`
// - `project`
func (c *Client) InstanceNetworkInterfaceDeleteV1(itf NameOrId, instance NameOrId, organization NameOrId, project NameOrId) error {
	// Create the url.
	path := "/v1/network-interfaces/{{.interface}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"interface": itf.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"instance":     instance.(string),
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// OrganizationListV1: List organizations
//
// To iterate over all pages, use the `OrganizationListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) OrganizationListV1(limit int, pageToken string, sortBy NameOrIdSortMode) (*OrganizationResultsPage, error) {
	// Create the url.
	path := "/v1/organizations"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OrganizationResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationListV1AllPages: List organizations
//
// This method is a wrapper around the `OrganizationListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) OrganizationListV1AllPages(sortBy NameOrIdSortMode) (*[]Organization, error) {
	var allPages []Organization
	pageToken := ""
	limit := 100
	for {
		page, err := c.OrganizationListV1(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// OrganizationCreateV1: Create an organization
func (c *Client) OrganizationCreateV1(j *OrganizationCreate) (*Organization, error) {
	// Create the url.
	path := "/v1/organizations"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationViewV1: Fetch an organization
//
// Parameters
// - `organization`
func (c *Client) OrganizationViewV1(organization NameOrId) (*Organization, error) {
	// Create the url.
	path := "/v1/organizations/{{.organization}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationUpdateV1: Update an organization
//
// Parameters
// - `organization`
func (c *Client) OrganizationUpdateV1(organization NameOrId, j *OrganizationUpdate) (*Organization, error) {
	// Create the url.
	path := "/v1/organizations/{{.organization}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Organization
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationDeleteV1: Delete an organization
//
// Parameters
// - `organization`
func (c *Client) OrganizationDeleteV1(organization NameOrId) error {
	// Create the url.
	path := "/v1/organizations/{{.organization}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// OrganizationPolicyViewV1: Fetch an organization's IAM policy
//
// Parameters
// - `organization`
func (c *Client) OrganizationPolicyViewV1(organization NameOrId) (*OrganizationRolePolicy, error) {
	// Create the url.
	path := "/v1/organizations/{{.organization}}/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OrganizationRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// OrganizationPolicyUpdateV1: Update an organization's IAM policy
//
// Parameters
// - `organization`
func (c *Client) OrganizationPolicyUpdateV1(organization NameOrId, j *OrganizationRolePolicy) (*OrganizationRolePolicy, error) {
	// Create the url.
	path := "/v1/organizations/{{.organization}}/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body OrganizationRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PolicyViewV1: Fetch the current silo's IAM policy
func (c *Client) PolicyViewV1() (*SiloRolePolicy, error) {
	// Create the url.
	path := "/v1/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PolicyUpdateV1: Update the current silo's IAM policy
func (c *Client) PolicyUpdateV1(j *SiloRolePolicy) (*SiloRolePolicy, error) {
	// Create the url.
	path := "/v1/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SiloRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectListV1: List projects
//
// To iterate over all pages, use the `ProjectListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) ProjectListV1(limit int, organization NameOrId, pageToken string, sortBy NameOrIdSortMode) (*ProjectResultsPage, error) {
	// Create the url.
	path := "/v1/projects"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectListV1AllPages: List projects
//
// This method is a wrapper around the `ProjectListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `sortBy`
func (c *Client) ProjectListV1AllPages(organization NameOrId, sortBy NameOrIdSortMode) (*[]Project, error) {
	var allPages []Project
	pageToken := ""
	limit := 100
	for {
		page, err := c.ProjectListV1(limit, organization, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// ProjectCreateV1: Create a project
//
// Parameters
// - `organization`
func (c *Client) ProjectCreateV1(organization NameOrId, j *ProjectCreate) (*Project, error) {
	// Create the url.
	path := "/v1/projects"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectViewV1: Fetch a project
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectViewV1(project NameOrId, organization NameOrId) (*Project, error) {
	// Create the url.
	path := "/v1/projects/{{.project}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"project": project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectUpdateV1: Update a project
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectUpdateV1(project NameOrId, organization NameOrId, j *ProjectUpdate) (*Project, error) {
	// Create the url.
	path := "/v1/projects/{{.project}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"project": project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Project
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectDeleteV1: Delete a project
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectDeleteV1(project NameOrId, organization NameOrId) error {
	// Create the url.
	path := "/v1/projects/{{.project}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"project": project.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// ProjectPolicyViewV1: Fetch a project's IAM policy
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectPolicyViewV1(project NameOrId, organization NameOrId) (*ProjectRolePolicy, error) {
	// Create the url.
	path := "/v1/projects/{{.project}}/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"project": project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// ProjectPolicyUpdateV1: Update a project's IAM policy
//
// Parameters
// - `organization`
// - `project`
func (c *Client) ProjectPolicyUpdateV1(project NameOrId, organization NameOrId, j *ProjectRolePolicy) (*ProjectRolePolicy, error) {
	// Create the url.
	path := "/v1/projects/{{.project}}/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"project": project.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ProjectRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotListV1: List snapshots
//
// To iterate over all pages, use the `SnapshotListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
func (c *Client) SnapshotListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode) (*SnapshotResultsPage, error) {
	// Create the url.
	path := "/v1/snapshots"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SnapshotResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotListV1AllPages: List snapshots
//
// This method is a wrapper around the `SnapshotListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `project`
// - `sortBy`
func (c *Client) SnapshotListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode) (*[]Snapshot, error) {
	var allPages []Snapshot
	pageToken := ""
	limit := 100
	for {
		page, err := c.SnapshotListV1(limit, organization, pageToken, project, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SnapshotCreateV1: Create a snapshot
// Creates a point-in-time snapshot from a disk.
//
// Parameters
// - `organization`
// - `project`
func (c *Client) SnapshotCreateV1(organization NameOrId, project NameOrId, j *SnapshotCreate) (*Snapshot, error) {
	// Create the url.
	path := "/v1/snapshots"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotViewV1: Fetch a snapshot
//
// Parameters
// - `organization`
// - `project`
// - `snapshot`
func (c *Client) SnapshotViewV1(snapshot NameOrId, organization NameOrId, project NameOrId) (*Snapshot, error) {
	// Create the url.
	path := "/v1/snapshots/{{.snapshot}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"snapshot": snapshot.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Snapshot
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SnapshotDeleteV1: Delete a snapshot
//
// Parameters
// - `organization`
// - `project`
// - `snapshot`
func (c *Client) SnapshotDeleteV1(snapshot NameOrId, organization NameOrId, project NameOrId) error {
	// Create the url.
	path := "/v1/snapshots/{{.snapshot}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"snapshot": snapshot.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// CertificateListV1: List system-wide certificates
// Returns a list of all the system-wide certificates. System-wide certificates are returned sorted by creation date, with the most recent certificates appearing first.
//
// To iterate over all pages, use the `CertificateListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) CertificateListV1(limit int, pageToken string, sortBy NameOrIdSortMode) (*CertificateResultsPage, error) {
	// Create the url.
	path := "/v1/system/certificates"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body CertificateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateListV1AllPages: List system-wide certificates
// Returns a list of all the system-wide certificates. System-wide certificates are returned sorted by creation date, with the most recent certificates appearing first.
//
// This method is a wrapper around the `CertificateListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) CertificateListV1AllPages(sortBy NameOrIdSortMode) (*[]Certificate, error) {
	var allPages []Certificate
	pageToken := ""
	limit := 100
	for {
		page, err := c.CertificateListV1(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// CertificateCreateV1: Create a new system-wide x.509 certificate.
// This certificate is automatically used by the Oxide Control plane to serve external connections.
func (c *Client) CertificateCreateV1(j *CertificateCreate) (*Certificate, error) {
	// Create the url.
	path := "/v1/system/certificates"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateViewV1: Fetch a certificate
// Returns the details of a specific certificate
//
// Parameters
// - `certificate`
func (c *Client) CertificateViewV1(certificate NameOrId) (*Certificate, error) {
	// Create the url.
	path := "/v1/system/certificates/{{.certificate}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"certificate": certificate.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Certificate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// CertificateDeleteV1: Delete a certificate
// Permanently delete a certificate. This operation cannot be undone.
//
// Parameters
// - `certificate`
func (c *Client) CertificateDeleteV1(certificate NameOrId) error {
	// Create the url.
	path := "/v1/system/certificates/{{.certificate}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"certificate": certificate.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// PhysicalDiskListV1: List physical disks
//
// To iterate over all pages, use the `PhysicalDiskListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) PhysicalDiskListV1(limit int, pageToken string, sortBy IdSortMode) (*PhysicalDiskResultsPage, error) {
	// Create the url.
	path := "/v1/system/hardware/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// PhysicalDiskListV1AllPages: List physical disks
//
// This method is a wrapper around the `PhysicalDiskListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) PhysicalDiskListV1AllPages(sortBy IdSortMode) (*[]PhysicalDisk, error) {
	var allPages []PhysicalDisk
	pageToken := ""
	limit := 100
	for {
		page, err := c.PhysicalDiskListV1(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// RackListV1: List racks
//
// To iterate over all pages, use the `RackListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) RackListV1(limit int, pageToken string, sortBy IdSortMode) (*RackResultsPage, error) {
	// Create the url.
	path := "/v1/system/hardware/racks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RackResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// RackListV1AllPages: List racks
//
// This method is a wrapper around the `RackListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) RackListV1AllPages(sortBy IdSortMode) (*[]Rack, error) {
	var allPages []Rack
	pageToken := ""
	limit := 100
	for {
		page, err := c.RackListV1(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// RackViewV1: Fetch a rack
//
// Parameters
// - `rackId` The rack's unique ID.
func (c *Client) RackViewV1(rackId string) (*Rack, error) {
	// Create the url.
	path := "/v1/system/hardware/racks/{{.rack_id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"rack_id": rackId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Rack
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListV1: List sleds
//
// To iterate over all pages, use the `SledListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SledListV1(limit int, pageToken string, sortBy IdSortMode) (*SledResultsPage, error) {
	// Create the url.
	path := "/v1/system/hardware/sleds"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SledResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledListV1AllPages: List sleds
//
// This method is a wrapper around the `SledListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SledListV1AllPages(sortBy IdSortMode) (*[]Sled, error) {
	var allPages []Sled
	pageToken := ""
	limit := 100
	for {
		page, err := c.SledListV1(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SledViewV1: Fetch a sled
//
// Parameters
// - `sledId` The sled's unique ID.
func (c *Client) SledViewV1(sledId string) (*Sled, error) {
	// Create the url.
	path := "/v1/system/hardware/sleds/{{.sled_id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sled_id": sledId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Sled
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskListV1: List physical disks attached to sleds
//
// To iterate over all pages, use the `SledPhysicalDiskListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sledId` The sled's unique ID.
// - `sortBy`
func (c *Client) SledPhysicalDiskListV1(sledId string, limit int, pageToken string, sortBy IdSortMode) (*PhysicalDiskResultsPage, error) {
	// Create the url.
	path := "/v1/system/hardware/sleds/{{.sled_id}}/disks"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"sled_id": sledId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body PhysicalDiskResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SledPhysicalDiskListV1AllPages: List physical disks attached to sleds
//
// This method is a wrapper around the `SledPhysicalDiskListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `sledId` The sled's unique ID.
// - `sortBy`
func (c *Client) SledPhysicalDiskListV1AllPages(sledId string, sortBy IdSortMode) (*[]PhysicalDisk, error) {
	var allPages []PhysicalDisk
	pageToken := ""
	limit := 100
	for {
		page, err := c.SledPhysicalDiskListV1(sledId, limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemPolicyViewV1: Fetch the top-level IAM policy
func (c *Client) SystemPolicyViewV1() (*FleetRolePolicy, error) {
	// Create the url.
	path := "/v1/system/policy"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemPolicyUpdateV1: Update the top-level IAM policy
func (c *Client) SystemPolicyUpdateV1(j *FleetRolePolicy) (*FleetRolePolicy, error) {
	// Create the url.
	path := "/v1/system/policy"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body FleetRolePolicy
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SagaListV1: List sagas
//
// To iterate over all pages, use the `SagaListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SagaListV1(limit int, pageToken string, sortBy IdSortMode) (*SagaResultsPage, error) {
	// Create the url.
	path := "/v1/system/sagas"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SagaResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SagaListV1AllPages: List sagas
//
// This method is a wrapper around the `SagaListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SagaListV1AllPages(sortBy IdSortMode) (*[]Saga, error) {
	var allPages []Saga
	pageToken := ""
	limit := 100
	for {
		page, err := c.SagaListV1(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SagaViewV1: Fetch a saga
//
// Parameters
// - `sagaId`
func (c *Client) SagaViewV1(sagaId string) (*Saga, error) {
	// Create the url.
	path := "/v1/system/sagas/{{.saga_id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"saga_id": sagaId,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Saga
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemComponentVersionList: View version and update status of component tree
//
// To iterate over all pages, use the `SystemComponentVersionListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SystemComponentVersionList(limit int, pageToken string, sortBy IdSortMode) (*UpdateableComponentResultsPage, error) {
	// Create the url.
	path := "/v1/system/update/components"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateableComponentResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemComponentVersionListAllPages: View version and update status of component tree
//
// This method is a wrapper around the `SystemComponentVersionList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SystemComponentVersionListAllPages(sortBy IdSortMode) (*[]UpdateableComponent, error) {
	var allPages []UpdateableComponent
	pageToken := ""
	limit := 100
	for {
		page, err := c.SystemComponentVersionList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// UpdateDeploymentsList: List all update deployments
//
// To iterate over all pages, use the `UpdateDeploymentsListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) UpdateDeploymentsList(limit int, pageToken string, sortBy IdSortMode) (*UpdateDeploymentResultsPage, error) {
	// Create the url.
	path := "/v1/system/update/deployments"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateDeploymentResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// UpdateDeploymentsListAllPages: List all update deployments
//
// This method is a wrapper around the `UpdateDeploymentsList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) UpdateDeploymentsListAllPages(sortBy IdSortMode) (*[]UpdateDeployment, error) {
	var allPages []UpdateDeployment
	pageToken := ""
	limit := 100
	for {
		page, err := c.UpdateDeploymentsList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// UpdateDeploymentView: Fetch a system update deployment
//
// Parameters
// - `id`
func (c *Client) UpdateDeploymentView(id string) (*UpdateDeployment, error) {
	// Create the url.
	path := "/v1/system/update/deployments/{{.id}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"id": id,
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateDeployment
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateRefresh: Refresh update data
func (c *Client) SystemUpdateRefresh() error {
	// Create the url.
	path := "/v1/system/update/refresh"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemUpdateStart: Start system update
func (c *Client) SystemUpdateStart(j *SystemUpdateStart) (*UpdateDeployment, error) {
	// Create the url.
	path := "/v1/system/update/start"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body UpdateDeployment
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateStop: Stop system update
// If there is no update in progress, do nothing.
func (c *Client) SystemUpdateStop() error {
	// Create the url.
	path := "/v1/system/update/stop"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("POST", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// SystemUpdateList: List all updates
//
// To iterate over all pages, use the `SystemUpdateListAllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `sortBy`
func (c *Client) SystemUpdateList(limit int, pageToken string, sortBy IdSortMode) (*SystemUpdateResultsPage, error) {
	// Create the url.
	path := "/v1/system/update/updates"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":      strconv.Itoa(limit),
		"page_token": pageToken,
		"sort_by":    string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SystemUpdateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateListAllPages: List all updates
//
// This method is a wrapper around the `SystemUpdateList` method.
// This method returns all the pages at once.
//
// Parameters
// - `sortBy`
func (c *Client) SystemUpdateListAllPages(sortBy IdSortMode) (*[]SystemUpdate, error) {
	var allPages []SystemUpdate
	pageToken := ""
	limit := 100
	for {
		page, err := c.SystemUpdateList(limit, pageToken, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// SystemUpdateView: View system update
//
// Parameters
// - `version`
func (c *Client) SystemUpdateView(version SemverVersion) (*SystemUpdate, error) {
	// Create the url.
	path := "/v1/system/update/updates/{{.version}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"version": string(version),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SystemUpdate
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemUpdateComponentsList: View system update component tree
//
// Parameters
// - `version`
func (c *Client) SystemUpdateComponentsList(version SemverVersion) (*ComponentUpdateResultsPage, error) {
	// Create the url.
	path := "/v1/system/update/updates/{{.version}}/components"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"version": string(version),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body ComponentUpdateResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// SystemVersion: View system version and update status
func (c *Client) SystemVersion() (*SystemVersion, error) {
	// Create the url.
	path := "/v1/system/update/version"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body SystemVersion
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcFirewallRulesViewV1: List firewall rules
//
// Parameters
// - `organization`
// - `project`
// - `vpc`
func (c *Client) VpcFirewallRulesViewV1(organization NameOrId, project NameOrId, vpc NameOrId) (*VpcFirewallRules, error) {
	// Create the url.
	path := "/v1/vpc-firewall-rules"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcFirewallRulesUpdateV1: Replace firewall rules
//
// Parameters
// - `organization`
// - `project`
// - `vpc`
func (c *Client) VpcFirewallRulesUpdateV1(organization NameOrId, project NameOrId, vpc NameOrId, j *VpcFirewallRuleUpdateParams) (*VpcFirewallRules, error) {
	// Create the url.
	path := "/v1/vpc-firewall-rules"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcFirewallRules
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteListV1: List routes
// List the routes associated with a router in a particular VPC.
//
// To iterate over all pages, use the `VpcRouterRouteListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `router`
// - `sortBy`
// - `vpc`
func (c *Client) VpcRouterRouteListV1(limit int, organization NameOrId, pageToken string, project NameOrId, router NameOrId, sortBy NameOrIdSortMode, vpc NameOrId) (*RouterRouteResultsPage, error) {
	// Create the url.
	path := "/v1/vpc-router-routes"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"router":       router.(string),
		"sort_by":      string(sortBy),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRouteResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteListV1AllPages: List routes
// List the routes associated with a router in a particular VPC.
//
// This method is a wrapper around the `VpcRouterRouteListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `project`
// - `router`
// - `sortBy`
// - `vpc`
func (c *Client) VpcRouterRouteListV1AllPages(organization NameOrId, project NameOrId, router NameOrId, sortBy NameOrIdSortMode, vpc NameOrId) (*[]RouterRoute, error) {
	var allPages []RouterRoute
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcRouterRouteListV1(limit, organization, pageToken, project, router, sortBy, vpc)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcRouterRouteCreateV1: Create a router
//
// Parameters
// - `organization`
// - `project`
// - `router`
// - `vpc`
func (c *Client) VpcRouterRouteCreateV1(organization NameOrId, project NameOrId, router NameOrId, vpc NameOrId, j *RouterRouteCreate) (*RouterRoute, error) {
	// Create the url.
	path := "/v1/vpc-router-routes"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"router":       router.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteViewV1: Fetch a route
//
// Parameters
// - `organization`
// - `project`
// - `route`
// - `router`
// - `vpc`
func (c *Client) VpcRouterRouteViewV1(route NameOrId, organization NameOrId, project NameOrId, router NameOrId, vpc NameOrId) (*RouterRoute, error) {
	// Create the url.
	path := "/v1/vpc-router-routes/{{.route}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"route": route.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"router":       router.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteUpdateV1: Update a route
//
// Parameters
// - `organization`
// - `project`
// - `route`
// - `router`
// - `vpc`
func (c *Client) VpcRouterRouteUpdateV1(route NameOrId, organization NameOrId, project NameOrId, router NameOrId, vpc NameOrId, j *RouterRouteUpdate) (*RouterRoute, error) {
	// Create the url.
	path := "/v1/vpc-router-routes/{{.route}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"route": route.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"router":       router.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body RouterRoute
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterRouteDeleteV1: Delete a route
//
// Parameters
// - `organization`
// - `project`
// - `route`
// - `router`
// - `vpc`
func (c *Client) VpcRouterRouteDeleteV1(route NameOrId, organization NameOrId, project NameOrId, router NameOrId, vpc NameOrId) error {
	// Create the url.
	path := "/v1/vpc-router-routes/{{.route}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"route": route.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"router":       router.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcRouterListV1: List routers
//
// To iterate over all pages, use the `VpcRouterListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
// - `vpc`
func (c *Client) VpcRouterListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode, vpc NameOrId) (*VpcRouterResultsPage, error) {
	// Create the url.
	path := "/v1/vpc-routers"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouterResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterListV1AllPages: List routers
//
// This method is a wrapper around the `VpcRouterListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `project`
// - `sortBy`
// - `vpc`
func (c *Client) VpcRouterListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode, vpc NameOrId) (*[]VpcRouter, error) {
	var allPages []VpcRouter
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcRouterListV1(limit, organization, pageToken, project, sortBy, vpc)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcRouterCreateV1: Create a VPC router
//
// Parameters
// - `organization`
// - `project`
// - `vpc`
func (c *Client) VpcRouterCreateV1(organization NameOrId, project NameOrId, vpc NameOrId, j *VpcRouterCreate) (*VpcRouter, error) {
	// Create the url.
	path := "/v1/vpc-routers"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterViewV1: Get a router
//
// Parameters
// - `organization`
// - `project`
// - `router`
// - `vpc`
func (c *Client) VpcRouterViewV1(router NameOrId, organization NameOrId, project NameOrId, vpc NameOrId) (*VpcRouter, error) {
	// Create the url.
	path := "/v1/vpc-routers/{{.router}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"router": router.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterUpdateV1: Update a router
//
// Parameters
// - `organization`
// - `project`
// - `router`
// - `vpc`
func (c *Client) VpcRouterUpdateV1(router NameOrId, organization NameOrId, project NameOrId, vpc NameOrId, j *VpcRouterUpdate) (*VpcRouter, error) {
	// Create the url.
	path := "/v1/vpc-routers/{{.router}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"router": router.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcRouter
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcRouterDeleteV1: Delete a router
//
// Parameters
// - `organization`
// - `project`
// - `router`
// - `vpc`
func (c *Client) VpcRouterDeleteV1(router NameOrId, organization NameOrId, project NameOrId, vpc NameOrId) error {
	// Create the url.
	path := "/v1/vpc-routers/{{.router}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"router": router.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcSubnetListV1: Fetch a subnet
//
// To iterate over all pages, use the `VpcSubnetListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
// - `vpc`
func (c *Client) VpcSubnetListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode, vpc NameOrId) (*VpcSubnetResultsPage, error) {
	// Create the url.
	path := "/v1/vpc-subnets"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnetResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetListV1AllPages: Fetch a subnet
//
// This method is a wrapper around the `VpcSubnetListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `project`
// - `sortBy`
// - `vpc`
func (c *Client) VpcSubnetListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode, vpc NameOrId) (*[]VpcSubnet, error) {
	var allPages []VpcSubnet
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcSubnetListV1(limit, organization, pageToken, project, sortBy, vpc)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcSubnetCreateV1: Create a subnet
//
// Parameters
// - `organization`
// - `project`
// - `vpc`
func (c *Client) VpcSubnetCreateV1(organization NameOrId, project NameOrId, vpc NameOrId, j *VpcSubnetCreate) (*VpcSubnet, error) {
	// Create the url.
	path := "/v1/vpc-subnets"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetViewV1: Fetch a subnet
//
// Parameters
// - `organization`
// - `project`
// - `subnet`
// - `vpc`
func (c *Client) VpcSubnetViewV1(subnet NameOrId, organization NameOrId, project NameOrId, vpc NameOrId) (*VpcSubnet, error) {
	// Create the url.
	path := "/v1/vpc-subnets/{{.subnet}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"subnet": subnet.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetUpdateV1: Update a subnet
//
// Parameters
// - `organization`
// - `project`
// - `subnet`
// - `vpc`
func (c *Client) VpcSubnetUpdateV1(subnet NameOrId, organization NameOrId, project NameOrId, vpc NameOrId, j *VpcSubnetUpdate) (*VpcSubnet, error) {
	// Create the url.
	path := "/v1/vpc-subnets/{{.subnet}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"subnet": subnet.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcSubnet
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcSubnetDeleteV1: Delete a subnet
//
// Parameters
// - `organization`
// - `project`
// - `subnet`
// - `vpc`
func (c *Client) VpcSubnetDeleteV1(subnet NameOrId, organization NameOrId, project NameOrId, vpc NameOrId) error {
	// Create the url.
	path := "/v1/vpc-subnets/{{.subnet}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"subnet": subnet.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
		"vpc":          vpc.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}

// VpcListV1: List VPCs
//
// To iterate over all pages, use the `VpcListV1AllPages` method, instead.
//
// Parameters
// - `limit` Maximum number of items returned by a single call
// - `organization`
// - `pageToken` Token returned by previous call to retrieve the subsequent page
// - `project`
// - `sortBy`
func (c *Client) VpcListV1(limit int, organization NameOrId, pageToken string, project NameOrId, sortBy NameOrIdSortMode) (*VpcResultsPage, error) {
	// Create the url.
	path := "/v1/vpcs"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"limit":        strconv.Itoa(limit),
		"organization": organization.(string),
		"page_token":   pageToken,
		"project":      project.(string),
		"sort_by":      string(sortBy),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body VpcResultsPage
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcListV1AllPages: List VPCs
//
// This method is a wrapper around the `VpcListV1` method.
// This method returns all the pages at once.
//
// Parameters
// - `organization`
// - `project`
// - `sortBy`
func (c *Client) VpcListV1AllPages(organization NameOrId, project NameOrId, sortBy NameOrIdSortMode) (*[]Vpc, error) {
	var allPages []Vpc
	pageToken := ""
	limit := 100
	for {
		page, err := c.VpcListV1(limit, organization, pageToken, project, sortBy)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == pageToken {
			break
		}
		pageToken = page.NextPage
	}

	return &allPages, nil
}

// VpcCreateV1: Create a VPC
//
// Parameters
// - `organization`
// - `project`
func (c *Client) VpcCreateV1(organization NameOrId, project NameOrId, j *VpcCreate) (*Vpc, error) {
	// Create the url.
	path := "/v1/vpcs"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("POST", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcViewV1: Fetch a VPC
//
// Parameters
// - `organization`
// - `project`
// - `vpc`
func (c *Client) VpcViewV1(vpc NameOrId, organization NameOrId, project NameOrId) (*Vpc, error) {
	// Create the url.
	path := "/v1/vpcs/{{.vpc}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("GET", uri, nil)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"vpc": vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcUpdateV1: Update a VPC
//
// Parameters
// - `organization`
// - `project`
// - `vpc`
func (c *Client) VpcUpdateV1(vpc NameOrId, organization NameOrId, project NameOrId, j *VpcUpdate) (*Vpc, error) {
	// Create the url.
	path := "/v1/vpcs/{{.vpc}}"
	uri := resolveRelative(c.server, path)

	// Encode the request body as json.
	b := new(bytes.Buffer)
	if err := json.NewEncoder(b).Encode(j); err != nil {
		return nil, fmt.Errorf("encoding json body request failed: %v", err)
	}

	// Create the request.
	req, err := http.NewRequest("PUT", uri, b)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"vpc": vpc.(string),
	}); err != nil {
		return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return nil, fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return nil, err
	}

	// Decode the body from the response.
	if resp.Body == nil {
		return nil, errors.New("request returned an empty body in the response")
	}

	var body Vpc
	if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
		return nil, fmt.Errorf("error decoding response body: %v", err)
	}

	// Return the response.
	return &body, nil
}

// VpcDeleteV1: Delete a VPC
//
// Parameters
// - `organization`
// - `project`
// - `vpc`
func (c *Client) VpcDeleteV1(vpc NameOrId, organization NameOrId, project NameOrId) error {
	// Create the url.
	path := "/v1/vpcs/{{.vpc}}"
	uri := resolveRelative(c.server, path)

	// Create the request.
	req, err := http.NewRequest("DELETE", uri, nil)
	if err != nil {
		return fmt.Errorf("error creating request: %v", err)
	}

	// Add the parameters to the url.
	if err := expandURL(req.URL, map[string]string{
		"vpc": vpc.(string),
	}); err != nil {
		return fmt.Errorf("expanding URL with parameters failed: %v", err)
	}

	// Add query if any
	if err := addQueries(req.URL, map[string]string{
		"organization": organization.(string),
		"project":      project.(string),
	}); err != nil {
		return fmt.Errorf("adding queries to URL failed: %v", err)
	}

	// Send the request.
	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("error sending request: %v", err)
	}
	defer resp.Body.Close()

	// Check the response.
	if err := checkResponse(resp); err != nil {
		return err
	}

	return nil
}
