// Code generated by `generate.test`. DO NOT EDIT.

package oxide

// IpPoolList
//
// To iterate over all pages, use the `IpPoolListAllPages` method, instead.
func (c *Client) IpPoolList(params IpPoolListParams, ) (*IpPoolResultsPage, error) {
    // Create the url.
    path := "/v1/ip-pools"
    uri := resolveRelative(c.server, path)

    // Create the request.
    req, err := http.NewRequest("GET", uri, nil)
    if err != nil {
        return nil, fmt.Errorf("error creating request: %v", err)
    }

    // Add the parameters to the url.
    if err := expandURL(req.URL, map[string]string{ 
    }); err != nil {
        return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
    }

    // Add query if any
    if err := addQueries(req.URL, map[string]string{ 
        "limit": strconv.Itoa(params.Limit),
        "page_token": params.PageToken,
    }); err != nil {
        return nil, fmt.Errorf("adding queries to URL failed: %v", err)
    }

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Check the response.
    if err := checkResponse(resp); err != nil {
        return nil, err
    }

    // Decode the body from the response.
    if resp.Body == nil {
        return nil, errors.New("request returned an empty body in the response")
    }

    var body IpPoolResultsPage
    if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
        return nil, fmt.Errorf("error decoding response body: %v", err)
    }

    // Return the response.
    return &body, nil
}

// IpPoolListAllPages
//
// This method is a wrapper around the `IpPoolList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolListAllPages(params IpPoolListParams, ) (*IpPoolResultsPage, error) {
	var allPages IpPoolResultsPage
	params.PageToken = ""
	params.Limit = 100
	for {
		page, err := c.IpPoolList(params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return &allPages, nil
}

// IpPoolCreate
func (c *Client) IpPoolCreate(j *IpPoolCreate) (*IpPool, error) {
    // Create the url.
    path := "/v1/ip-pools"
    uri := resolveRelative(c.server, path)

    // Encode the request body as json.
    b := new(bytes.Buffer)
    if err := json.NewEncoder(b).Encode(j); err != nil {
        return nil, fmt.Errorf("encoding json body request failed: %v", err)
    }

    // Create the request.
    req, err := http.NewRequest("POST", uri, b)
    if err != nil {
        return nil, fmt.Errorf("error creating request: %v", err)
    }

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Check the response.
    if err := checkResponse(resp); err != nil {
        return nil, err
    }

    // Decode the body from the response.
    if resp.Body == nil {
        return nil, errors.New("request returned an empty body in the response")
    }

    var body IpPool
    if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
        return nil, fmt.Errorf("error decoding response body: %v", err)
    }

    // Return the response.
    return &body, nil
}

// IpPoolView
func (c *Client) IpPoolView(params IpPoolViewParams, ) (*IpPool, error) {
    // Create the url.
    path := "/v1/ip-pools{{.pool_name}}"
    uri := resolveRelative(c.server, path)

    // Create the request.
    req, err := http.NewRequest("GET", uri, nil)
    if err != nil {
        return nil, fmt.Errorf("error creating request: %v", err)
    }

    // Add the parameters to the url.
    if err := expandURL(req.URL, map[string]string{ 
        "pool_name": string(params.PoolName),
    }); err != nil {
        return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
    }

    // Add query if any
    if err := addQueries(req.URL, map[string]string{ 
    }); err != nil {
        return nil, fmt.Errorf("adding queries to URL failed: %v", err)
    }

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Check the response.
    if err := checkResponse(resp); err != nil {
        return nil, err
    }

    // Decode the body from the response.
    if resp.Body == nil {
        return nil, errors.New("request returned an empty body in the response")
    }

    var body IpPool
    if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
        return nil, fmt.Errorf("error decoding response body: %v", err)
    }

    // Return the response.
    return &body, nil
}

// IpPoolUpdate
func (c *Client) IpPoolUpdate(params IpPoolUpdateParams, j *IpPoolUpdate) (*IpPool, error) {
    // Create the url.
    path := "/v1/ip-pools{{.pool_name}}"
    uri := resolveRelative(c.server, path)

    // Encode the request body as json.
    b := new(bytes.Buffer)
    if err := json.NewEncoder(b).Encode(j); err != nil {
        return nil, fmt.Errorf("encoding json body request failed: %v", err)
    }

    // Create the request.
    req, err := http.NewRequest("PUT", uri, b)
    if err != nil {
        return nil, fmt.Errorf("error creating request: %v", err)
    }

    // Add the parameters to the url.
    if err := expandURL(req.URL, map[string]string{ 
        "pool_name": string(params.PoolName),
    }); err != nil {
        return nil, fmt.Errorf("expanding URL with parameters failed: %v", err)
    }

    // Add query if any
    if err := addQueries(req.URL, map[string]string{ 
    }); err != nil {
        return nil, fmt.Errorf("adding queries to URL failed: %v", err)
    }

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Check the response.
    if err := checkResponse(resp); err != nil {
        return nil, err
    }

    // Decode the body from the response.
    if resp.Body == nil {
        return nil, errors.New("request returned an empty body in the response")
    }

    var body IpPool
    if err := json.NewDecoder(resp.Body).Decode(&body); err != nil {
        return nil, fmt.Errorf("error decoding response body: %v", err)
    }

    // Return the response.
    return &body, nil
}

// IpPoolDelete
func (c *Client) IpPoolDelete(params IpPoolDeleteParams, ) error {
    // Create the url.
    path := "/v1/ip-pools{{.pool_name}}"
    uri := resolveRelative(c.server, path)

    // Create the request.
    req, err := http.NewRequest("DELETE", uri, nil)
    if err != nil {
        return fmt.Errorf("error creating request: %v", err)
    }

    // Add the parameters to the url.
    if err := expandURL(req.URL, map[string]string{ 
        "pool_name": string(params.PoolName),
    }); err != nil {
        return fmt.Errorf("expanding URL with parameters failed: %v", err)
    }

    // Add query if any
    if err := addQueries(req.URL, map[string]string{ 
    }); err != nil {
        return fmt.Errorf("adding queries to URL failed: %v", err)
    }

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Check the response.
    if err := checkResponse(resp); err != nil {
        return err
    }

    return nil
}

