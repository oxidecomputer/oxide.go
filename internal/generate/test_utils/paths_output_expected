// Code generated by `generate.test`. DO NOT EDIT.

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package oxide

// IpPoolList: List IP pools
//
// To iterate over all pages, use the `IpPoolListAllPages` method, instead.
func (c *Client) IpPoolList(ctx context.Context, params IpPoolListParams, ) (*IpPoolResultsPage, error) { 
    if err := params.Validate(); err != nil {
		return nil, err
	}
    // Create the request
    req, err := c.buildRequest(
        ctx,
        nil, 
        "GET", 
        resolveRelative(c.host, "/v1/system/ip-pools"), 
        map[string]string{ 
        }, 
        map[string]string{ 
            "limit": PointerIntToStr(params.Limit),
            "page_token": params.PageToken,
            "sort_by": string(params.SortBy),
        },
    )
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Create and return an HTTPError when an error response code is received.
    if err := NewHTTPError(resp); err != nil {
        return nil, err
    }

    // Decode the body from the response.
    if resp.Body == nil {
        return nil, errors.New("request returned an empty body in the response")
    }

    var body IpPoolResultsPage
    if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
        return nil, fmt.Errorf("error decoding response body: %v", err)
    }

    // Return the response.
    return &body, nil
}

// IpPoolListAllPages: List IP pools
//
// This method is a wrapper around the `IpPoolList` method.
// This method returns all the pages at once.
func (c *Client) IpPoolListAllPages(ctx context.Context, params IpPoolListParams, ) ([]IpPool, error) { 
	if err := params.Validate(); err != nil {
		return nil, err
	}
	var allPages []IpPool
	params.PageToken = ""
	params.Limit = NewPointer(100)
	for {
		page, err := c.IpPoolList(ctx, params)
		if err != nil {
			return nil, err
		}
		allPages = append(allPages, page.Items...)
		if page.NextPage == "" || page.NextPage == params.PageToken {
			break
		}
		params.PageToken = page.NextPage
	}

	return allPages, nil
}

// IpPoolCreate: Create an IP pool
func (c *Client) IpPoolCreate(ctx context.Context, params IpPoolCreateParams, ) (*IpPool, error) { 
    if err := params.Validate(); err != nil {
		return nil, err
	}
    // Encode the request body as json.
    b := new(bytes.Buffer)
    if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
        return nil, fmt.Errorf("encoding json body request failed: %v", err)
    }

    // Create the request
    req, err := c.buildRequest(
        ctx,
        b, 
        "POST", 
        resolveRelative(c.host, "/v1/system/ip-pools"), 
        map[string]string{ 
        }, 
        map[string]string{ 
        },
    )
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Create and return an HTTPError when an error response code is received.
    if err := NewHTTPError(resp); err != nil {
        return nil, err
    }

    // Decode the body from the response.
    if resp.Body == nil {
        return nil, errors.New("request returned an empty body in the response")
    }

    var body IpPool
    if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
        return nil, fmt.Errorf("error decoding response body: %v", err)
    }

    // Return the response.
    return &body, nil
}

// IpPoolView: Fetch an IP pool
func (c *Client) IpPoolView(ctx context.Context, params IpPoolViewParams, ) (*IpPool, error) { 
    if err := params.Validate(); err != nil {
		return nil, err
	}
    // Create the request
    req, err := c.buildRequest(
        ctx,
        nil, 
        "GET", 
        resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}"), 
        map[string]string{ 
            "pool": string(params.Pool),
        }, 
        map[string]string{ 
        },
    )
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Create and return an HTTPError when an error response code is received.
    if err := NewHTTPError(resp); err != nil {
        return nil, err
    }

    // Decode the body from the response.
    if resp.Body == nil {
        return nil, errors.New("request returned an empty body in the response")
    }

    var body IpPool
    if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
        return nil, fmt.Errorf("error decoding response body: %v", err)
    }

    // Return the response.
    return &body, nil
}

// IpPoolUpdate: Update an IP Pool
func (c *Client) IpPoolUpdate(ctx context.Context, params IpPoolUpdateParams, ) (*IpPool, error) { 
    if err := params.Validate(); err != nil {
		return nil, err
	}
    // Encode the request body as json.
    b := new(bytes.Buffer)
    if err := c.newJSONEncoder(b).Encode(params.Body); err != nil {
        return nil, fmt.Errorf("encoding json body request failed: %v", err)
    }

    // Create the request
    req, err := c.buildRequest(
        ctx,
        b, 
        "PUT", 
        resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}"), 
        map[string]string{ 
            "pool": string(params.Pool),
        }, 
        map[string]string{ 
        },
    )
	if err != nil {
		return nil, fmt.Errorf("error building request: %v", err)
	}

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return nil, fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Create and return an HTTPError when an error response code is received.
    if err := NewHTTPError(resp); err != nil {
        return nil, err
    }

    // Decode the body from the response.
    if resp.Body == nil {
        return nil, errors.New("request returned an empty body in the response")
    }

    var body IpPool
    if err := c.newJSONDecoder(resp.Body).Decode(&body); err != nil {
        return nil, fmt.Errorf("error decoding response body: %v", err)
    }

    // Return the response.
    return &body, nil
}

// IpPoolDelete: Delete an IP Pool
func (c *Client) IpPoolDelete(ctx context.Context, params IpPoolDeleteParams, ) error { 
    if err := params.Validate(); err != nil {
		return err
	}
    // Create the request
    req, err := c.buildRequest(
        ctx,
        nil, 
        "DELETE", 
        resolveRelative(c.host, "/v1/system/ip-pools/{{.pool}}"), 
        map[string]string{ 
            "pool": string(params.Pool),
        }, 
        map[string]string{ 
        },
    )
	if err != nil {
		return fmt.Errorf("error building request: %v", err)
	}

    // Send the request.
    resp, err := c.client.Do(req)
    if err != nil {
        return fmt.Errorf("error sending request: %v", err)
    }
    defer resp.Body.Close()

    // Create and return an HTTPError when an error response code is received.
    if err := NewHTTPError(resp); err != nil {
        return err
    }

    return nil
}

